(function () {
	'use strict';

	/** A global state object at the top of the reference chain. */
	const G$1 = {
	    modification: null,
	    game: null,
	    menu: null,
	    lobby: null
	};
	//# sourceMappingURL=global.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Implementation of a quaternion. */
	class Quaternion$1 {
	    constructor(x = 0, y = 0, z = 0, w = 1) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    /** Sets x, y, z, w properties of this quaternion. */
	    set(x, y, z, w) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	        return this;
	    }
	    /** Creates a new Quaternion with identical x, y, z and w properties to this one. */
	    clone() {
	        return new Quaternion$1(this.x, this.y, this.z, this.w);
	    }
	    /** Copies the x, y, z and w properties of `q` into this quaternion. */
	    copy(quaternion) {
	        this.x = quaternion.x;
	        this.y = quaternion.y;
	        this.z = quaternion.z;
	        this.w = quaternion.w;
	        return this;
	    }
	    /** Sets this quaternion from the rotation specified by Euler angle. */
	    setFromEuler(euler) {
	        const x = euler.x, y = euler.y, z = euler.z, order = euler.order;
	        // http://www.mathworks.com/matlabcentral/fileexchange/
	        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	        //	content/SpinCalc.m
	        const cos = Math.cos;
	        const sin = Math.sin;
	        const c1 = cos(x / 2);
	        const c2 = cos(y / 2);
	        const c3 = cos(z / 2);
	        const s1 = sin(x / 2);
	        const s2 = sin(y / 2);
	        const s3 = sin(z / 2);
	        switch (order) {
	            case "XYZ":
	                this.x = s1 * c2 * c3 + c1 * s2 * s3;
	                this.y = c1 * s2 * c3 - s1 * c2 * s3;
	                this.z = c1 * c2 * s3 + s1 * s2 * c3;
	                this.w = c1 * c2 * c3 - s1 * s2 * s3;
	                break;
	            case "YXZ":
	                this.x = s1 * c2 * c3 + c1 * s2 * s3;
	                this.y = c1 * s2 * c3 - s1 * c2 * s3;
	                this.z = c1 * c2 * s3 - s1 * s2 * c3;
	                this.w = c1 * c2 * c3 + s1 * s2 * s3;
	                break;
	            case "ZXY":
	                this.x = s1 * c2 * c3 - c1 * s2 * s3;
	                this.y = c1 * s2 * c3 + s1 * c2 * s3;
	                this.z = c1 * c2 * s3 + s1 * s2 * c3;
	                this.w = c1 * c2 * c3 - s1 * s2 * s3;
	                break;
	            case "ZYX":
	                this.x = s1 * c2 * c3 - c1 * s2 * s3;
	                this.y = c1 * s2 * c3 + s1 * c2 * s3;
	                this.z = c1 * c2 * s3 - s1 * s2 * c3;
	                this.w = c1 * c2 * c3 + s1 * s2 * s3;
	                break;
	            case "YZX":
	                this.x = s1 * c2 * c3 + c1 * s2 * s3;
	                this.y = c1 * s2 * c3 + s1 * c2 * s3;
	                this.z = c1 * c2 * s3 - s1 * s2 * c3;
	                this.w = c1 * c2 * c3 - s1 * s2 * s3;
	                break;
	            case "XZY":
	                this.x = s1 * c2 * c3 - c1 * s2 * s3;
	                this.y = c1 * s2 * c3 - s1 * c2 * s3;
	                this.z = c1 * c2 * s3 + s1 * s2 * c3;
	                this.w = c1 * c2 * c3 + s1 * s2 * s3;
	                break;
	            default:
	                console.warn("Quaternion: .setFromEuler() encountered an unknown order: " + order);
	        }
	        return this;
	    }
	    /** Sets this quaternion from rotation specified by `axis` and `angle`. Axis is assumed to be normalized, angle is in radians. */
	    setFromAxisAngle(axis, angle) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	        // assumes axis is normalized
	        const halfAngle = angle / 2, s = Math.sin(halfAngle);
	        this.x = axis.x * s;
	        this.y = axis.y * s;
	        this.z = axis.z * s;
	        this.w = Math.cos(halfAngle);
	        return this;
	    }
	    /** Sets this quaternion from rotation component of `m`. */
	    setFromRotationMatrix(m) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
	        if (trace > 0) {
	            const s = 0.5 / Math.sqrt(trace + 1.0);
	            this.w = 0.25 / s;
	            this.x = (m32 - m23) * s;
	            this.y = (m13 - m31) * s;
	            this.z = (m21 - m12) * s;
	        }
	        else if (m11 > m22 && m11 > m33) {
	            const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
	            this.w = (m32 - m23) / s;
	            this.x = 0.25 * s;
	            this.y = (m12 + m21) / s;
	            this.z = (m13 + m31) / s;
	        }
	        else if (m22 > m33) {
	            const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
	            this.w = (m13 - m31) / s;
	            this.x = (m12 + m21) / s;
	            this.y = 0.25 * s;
	            this.z = (m23 + m32) / s;
	        }
	        else {
	            const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
	            this.w = (m21 - m12) / s;
	            this.x = (m13 + m31) / s;
	            this.y = (m23 + m32) / s;
	            this.z = 0.25 * s;
	        }
	        return this;
	    }
	    /** Sets this quaternion to the rotation required to rotate direction vector `vFrom` to direction vector `vTo`. `vFrom` and `vTo` are assumed to be normalized. */
	    setFromUnitVectors(vFrom, vTo) {
	        // assumes direction vectors vFrom and vTo are normalized
	        let r = vFrom.dot(vTo) + 1;
	        if (r < Number.EPSILON) {
	            // vFrom and vTo point in opposite directions
	            r = 0;
	            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	                this.x = -vFrom.y;
	                this.y = vFrom.x;
	                this.z = 0;
	                this.w = r;
	            }
	            else {
	                this.x = 0;
	                this.y = -vFrom.z;
	                this.z = vFrom.y;
	                this.w = r;
	            }
	        }
	        else {
	            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
	            this.x = vFrom.y * vTo.z - vFrom.z * vTo.y;
	            this.y = vFrom.z * vTo.x - vFrom.x * vTo.z;
	            this.z = vFrom.x * vTo.y - vFrom.y * vTo.x;
	            this.w = r;
	        }
	        return this.normalize();
	    }
	    /** Returns the angle between this quaternion and quaternion `q` in radians. */
	    angleTo(q) {
	        return 2 * Math.acos(Math.abs(Util$1.clamp(this.dot(q), -1, 1)));
	    }
	    /** Rotates this quaternion by a given angular step to the defined quaternion `q`. The method ensures that the final quaternion will not overshoot `q`. */
	    rotateTowards(q, step) {
	        const angle = this.angleTo(q);
	        if (angle === 0)
	            return this;
	        const t = Math.min(1, step / angle);
	        this.slerp(q, t);
	        return this;
	    }
	    /** Sets this quaternion to the identity quaternion; that is, to the quaternion that represents "no rotation". */
	    identity() {
	        return this.set(0, 0, 0, 1);
	    }
	    /** Inverts this quaternion - calculates the conjugate. The quaternion is assumed to have unit length. */
	    invert() {
	        // quaternion is assumed to have unit length
	        return this.conjugate();
	    }
	    /** Returns the rotational conjugate of this quaternion. The conjugate of a quaternion represents the same rotation in the opposite direction about the rotational axis. */
	    conjugate() {
	        this.x *= -1;
	        this.y *= -1;
	        this.z *= -1;
	        return this;
	    }
	    /** Calculates the dot product of quaternions `v` and this one. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    }
	    /** Computes the squared Euclidean length (straight-line length) of this quaternion, considered as a 4 dimensional vector. */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	    }
	    /** Computes the Euclidean length (straight-line length) of this quaternion, considered as a 4 dimensional vector. */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    }
	    /** Normalizes this quaternion - that is, calculated the quaternion that performs the same rotation as this one, but has length equal to 1. */
	    normalize() {
	        let l = this.length();
	        if (l === 0) {
	            this.x = 0;
	            this.y = 0;
	            this.z = 0;
	            this.w = 1;
	        }
	        else {
	            l = 1 / l;
	            this.x = this.x * l;
	            this.y = this.y * l;
	            this.z = this.z * l;
	            this.w = this.w * l;
	        }
	        return this;
	    }
	    /** Multiplies this quaternion by `q`. */
	    multiply(q) {
	        return this.multiplyQuaternions(this, q);
	    }
	    /** Pre-multiplies this quaternion by `q`. */
	    premultiply(q) {
	        return this.multiplyQuaternions(q, this);
	    }
	    /** Sets this quaternion to `a` x `b`. */
	    multiplyQuaternions(a, b) {
	        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	        const qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
	        const qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
	        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	        return this;
	    }
	    /** Handles the spherical linear interpolation between quaternions. t represents the amount of rotation between this quaternion (where `t` is 0) and `qb` (where `t` is 1). This quaternion is set to the result. */
	    slerp(qb, t) {
	        if (t === 0)
	            return this;
	        if (t === 1)
	            return this.copy(qb);
	        const x = this.x, y = this.y, z = this.z, w = this.w;
	        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	        let cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
	        if (cosHalfTheta < 0) {
	            this.w = -qb.w;
	            this.x = -qb.x;
	            this.y = -qb.y;
	            this.z = -qb.z;
	            cosHalfTheta = -cosHalfTheta;
	        }
	        else {
	            this.copy(qb);
	        }
	        if (cosHalfTheta >= 1.0) {
	            this.w = w;
	            this.x = x;
	            this.y = y;
	            this.z = z;
	            return this;
	        }
	        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
	        if (sqrSinHalfTheta <= Number.EPSILON) {
	            const s = 1 - t;
	            this.w = s * w + t * this.w;
	            this.x = s * x + t * this.x;
	            this.y = s * y + t * this.y;
	            this.z = s * z + t * this.z;
	            this.normalize();
	            return this;
	        }
	        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
	        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	        this.w = w * ratioA + this.w * ratioB;
	        this.x = x * ratioA + this.x * ratioB;
	        this.y = y * ratioA + this.y * ratioB;
	        this.z = z * ratioA + this.z * ratioB;
	        return this;
	    }
	    /** Performs a spherical linear interpolation between the given quaternions and stores the result in this quaternion. */
	    slerpQuaternions(qa, qb, t) {
	        return this.copy(qa).slerp(qb, t);
	    }
	    /** Sets this quaternion to a uniformly random, normalized quaternion. */
	    random() {
	        // Derived from http://planning.cs.uiuc.edu/node198.html
	        // Note, this source uses w, x, y, z ordering,
	        // so we swap the order below.
	        const u1 = Math.random();
	        const sqrt1u1 = Math.sqrt(1 - u1);
	        const sqrtu1 = Math.sqrt(u1);
	        const u2 = 2 * Math.PI * Math.random();
	        const u3 = 2 * Math.PI * Math.random();
	        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
	    }
	    /** Compares the x, y, z and w properties of v to the equivalent properties of this quaternion to determine if they represent the same rotation. */
	    equals(quaternion) {
	        return (quaternion.x === this.x && quaternion.y === this.y && quaternion.z === this.z && quaternion.w === this.w);
	    }
	    /** Sets this quaternion's x, y, z and w properties from an array. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        this.w = array[offset + 3];
	        return this;
	    }
	    /** Returns the numerical elements of this quaternion in an array of format [x, y, z, w]. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.w;
	        return array;
	    }
	    /** Sets this quaternion's x, y, z and w properties from an object. */
	    fromObject(object) {
	        this.x = object.x;
	        this.y = object.y;
	        this.z = object.z;
	        this.w = object.w;
	        return this;
	    }
	}
	//# sourceMappingURL=quaternion.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Class representing a 3D vector. */
	class Vector3$1 {
	    constructor(x = 0, y = 0, z = 0) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	    }
	    /** Sets the x, y and z components of this vector. */
	    set(x, y, z) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        return this;
	    }
	    /** Set the x, y and z values of this vector both equal to scalar. */
	    setScalar(scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        this.z = scalar;
	        return this;
	    }
	    /** Replace this vector's x value with x. */
	    setX(x) {
	        this.x = x;
	        return this;
	    }
	    /** Replace this vector's y value with y. */
	    setY(y) {
	        this.y = y;
	        return this;
	    }
	    /** Replace this vector's z value with z. */
	    setZ(z) {
	        this.z = z;
	        return this;
	    }
	    /** If index equals 0 set x to value. If index equals 1 set y to value. If index equals 2 set z to value */
	    setComponent(index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            case 2:
	                this.z = value;
	                break;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	        return this;
	    }
	    /** If index equals 0 returns the x value. If index equals 1 returns the y value. If index equals 2 returns the z value. */
	    getComponent(index) {
	        switch (index) {
	            case 0:
	                return this.x;
	            case 1:
	                return this.y;
	            case 2:
	                return this.z;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	    }
	    /** Returns a new vector3 with the same x, y and z values as this one. */
	    clone() {
	        return new Vector3$1(this.x, this.y, this.z);
	    }
	    /** Copies the values of the passed vector3's x, y and z properties to this vector3. */
	    copy(v) {
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        return this;
	    }
	    /** Adds v to this vector. */
	    add(v) {
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;
	        return this;
	    }
	    /** Adds the scalar value s to this vector's x, y and z values. */
	    addScalar(s) {
	        this.x += s;
	        this.y += s;
	        this.z += s;
	        return this;
	    }
	    /** Sets this vector to a + b. */
	    addVectors(a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        return this;
	    }
	    /** Adds the multiple of v and s to this vector. */
	    addScaledVector(v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        this.z += v.z * s;
	        return this;
	    }
	    /** Subtracts v from this vector. */
	    sub(v) {
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        return this;
	    }
	    /** Subtracts s from this vector's x, y and z components. */
	    subScalar(s) {
	        this.x -= s;
	        this.y -= s;
	        this.z -= s;
	        return this;
	    }
	    /** Sets this vector to a - b. */
	    subVectors(a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        return this;
	    }
	    /** Multiplies this vector by v. */
	    multiply(v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z;
	        return this;
	    }
	    /** Multiplies this vector by scalar s. */
	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        this.z *= scalar;
	        return this;
	    }
	    /** Sets this vector equal to a * b, component-wise. */
	    multiplyVectors(a, b) {
	        this.x = a.x * b.x;
	        this.y = a.y * b.y;
	        this.z = a.z * b.z;
	        return this;
	    }
	    /** Applies euler transform to this vector by converting the Euler object to a Quaternion and applying. */
	    applyEuler(euler) {
	        return this.applyQuaternion(_quaternion.setFromEuler(euler));
	    }
	    /** Applies a rotation specified by an axis and an angle to this vector. */
	    applyAxisAngle(axis, angle) {
	        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
	    }
	    /** Multiplies this vector by m. */
	    applyMatrix3(m) {
	        const x = this.x, y = this.y, z = this.z;
	        const e = m.elements;
	        this.x = e[0] * x + e[3] * y + e[6] * z;
	        this.y = e[1] * x + e[4] * y + e[7] * z;
	        this.z = e[2] * x + e[5] * y + e[8] * z;
	        return this;
	    }
	    /** Multiplies this vector by normal matrix m and normalizes the result. */
	    applyNormalMatrix(m) {
	        return this.applyMatrix3(m).normalize();
	    }
	    /** Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective. */
	    applyMatrix4(m) {
	        const x = this.x, y = this.y, z = this.z;
	        const e = m.elements;
	        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
	        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
	        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
	        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
	        return this;
	    }
	    /** Applies a Quaternion transform to this vector. */
	    applyQuaternion(q) {
	        const x = this.x, y = this.y, z = this.z;
	        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	        // calculate quat * vector
	        const ix = qw * x + qy * z - qz * y;
	        const iy = qw * y + qz * x - qx * z;
	        const iz = qw * z + qx * y - qy * x;
	        const iw = -qx * x - qy * y - qz * z;
	        // calculate result * inverse quat
	        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	        return this;
	    }
	    /** Transforms the direction of this vector by a matrix (the upper left 3 x 3 subset of a m) and then normalizes the result. */
	    transformDirection(m) {
	        // input: Matrix4 affine matrix
	        // vector interpreted as a direction
	        const x = this.x, y = this.y, z = this.z;
	        const e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z;
	        this.y = e[1] * x + e[5] * y + e[9] * z;
	        this.z = e[2] * x + e[6] * y + e[10] * z;
	        return this.normalize();
	    }
	    /** Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective. */
	    divide(v) {
	        this.x /= v.x;
	        this.y /= v.y;
	        this.z /= v.z;
	        return this;
	    }
	    /** Divides this vector by scalar s. */
	    divideScalar(scalar) {
	        return this.multiplyScalar(1 / scalar);
	    }
	    /** If this vector's x, y or z value is greater than v's x, y or z value, replace that value with the corresponding min value. */
	    min(v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);
	        return this;
	    }
	    /** If this vector's x, y or z value is less than v's x, y or z value, replace that value with the corresponding max value. */
	    max(v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);
	        return this;
	    }
	    /** If this vector's x, y or z value is greater than the max vector's x, y or z value, it is replaced by the corresponding value. If this vector's x, y or z value is less than the min vector's x, y or z value, it is replaced by the corresponding value. */
	    clamp(min, max) {
	        // assumes min < max, componentwise
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        this.z = Math.max(min.z, Math.min(max.z, this.z));
	        return this;
	    }
	    /** If this vector's x, y or z values are greater than the max value, they are replaced by the max value. If this vector's x, y or z values are less than the min value, they are replaced by the min value. */
	    clampScalar(minVal, maxVal) {
	        this.x = Math.max(minVal, Math.min(maxVal, this.x));
	        this.y = Math.max(minVal, Math.min(maxVal, this.y));
	        this.z = Math.max(minVal, Math.min(maxVal, this.z));
	        return this;
	    }
	    /** If this vector's length is greater than the max value, the vector will be scaled down so its length is the max value. If this vector's length is less than the min value, the vector will be scaled up so its length is the min value. */
	    clampLength(min, max) {
	        const length = this.length();
	        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	    }
	    /** The components of this vector are rounded down to the nearest integer value. */
	    floor() {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        this.z = Math.floor(this.z);
	        return this;
	    }
	    /** The x, y and z components of this vector are rounded up to the nearest integer value. */
	    ceil() {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        this.z = Math.ceil(this.z);
	        return this;
	    }
	    /** The components of this vector are rounded to the nearest integer value. */
	    round() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        this.z = Math.round(this.z);
	        return this;
	    }
	    /** The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value. */
	    roundToZero() {
	        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
	        return this;
	    }
	    /** Inverts this vector - i.e. sets x = -x, y = -y and z = -z. */
	    negate() {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        return this;
	    }
	    /** Calculate the dot product of this vector and v. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z;
	    }
	    /** Computes the square of the Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z). */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y + this.z * this.z;
	    }
	    /** Computes the Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z). */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	    }
	    /** Computes the Manhattan length of this vector. */
	    manhattanLength() {
	        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	    }
	    /** Convert this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1. */
	    normalize() {
	        return this.divideScalar(this.length() || 1);
	    }
	    /** Set this vector to a vector with the same direction as this one, but length l. */
	    setLength(length) {
	        return this.normalize().multiplyScalar(length);
	    }
	    /** Linearly interpolate between this vector and v, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v. */
	    lerp(v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        this.z += (v.z - this.z) * alpha;
	        return this;
	    }
	    /** Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2. */
	    lerpVectors(v1, v2, alpha) {
	        this.x = v1.x + (v2.x - v1.x) * alpha;
	        this.y = v1.y + (v2.y - v1.y) * alpha;
	        this.z = v1.z + (v2.z - v1.z) * alpha;
	        return this;
	    }
	    /** Sets this vector to cross product of itself and v. */
	    cross(v) {
	        return this.crossVectors(this, v);
	    }
	    /** Sets this vector to cross product of a and b. */
	    crossVectors(a, b) {
	        const ax = a.x, ay = a.y, az = a.z;
	        const bx = b.x, by = b.y, bz = b.z;
	        this.x = ay * bz - az * by;
	        this.y = az * bx - ax * bz;
	        this.z = ax * by - ay * bx;
	        return this;
	    }
	    /** Projects this vector onto v. */
	    projectOnVector(v) {
	        const denominator = v.lengthSq();
	        if (denominator === 0)
	            return this.set(0, 0, 0);
	        const scalar = v.dot(this) / denominator;
	        return this.copy(v).multiplyScalar(scalar);
	    }
	    /** Projects this vector onto a plane by subtracting this vector projected onto the plane's normal from this vector. */
	    projectOnPlane(planeNormal) {
	        _vector.copy(this).projectOnVector(planeNormal);
	        return this.sub(_vector);
	    }
	    /** Reflect this vector off of plane orthogonal to normal. Normal is assumed to have unit length. */
	    reflect(normal) {
	        // reflect incident vector off plane orthogonal to normal
	        // normal is assumed to have unit length
	        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
	    }
	    /** Returns the angle between this vector and vector v in radians. */
	    angleTo(v) {
	        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	        if (denominator === 0)
	            return Math.PI / 2;
	        const theta = this.dot(v) / denominator;
	        // clamp, to handle numerical problems
	        return Math.acos(Util$1.clamp(theta, -1, 1));
	    }
	    /** Computes the distance from this vector to v. */
	    distanceTo(v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    }
	    /** Computes the squared distance from this vector to v. */
	    distanceToSquared(v) {
	        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	        return dx * dx + dy * dy + dz * dz;
	    }
	    /** Computes the Manhattan distance from this vector to v. */
	    manhattanDistanceTo(v) {
	        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	    }
	    /** Sets this vector to the position elements of the transformation matrix m. */
	    setFromMatrixPosition(m) {
	        const e = m.elements;
	        this.x = e[12];
	        this.y = e[13];
	        this.z = e[14];
	        return this;
	    }
	    /** Sets this vector to the scale elements of the transformation matrix m. */
	    setFromMatrixScale(m) {
	        const sx = this.setFromMatrixColumn(m, 0).length();
	        const sy = this.setFromMatrixColumn(m, 1).length();
	        const sz = this.setFromMatrixColumn(m, 2).length();
	        this.x = sx;
	        this.y = sy;
	        this.z = sz;
	        return this;
	    }
	    /** Sets this vector's x, y and z components from index column of matrix. */
	    setFromMatrixColumn(m, index) {
	        return this.fromArray(m.elements, index * 4);
	    }
	    /** Sets this vector's x, y and z components from index column of matrix. */
	    setFromMatrix3Column(m, index) {
	        return this.fromArray(m.elements, index * 3);
	    }
	    /** Returns true if the components of this vector and v are strictly equal; false otherwise. */
	    equals(v) {
	        return v.x === this.x && v.y === this.y && v.z === this.z;
	    }
	    /** Returns true if the components of this vector and v are strictly equal as 32-bit floats; false otherwise. */
	    fequals(v) {
	        return Math.fround(v.x) === Math.fround(this.x) && Math.fround(v.y) === Math.fround(this.y) && Math.fround(v.z) === Math.fround(this.z);
	    }
	    /** Sets this vector's x value to be array[offset + 0], y value to be array[offset + 1] and z value to be array[offset + 2]. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        return this;
	    }
	    /** Returns an array [x, y, z], or copies x, y and z into the provided array. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        return array;
	    }
	    /** Sets this vector's x, y and z values from an object. */
	    fromObject(object) {
	        this.x = object.x;
	        this.y = object.y;
	        this.z = object.z;
	        return this;
	    }
	    /** Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1. */
	    random() {
	        this.x = Math.random();
	        this.y = Math.random();
	        this.z = Math.random();
	        return this;
	    }
	    /** Sets this vector to a uniformly random point on a unit sphere. */
	    randomDirection() {
	        // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
	        const u = (Math.random() - 0.5) * 2;
	        const t = Math.random() * Math.PI * 2;
	        const f = Math.sqrt(1 - u ** 2);
	        this.x = f * Math.cos(t);
	        this.y = f * Math.sin(t);
	        this.z = u;
	        return this;
	    }
	    /** Turns each component's value into its absolute value. */
	    abs() {
	        this.x = Math.abs(this.x);
	        this.y = Math.abs(this.y);
	        this.z = Math.abs(this.z);
	        return this;
	    }
	    cubicHermite(p0, m0, p1, m1, t) {
	        let b0 = 2 * t ** 3 - 3 * t ** 2 + 1;
	        let b1 = t ** 3 - 2 * t ** 2 + t;
	        let b2 = -2 * t ** 3 + 3 * t ** 2;
	        let b3 = t ** 3 - t ** 2;
	        _vector.setScalar(0)
	            .addScaledVector(p0, b0)
	            .addScaledVector(m0, b1)
	            .addScaledVector(p1, b2)
	            .addScaledVector(m1, b3);
	        return this.copy(_vector);
	    }
	    cubicHermiteDerivative(p0, m0, p1, m1, t) {
	        let b0 = 6 * t ** 2 - 6 * t;
	        let b1 = 3 * t ** 2 - 4 * t + 1;
	        let b2 = -6 * t ** 2 + 6 * t;
	        let b3 = 3 * t ** 2 - 2 * t;
	        _vector.setScalar(0)
	            .addScaledVector(p0, b0)
	            .addScaledVector(m0, b1)
	            .addScaledVector(p1, b2)
	            .addScaledVector(m1, b3);
	        return this.copy(_vector);
	    }
	    *[Symbol.iterator]() {
	        yield this.x;
	        yield this.y;
	        yield this.z;
	    }
	}
	const _vector = new Vector3$1();
	const _quaternion = new Quaternion$1();
	//# sourceMappingURL=vector3.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Represents an axis-aligned bounding box (AABB) in 3D space. */
	class Box3 {
	    constructor(min = new Vector3$1(+Infinity, +Infinity, +Infinity), max = new Vector3$1(-Infinity, -Infinity, -Infinity)) {
	        this.min = min;
	        this.max = max;
	    }
	    /** Sets the lower and upper (x, y, z) boundaries of this box. */
	    set(min, max) {
	        this.min.copy(min);
	        this.max.copy(max);
	        return this;
	    }
	    /** Sets the upper and lower bounds of this box to include all of the data in `array`. */
	    setFromArray(array) {
	        let minX = +Infinity;
	        let minY = +Infinity;
	        let minZ = +Infinity;
	        let maxX = -Infinity;
	        let maxY = -Infinity;
	        let maxZ = -Infinity;
	        for (let i = 0, l = array.length; i < l; i += 3) {
	            const x = array[i];
	            const y = array[i + 1];
	            const z = array[i + 2];
	            if (x < minX)
	                minX = x;
	            if (y < minY)
	                minY = y;
	            if (z < minZ)
	                minZ = z;
	            if (x > maxX)
	                maxX = x;
	            if (y > maxY)
	                maxY = y;
	            if (z > maxZ)
	                maxZ = z;
	        }
	        this.min.set(minX, minY, minZ);
	        this.max.set(maxX, maxY, maxZ);
	        return this;
	    }
	    /** Sets the upper and lower bounds of this box to include all of the points in `points`. */
	    setFromPoints(points) {
	        this.makeEmpty();
	        for (let i = 0, il = points.length; i < il; i++) {
	            this.expandByPoint(points[i]);
	        }
	        return this;
	    }
	    /** Centers this box on `center` and sets this box's width, height and depth to the values specified in `size`. */
	    setFromCenterAndSize(center, size) {
	        const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
	        this.min.copy(center).sub(halfSize);
	        this.max.copy(center).add(halfSize);
	        return this;
	    }
	    /** Returns a new Box3 with the same min and max as this one. */
	    clone() {
	        return new Box3().copy(this);
	    }
	    /** Copies the min and max from `box` to this box. */
	    copy(box) {
	        this.min.copy(box.min);
	        this.max.copy(box.max);
	        return this;
	    }
	    /** Makes this box empty. */
	    makeEmpty() {
	        this.min.x = this.min.y = this.min.z = +Infinity;
	        this.max.x = this.max.y = this.max.z = -Infinity;
	        return this;
	    }
	    /** Returns true if this box includes zero points within its bounds. Note that a box with equal lower and upper bounds still includes one point, the one both bounds share. */
	    isEmpty() {
	        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	    }
	    /** Returns the center point of the box as a Vector3. */
	    getCenter(target) {
	        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	    }
	    /** Returns the width, height and depth of this box. */
	    getSize(target) {
	        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	    }
	    /** Expands the boundaries of this box to include point. */
	    expandByPoint(point) {
	        this.min.min(point);
	        this.max.max(point);
	        return this;
	    }
	    /** Expands this box equilaterally by vector. The width of this box will be expanded by the x component of vector in both directions. The height of this box will be expanded by the y component of vector in both directions. The depth of this box will be expanded by the z component of vector in both directions. */
	    expandByVector(vector) {
	        this.min.sub(vector);
	        this.max.add(vector);
	        return this;
	    }
	    /** Expands each dimension of the box by scalar. If negative, the dimensions of the box will be contracted. */
	    expandByScalar(scalar) {
	        this.min.addScalar(-scalar);
	        this.max.addScalar(scalar);
	        return this;
	    }
	    /** Returns true if the specified point lies within or on the boundaries of this box. */
	    containsPoint(point) {
	        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
	    }
	    /** Returns true if this box includes the entirety of box. If this and box are identical, this function also returns true. */
	    containsBox(box) {
	        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	    }
	    /** Returns a point as a proportion of this box's width, height and depth. */
	    getParameter(point, target) {
	        // This can potentially have a divide by zero if the box
	        // has a size dimension of 0.
	        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	    }
	    /** Determines whether or not this box intersects box. */
	    intersectsBox(box) {
	        // using 6 splitting planes to rule out intersections.
	        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	    }
	    /** Clamps the point within the bounds of this box. */
	    clampPoint(point, target) {
	        return target.copy(point).clamp(this.min, this.max);
	    }
	    /** Returns the distance from any edge of this box to the specified point. If the point lies inside of this box, the distance will be 0. */
	    distanceToPoint(point) {
	        const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
	        return clampedPoint.sub(point).length();
	    }
	    /** Computes the intersection of this and `box`, setting the upper bound of this box to the lesser of the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' lower bounds. If there's no overlap, makes this box empty. */
	    intersect(box) {
	        this.min.max(box.min);
	        this.max.min(box.max);
	        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
	        if (this.isEmpty())
	            this.makeEmpty();
	        return this;
	    }
	    /** Computes the union of this box and `box`, setting the upper bound of this box to the greater of the two boxes' upper bounds and the lower bound of this box to the lesser of the two boxes' lower bounds. */
	    union(box) {
	        this.min.min(box.min);
	        this.max.max(box.max);
	        return this;
	    }
	    /** Transforms this Box3 with the supplied matrix. */
	    applyMatrix4(matrix) {
	        // transform of empty box is an empty box.
	        if (this.isEmpty())
	            return this;
	        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
	        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
	        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
	        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
	        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
	        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
	        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
	        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
	        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
	        this.setFromPoints(_points);
	        return this;
	    }
	    /** Adds `offset` to both the upper and lower bounds of this box, effectively moving this box offset units in 3D space. */
	    translate(offset) {
	        this.min.add(offset);
	        this.max.add(offset);
	        return this;
	    }
	    /** Returns true if this box and `box` share the same lower and upper bounds. */
	    equals(box) {
	        return box.min.equals(this.min) && box.max.equals(this.max);
	    }
	}
	const _points = [new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1()];
	const _vector$1 = new Vector3$1();
	//# sourceMappingURL=box3.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** A class representing a 3x3 matrix. Defaults to the identity matrix. */
	class Matrix3 {
	    constructor() {
	        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    }
	    /** Sets the 3x3 matrix values to the given row-major sequence of values. */
	    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	        const te = this.elements;
	        te[0] = n11;
	        te[1] = n21;
	        te[2] = n31;
	        te[3] = n12;
	        te[4] = n22;
	        te[5] = n32;
	        te[6] = n13;
	        te[7] = n23;
	        te[8] = n33;
	        return this;
	    }
	    /** Resets this matrix to the 3x3 identity matrix. */
	    identity() {
	        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	        return this;
	    }
	    /** Copies the elements of matrix m into this matrix. */
	    copy(m) {
	        const te = this.elements;
	        const me = m.elements;
	        te[0] = me[0];
	        te[1] = me[1];
	        te[2] = me[2];
	        te[3] = me[3];
	        te[4] = me[4];
	        te[5] = me[5];
	        te[6] = me[6];
	        te[7] = me[7];
	        te[8] = me[8];
	        return this;
	    }
	    /** Extracts the basis of this matrix into the three axis vectors provided. */
	    extractBasis(xAxis, yAxis, zAxis) {
	        xAxis.setFromMatrix3Column(this, 0);
	        yAxis.setFromMatrix3Column(this, 1);
	        zAxis.setFromMatrix3Column(this, 2);
	        return this;
	    }
	    /** Set this matrix to the upper 3x3 matrix of the Matrix4 `m`. */
	    setFromMatrix4(m) {
	        const me = m.elements;
	        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
	        return this;
	    }
	    /** Post-multiplies this matrix by `m`. */
	    multiply(m) {
	        return this.multiplyMatrices(this, m);
	    }
	    /** Pre-multiplies this matrix by `m`. */
	    premultiply(m) {
	        return this.multiplyMatrices(m, this);
	    }
	    /** Sets this matrix to `a` x `b`. */
	    multiplyMatrices(a, b) {
	        const ae = a.elements;
	        const be = b.elements;
	        const te = this.elements;
	        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
	        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
	        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
	        const b11 = be[0], b12 = be[3], b13 = be[6];
	        const b21 = be[1], b22 = be[4], b23 = be[7];
	        const b31 = be[2], b32 = be[5], b33 = be[8];
	        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
	        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
	        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
	        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
	        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
	        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
	        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
	        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
	        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
	        return this;
	    }
	    /** Multiplies every component of the matrix by the scalar value `s`. */
	    multiplyScalar(s) {
	        const te = this.elements;
	        te[0] *= s;
	        te[3] *= s;
	        te[6] *= s;
	        te[1] *= s;
	        te[4] *= s;
	        te[7] *= s;
	        te[2] *= s;
	        te[5] *= s;
	        te[8] *= s;
	        return this;
	    }
	    /** Adds `m` to this matrix, component-wise. */
	    add(m) {
	        for (let i = 0; i < 9; i++)
	            this.elements[i] += m.elements[i];
	        return this;
	    }
	    /** Subtracts `m` from this matrix, component-wise. */
	    sub(m) {
	        for (let i = 0; i < 9; i++)
	            this.elements[i] -= m.elements[i];
	        return this;
	    }
	    /** Computes and returns the determinant of this matrix. */
	    determinant() {
	        const te = this.elements;
	        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
	        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	    }
	    /** Inverts this matrix, using the analytic method. You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead. */
	    invert() {
	        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
	        if (det === 0)
	            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
	        const detInv = 1 / det;
	        te[0] = t11 * detInv;
	        te[1] = (n31 * n23 - n33 * n21) * detInv;
	        te[2] = (n32 * n21 - n31 * n22) * detInv;
	        te[3] = t12 * detInv;
	        te[4] = (n33 * n11 - n31 * n13) * detInv;
	        te[5] = (n31 * n12 - n32 * n11) * detInv;
	        te[6] = t13 * detInv;
	        te[7] = (n21 * n13 - n23 * n11) * detInv;
	        te[8] = (n22 * n11 - n21 * n12) * detInv;
	        return this;
	    }
	    /** Transposes this matrix in place. */
	    transpose() {
	        let tmp;
	        const m = this.elements;
	        tmp = m[1];
	        m[1] = m[3];
	        m[3] = tmp;
	        tmp = m[2];
	        m[2] = m[6];
	        m[6] = tmp;
	        tmp = m[5];
	        m[5] = m[7];
	        m[7] = tmp;
	        return this;
	    }
	    /** Sets this matrix as the upper left 3x3 of the normal matrix of the passed matrix4. The normal matrix is the inverse transpose of the matrix m. */
	    getNormalMatrix(matrix4) {
	        return this.setFromMatrix4(matrix4).invert().transpose();
	    }
	    /** Transposes this matrix into the supplied array, and returns itself unchanged. */
	    transposeIntoArray(r) {
	        const m = this.elements;
	        r[0] = m[0];
	        r[1] = m[3];
	        r[2] = m[6];
	        r[3] = m[1];
	        r[4] = m[4];
	        r[5] = m[7];
	        r[6] = m[2];
	        r[7] = m[5];
	        r[8] = m[8];
	        return this;
	    }
	    /** Sets the UV transform matrix from offset, repeat, rotation, and center. */
	    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
	        const c = Math.cos(rotation);
	        const s = Math.sin(rotation);
	        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
	        return this;
	    }
	    /** Scales this matrix. */
	    scale(sx, sy) {
	        const te = this.elements;
	        te[0] *= sx;
	        te[3] *= sx;
	        te[6] *= sx;
	        te[1] *= sy;
	        te[4] *= sy;
	        te[7] *= sy;
	        return this;
	    }
	    /** Rotates this matrix. */
	    rotate(theta) {
	        const c = Math.cos(theta);
	        const s = Math.sin(theta);
	        const te = this.elements;
	        const a11 = te[0], a12 = te[3], a13 = te[6];
	        const a21 = te[1], a22 = te[4], a23 = te[7];
	        te[0] = c * a11 + s * a21;
	        te[3] = c * a12 + s * a22;
	        te[6] = c * a13 + s * a23;
	        te[1] = -s * a11 + c * a21;
	        te[4] = -s * a12 + c * a22;
	        te[7] = -s * a13 + c * a23;
	        return this;
	    }
	    /** Translates this matrix. */
	    translate(tx, ty) {
	        const te = this.elements;
	        te[0] += tx * te[2];
	        te[3] += tx * te[5];
	        te[6] += tx * te[8];
	        te[1] += ty * te[2];
	        te[4] += ty * te[5];
	        te[7] += ty * te[8];
	        return this;
	    }
	    /** Return true if this matrix and m are equal. */
	    equals(matrix) {
	        const te = this.elements;
	        const me = matrix.elements;
	        for (let i = 0; i < 9; i++) {
	            if (te[i] !== me[i])
	                return false;
	        }
	        return true;
	    }
	    /** Sets the elements of this matrix based on an array in column-major format. */
	    fromArray(array, offset = 0) {
	        for (let i = 0; i < 9; i++) {
	            this.elements[i] = array[i + offset];
	        }
	        return this;
	    }
	    /** Writes the elements of this matrix to an array in column-major format. */
	    toArray(array = [], offset = 0) {
	        const te = this.elements;
	        array[offset] = te[0];
	        array[offset + 1] = te[1];
	        array[offset + 2] = te[2];
	        array[offset + 3] = te[3];
	        array[offset + 4] = te[4];
	        array[offset + 5] = te[5];
	        array[offset + 6] = te[6];
	        array[offset + 7] = te[7];
	        array[offset + 8] = te[8];
	        return array;
	    }
	    /** Creates a new Matrix3 and with identical elements to this one. */
	    clone() {
	        return new Matrix3().fromArray(this.elements);
	    }
	}
	//# sourceMappingURL=matrix3.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** A class representing a 4x4 matrix. Defaults to the identity matrix. */
	class Matrix4 {
	    constructor() {
	        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    }
	    /** Set the elements of this matrix to the supplied row-major values `n11`, `n12`, ... `n44`. */
	    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	        const te = this.elements;
	        te[0] = n11;
	        te[4] = n12;
	        te[8] = n13;
	        te[12] = n14;
	        te[1] = n21;
	        te[5] = n22;
	        te[9] = n23;
	        te[13] = n24;
	        te[2] = n31;
	        te[6] = n32;
	        te[10] = n33;
	        te[14] = n34;
	        te[3] = n41;
	        te[7] = n42;
	        te[11] = n43;
	        te[15] = n44;
	        return this;
	    }
	    /** Resets this matrix to the identity matrix. */
	    identity() {
	        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Creates a new Matrix4 with identical elements to this one. */
	    clone() {
	        return new Matrix4().fromArray(this.elements);
	    }
	    /** Copies the elements of matrix m into this matrix. */
	    copy(m) {
	        const te = this.elements;
	        const me = m.elements;
	        te[0] = me[0];
	        te[1] = me[1];
	        te[2] = me[2];
	        te[3] = me[3];
	        te[4] = me[4];
	        te[5] = me[5];
	        te[6] = me[6];
	        te[7] = me[7];
	        te[8] = me[8];
	        te[9] = me[9];
	        te[10] = me[10];
	        te[11] = me[11];
	        te[12] = me[12];
	        te[13] = me[13];
	        te[14] = me[14];
	        te[15] = me[15];
	        return this;
	    }
	    /** Copies the translation component of the supplied matrix m into this matrix's translation component. */
	    copyPosition(m) {
	        const te = this.elements, me = m.elements;
	        te[12] = me[12];
	        te[13] = me[13];
	        te[14] = me[14];
	        return this;
	    }
	    /** Set the upper 3x3 elements of this matrix to the values of the Matrix3 `m`. */
	    setFromMatrix3(m) {
	        const me = m.elements;
	        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Extracts the basis of this matrix into the three axis vectors provided. */
	    extractBasis(xAxis, yAxis, zAxis) {
	        xAxis.setFromMatrixColumn(this, 0);
	        yAxis.setFromMatrixColumn(this, 1);
	        zAxis.setFromMatrixColumn(this, 2);
	        return this;
	    }
	    /** Set this to the basis matrix consisting of the three provided basis vectors. */
	    makeBasis(xAxis, yAxis, zAxis) {
	        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Extracts the rotation component of the supplied matrix m into this matrix's rotation component. */
	    extractRotation(m) {
	        // this method does not support reflection matrices
	        const te = this.elements;
	        const me = m.elements;
	        const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
	        const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
	        const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();
	        te[0] = me[0] * scaleX;
	        te[1] = me[1] * scaleX;
	        te[2] = me[2] * scaleX;
	        te[3] = 0;
	        te[4] = me[4] * scaleY;
	        te[5] = me[5] * scaleY;
	        te[6] = me[6] * scaleY;
	        te[7] = 0;
	        te[8] = me[8] * scaleZ;
	        te[9] = me[9] * scaleZ;
	        te[10] = me[10] * scaleZ;
	        te[11] = 0;
	        te[12] = 0;
	        te[13] = 0;
	        te[14] = 0;
	        te[15] = 1;
	        return this;
	    }
	    /** Sets the rotation component (the upper left 3x3 matrix) of this matrix to the rotation specified by the given Euler Angle. The rest of the matrix is set to the identity. Depending on the order of the euler, there are six possible outcomes. */
	    makeRotationFromEuler(euler) {
	        const te = this.elements;
	        const x = euler.x, y = euler.y, z = euler.z;
	        const a = Math.cos(x), b = Math.sin(x);
	        const c = Math.cos(y), d = Math.sin(y);
	        const e = Math.cos(z), f = Math.sin(z);
	        if (euler.order === "XYZ") {
	            const ae = a * e, af = a * f, be = b * e, bf = b * f;
	            te[0] = c * e;
	            te[4] = -c * f;
	            te[8] = d;
	            te[1] = af + be * d;
	            te[5] = ae - bf * d;
	            te[9] = -b * c;
	            te[2] = bf - ae * d;
	            te[6] = be + af * d;
	            te[10] = a * c;
	        }
	        else if (euler.order === "YXZ") {
	            const ce = c * e, cf = c * f, de = d * e, df = d * f;
	            te[0] = ce + df * b;
	            te[4] = de * b - cf;
	            te[8] = a * d;
	            te[1] = a * f;
	            te[5] = a * e;
	            te[9] = -b;
	            te[2] = cf * b - de;
	            te[6] = df + ce * b;
	            te[10] = a * c;
	        }
	        else if (euler.order === "ZXY") {
	            const ce = c * e, cf = c * f, de = d * e, df = d * f;
	            te[0] = ce - df * b;
	            te[4] = -a * f;
	            te[8] = de + cf * b;
	            te[1] = cf + de * b;
	            te[5] = a * e;
	            te[9] = df - ce * b;
	            te[2] = -a * d;
	            te[6] = b;
	            te[10] = a * c;
	        }
	        else if (euler.order === "ZYX") {
	            const ae = a * e, af = a * f, be = b * e, bf = b * f;
	            te[0] = c * e;
	            te[4] = be * d - af;
	            te[8] = ae * d + bf;
	            te[1] = c * f;
	            te[5] = bf * d + ae;
	            te[9] = af * d - be;
	            te[2] = -d;
	            te[6] = b * c;
	            te[10] = a * c;
	        }
	        else if (euler.order === "YZX") {
	            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	            te[0] = c * e;
	            te[4] = bd - ac * f;
	            te[8] = bc * f + ad;
	            te[1] = f;
	            te[5] = a * e;
	            te[9] = -b * e;
	            te[2] = -d * e;
	            te[6] = ad * f + bc;
	            te[10] = ac - bd * f;
	        }
	        else if (euler.order === "XZY") {
	            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	            te[0] = c * e;
	            te[4] = -f;
	            te[8] = d * e;
	            te[1] = ac * f + bd;
	            te[5] = a * e;
	            te[9] = ad * f - bc;
	            te[2] = bc * f - ad;
	            te[6] = b * e;
	            te[10] = bd * f + ac;
	        }
	        // bottom row
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        // last column
	        te[12] = 0;
	        te[13] = 0;
	        te[14] = 0;
	        te[15] = 1;
	        return this;
	    }
	    /** Sets the rotation component of this matrix to the rotation specified by q, as outlined here (https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion). The rest of the matrix is set to the identity */
	    makeRotationFromQuaternion(q) {
	        return this.compose(_zero, q, _one);
	    }
	    /** Constructs a rotation matrix, looking from `eye` towards `target` oriented by the `up` vector. */
	    lookAt(eye, target, up) {
	        const te = this.elements;
	        _z.subVectors(eye, target);
	        if (_z.lengthSq() === 0) {
	            // eye and target are in the same position
	            _z.z = 1;
	        }
	        _z.normalize();
	        _x.crossVectors(up, _z);
	        if (_x.lengthSq() === 0) {
	            // up and z are parallel
	            if (Math.abs(up.z) === 1) {
	                _z.x += 0.0001;
	            }
	            else {
	                _z.z += 0.0001;
	            }
	            _z.normalize();
	            _x.crossVectors(up, _z);
	        }
	        _x.normalize();
	        _y.crossVectors(_z, _x);
	        te[0] = _x.x;
	        te[4] = _y.x;
	        te[8] = _z.x;
	        te[1] = _x.y;
	        te[5] = _y.y;
	        te[9] = _z.y;
	        te[2] = _x.z;
	        te[6] = _y.z;
	        te[10] = _z.z;
	        return this;
	    }
	    /** Post-multiplies this matrix by m. */
	    multiply(m) {
	        return this.multiplyMatrices(this, m);
	    }
	    /** Pre-multiplies this matrix by m. */
	    premultiply(m) {
	        return this.multiplyMatrices(m, this);
	    }
	    /** Sets this matrix to a x b. */
	    multiplyMatrices(a, b) {
	        const ae = a.elements;
	        const be = b.elements;
	        const te = this.elements;
	        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
	        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
	        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
	        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
	        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
	        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
	        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
	        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
	        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	        return this;
	    }
	    /** Multiplies every component of the matrix by a scalar value s. */
	    multiplyScalar(s) {
	        const te = this.elements;
	        te[0] *= s;
	        te[4] *= s;
	        te[8] *= s;
	        te[12] *= s;
	        te[1] *= s;
	        te[5] *= s;
	        te[9] *= s;
	        te[13] *= s;
	        te[2] *= s;
	        te[6] *= s;
	        te[10] *= s;
	        te[14] *= s;
	        te[3] *= s;
	        te[7] *= s;
	        te[11] *= s;
	        te[15] *= s;
	        return this;
	    }
	    /** Adds `m` to this matrix, component-wise. */
	    add(m) {
	        for (let i = 0; i < 16; i++)
	            this.elements[i] += m.elements[i];
	        return this;
	    }
	    /** Subtracts `m` from this matrix, component-wise. */
	    sub(m) {
	        for (let i = 0; i < 16; i++)
	            this.elements[i] -= m.elements[i];
	        return this;
	    }
	    /** Computes and returns the determinant of this matrix. */
	    determinant() {
	        const te = this.elements;
	        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
	        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
	        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
	        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
	        return (n41 *
	            (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) +
	            n42 *
	                (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) +
	            n43 *
	                (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) +
	            n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
	    }
	    /** Transposes this matrix. */
	    transpose() {
	        const te = this.elements;
	        let tmp;
	        tmp = te[1];
	        te[1] = te[4];
	        te[4] = tmp;
	        tmp = te[2];
	        te[2] = te[8];
	        te[8] = tmp;
	        tmp = te[6];
	        te[6] = te[9];
	        te[9] = tmp;
	        tmp = te[3];
	        te[3] = te[12];
	        te[12] = tmp;
	        tmp = te[7];
	        te[7] = te[13];
	        te[13] = tmp;
	        tmp = te[11];
	        te[11] = te[14];
	        te[14] = tmp;
	        return this;
	    }
	    /** Sets the position component for this matrix from vector v, without affecting the rest of the matrix. */
	    setPosition(x) {
	        const te = this.elements;
	        te[12] = x.x;
	        te[13] = x.y;
	        te[14] = x.z;
	        return this;
	    }
	    /** Inverts this matrix, using the analytic method. You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead. */
	    invert() {
	        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	        if (det === 0)
	            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
	        const detInv = 1 / det;
	        te[0] = t11 * detInv;
	        te[1] =
	            (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) *
	                detInv;
	        te[2] =
	            (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) *
	                detInv;
	        te[3] =
	            (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) *
	                detInv;
	        te[4] = t12 * detInv;
	        te[5] =
	            (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) *
	                detInv;
	        te[6] =
	            (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) *
	                detInv;
	        te[7] =
	            (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) *
	                detInv;
	        te[8] = t13 * detInv;
	        te[9] =
	            (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) *
	                detInv;
	        te[10] =
	            (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) *
	                detInv;
	        te[11] =
	            (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) *
	                detInv;
	        te[12] = t14 * detInv;
	        te[13] =
	            (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) *
	                detInv;
	        te[14] =
	            (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) *
	                detInv;
	        te[15] =
	            (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) *
	                detInv;
	        return this;
	    }
	    /** Multiplies the columns of this matrix by vector v. */
	    scale(v) {
	        const te = this.elements;
	        const x = v.x, y = v.y, z = v.z;
	        te[0] *= x;
	        te[4] *= y;
	        te[8] *= z;
	        te[1] *= x;
	        te[5] *= y;
	        te[9] *= z;
	        te[2] *= x;
	        te[6] *= y;
	        te[10] *= z;
	        te[3] *= x;
	        te[7] *= y;
	        te[11] *= z;
	        return this;
	    }
	    /** Gets the maximum scale value of the 3 axes. */
	    getMaxScaleOnAxis() {
	        const te = this.elements;
	        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	    }
	    /** Sets this matrix as a translation transform. */
	    makeTranslation(x, y, z) {
	        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a rotational transformation around the X axis by theta (θ) radians. */
	    makeRotationX(theta) {
	        const c = Math.cos(theta), s = Math.sin(theta);
	        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a rotational transformation around the Y axis by theta (θ) radians. */
	    makeRotationY(theta) {
	        const c = Math.cos(theta), s = Math.sin(theta);
	        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a rotational transformation around the Z axis by theta (θ) radians. */
	    makeRotationZ(theta) {
	        const c = Math.cos(theta), s = Math.sin(theta);
	        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as rotation transform around axis by theta radians. */
	    makeRotationAxis(axis, angle) {
	        // Based on http://www.gamedev.net/reference/articles/article1199.asp
	        const c = Math.cos(angle);
	        const s = Math.sin(angle);
	        const t = 1 - c;
	        const x = axis.x, y = axis.y, z = axis.z;
	        const tx = t * x, ty = t * y;
	        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as scale transform. */
	    makeScale(x, y, z) {
	        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix as a shear transform. */
	    makeShear(xy, xz, yx, yz, zx, zy) {
	        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
	        return this;
	    }
	    /** Sets this matrix to the transformation composed of position, quaternion and scale. */
	    compose(position, quaternion, scale) {
	        const te = this.elements;
	        const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
	        const x2 = x + x, y2 = y + y, z2 = z + z;
	        const xx = x * x2, xy = x * y2, xz = x * z2;
	        const yy = y * y2, yz = y * z2, zz = z * z2;
	        const wx = w * x2, wy = w * y2, wz = w * z2;
	        const sx = scale.x, sy = scale.y, sz = scale.z;
	        te[0] = (1 - (yy + zz)) * sx;
	        te[1] = (xy + wz) * sx;
	        te[2] = (xz - wy) * sx;
	        te[3] = 0;
	        te[4] = (xy - wz) * sy;
	        te[5] = (1 - (xx + zz)) * sy;
	        te[6] = (yz + wx) * sy;
	        te[7] = 0;
	        te[8] = (xz + wy) * sz;
	        te[9] = (yz - wx) * sz;
	        te[10] = (1 - (xx + yy)) * sz;
	        te[11] = 0;
	        te[12] = position.x;
	        te[13] = position.y;
	        te[14] = position.z;
	        te[15] = 1;
	        return this;
	    }
	    /** Decomposes this matrix into its position, quaternion and scale components. Note: Not all matrices are decomposable in this way. For example, if an object has a non-uniformly scaled parent, then the object's world matrix may not be decomposable, and this method may not be appropriate. */
	    decompose(position, quaternion, scale) {
	        const te = this.elements;
	        let sx = _v1.set(te[0], te[1], te[2]).length();
	        const sy = _v1.set(te[4], te[5], te[6]).length();
	        const sz = _v1.set(te[8], te[9], te[10]).length();
	        // if determine is negative, we need to invert one scale
	        const det = this.determinant();
	        if (det < 0)
	            sx = -sx;
	        position.x = te[12];
	        position.y = te[13];
	        position.z = te[14];
	        // scale the rotation part
	        _m1.copy(this);
	        const invSX = 1 / sx;
	        const invSY = 1 / sy;
	        const invSZ = 1 / sz;
	        _m1.elements[0] *= invSX;
	        _m1.elements[1] *= invSX;
	        _m1.elements[2] *= invSX;
	        _m1.elements[4] *= invSY;
	        _m1.elements[5] *= invSY;
	        _m1.elements[6] *= invSY;
	        _m1.elements[8] *= invSZ;
	        _m1.elements[9] *= invSZ;
	        _m1.elements[10] *= invSZ;
	        quaternion.setFromRotationMatrix(_m1);
	        scale.x = sx;
	        scale.y = sy;
	        scale.z = sz;
	        return this;
	    }
	    /** Creates a perspective projection matrix. */
	    makePerspective(left, right, top, bottom, near, far) {
	        const te = this.elements;
	        const x = (2 * near) / (right - left);
	        const y = (2 * near) / (top - bottom);
	        const a = (right + left) / (right - left);
	        const b = (top + bottom) / (top - bottom);
	        const c = -(far + near) / (far - near);
	        const d = (-2 * far * near) / (far - near);
	        te[0] = x;
	        te[4] = 0;
	        te[8] = a;
	        te[12] = 0;
	        te[1] = 0;
	        te[5] = y;
	        te[9] = b;
	        te[13] = 0;
	        te[2] = 0;
	        te[6] = 0;
	        te[10] = c;
	        te[14] = d;
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = -1;
	        te[15] = 0;
	        return this;
	    }
	    /** Creates an orthographic projection matrix. */
	    makeOrthographic(left, right, top, bottom, near, far) {
	        const te = this.elements;
	        const w = 1.0 / (right - left);
	        const h = 1.0 / (top - bottom);
	        const p = 1.0 / (far - near);
	        const x = (right + left) * w;
	        const y = (top + bottom) * h;
	        const z = (far + near) * p;
	        te[0] = 2 * w;
	        te[4] = 0;
	        te[8] = 0;
	        te[12] = -x;
	        te[1] = 0;
	        te[5] = 2 * h;
	        te[9] = 0;
	        te[13] = -y;
	        te[2] = 0;
	        te[6] = 0;
	        te[10] = -2 * p;
	        te[14] = -z;
	        te[3] = 0;
	        te[7] = 0;
	        te[11] = 0;
	        te[15] = 1;
	        return this;
	    }
	    /** Return true if this matrix and `matrix` are equal. */
	    equals(matrix) {
	        const te = this.elements;
	        const me = matrix.elements;
	        for (let i = 0; i < 16; i++) {
	            if (te[i] !== me[i])
	                return false;
	        }
	        return true;
	    }
	    /** Sets the elements of this matrix based on an `array` in column-major format. */
	    fromArray(array, offset = 0) {
	        for (let i = 0; i < 16; i++) {
	            this.elements[i] = array[i + offset];
	        }
	        return this;
	    }
	    /** Writes the elements of this matrix to an array in column-major format. */
	    toArray(array = [], offset = 0) {
	        const te = this.elements;
	        array[offset] = te[0];
	        array[offset + 1] = te[1];
	        array[offset + 2] = te[2];
	        array[offset + 3] = te[3];
	        array[offset + 4] = te[4];
	        array[offset + 5] = te[5];
	        array[offset + 6] = te[6];
	        array[offset + 7] = te[7];
	        array[offset + 8] = te[8];
	        array[offset + 9] = te[9];
	        array[offset + 10] = te[10];
	        array[offset + 11] = te[11];
	        array[offset + 12] = te[12];
	        array[offset + 13] = te[13];
	        array[offset + 14] = te[14];
	        array[offset + 15] = te[15];
	        return array;
	    }
	}
	const _v1 = new Vector3$1();
	const _m1 = new Matrix4();
	const _zero = new Vector3$1(0, 0, 0);
	const _one = new Vector3$1(1, 1, 1);
	const _x = new Vector3$1();
	const _y = new Vector3$1();
	const _z = new Vector3$1();
	//# sourceMappingURL=matrix4.js.map

	let v1 = new Vector3$1();
	let v2 = new Vector3$1();
	let v3 = new Vector3$1();
	let v4 = new Vector3$1();
	let v5 = new Vector3$1();
	let m1 = new Matrix4();
	let q1 = new Quaternion$1();
	/** Represents a convex collision shape. */
	class CollisionShape {
	    constructor() {
	        /** The body this shape belongs to. */
	        this.body = null;
	        this.boundingBox = new Box3();
	        /** The collision margin of this shape, can be used to make the shape thiccer in all directions. */
	        this.margin = 0;
	        /** If set, this shape will be used instead for broadphase collision detection (allows for better caching). */
	        this.broadphaseShape = null;
	        this.collisionDetectionMask = 0b1;
	        this.collisionResponseMask = 0b1;
	        this.friction = 1;
	        this.restitution = 1;
	        this.mass = 1;
	        this.inertia = new Matrix3();
	        this.invInertia = new Matrix3();
	        /** Material overrides allow a single collision shape to have more than one material (i.e. friction and restitution). These properties are described by a direction vector (intended to be the normal vector of the face the material applies) to, and the material with the highest dot product with the collision normal is chosen. */
	        this.materialOverrides = new Map();
	    }
	    updateBoundingBox() {
	        var _a, _b;
	        m1.compose(this.body.position, this.body.orientation, v1.setScalar(1));
	        this.boundingBox.applyMatrix4(m1); // Puts a bounding box around the translated bounding box
	        this.boundingBox.min.subScalar(this.margin);
	        this.boundingBox.max.addScalar(this.margin);
	        if (this.body.prevValid) {
	            // Extend the bounding box towards the previous position for CCD purposes
	            let translation = v1.copy(this.body.position).sub(this.body.prevPosition);
	            v2.copy(this.boundingBox.min).sub(translation); // Go backwards
	            v3.copy(this.boundingBox.max).sub(translation);
	            this.boundingBox.expandByPoint(v2).expandByPoint(v3);
	        }
	        // Update the octree
	        (_b = (_a = this.body) === null || _a === void 0 ? void 0 : _a.world) === null || _b === void 0 ? void 0 : _b.octree.update(this);
	    }
	}
	/** Represents a ball with a given radius. */
	class BallCollisionShape extends CollisionShape {
	    constructor(radius) {
	        super();
	        this.radius = radius;
	        this.updateInertiaTensor();
	    }
	    updateInertiaTensor() {
	        let scalar = 2 / 5 * this.mass * this.radius ** 2;
	        this.inertia.identity().multiplyScalar(scalar);
	        this.invInertia.copy(this.inertia).invert();
	    }
	    support(dst, direction) {
	        dst.copy(direction).setLength(this.radius).add(this.body.position);
	        if (this.margin > 0)
	            dst.add(v1.copy(direction).setLength(this.margin));
	        return dst;
	    }
	    getCenter(dst) {
	        return dst.copy(this.body.position);
	    }
	    updateBoundingBox() {
	        this.boundingBox.min.setScalar(-this.radius);
	        this.boundingBox.max.setScalar(this.radius);
	        super.updateBoundingBox();
	    }
	}
	/** Represents the convex hull of a set of points. */
	class ConvexHullCollisionShape extends CollisionShape {
	    constructor(points) {
	        super();
	        this.localCenter = new Vector3$1();
	        this.localAabb = new Box3();
	        this.points = points;
	        this.computeLocalBoundingBox();
	        this.updateInertiaTensor();
	    }
	    computeLocalBoundingBox() {
	        // Precompute some stuff so it's faster later
	        this.localCenter.setScalar(0);
	        for (let point of this.points)
	            this.localCenter.addScaledVector(point, 1 / this.points.length);
	        this.localAabb.setFromPoints(this.points);
	    }
	    updateInertiaTensor() {
	        // Do nothing for now, we likely won't need it because there is no dynamic convex hull object
	    }
	    support(dst, direction) {
	        q1.copy(this.body.orientation).conjugate();
	        let localDirection = v1.copy(direction).applyQuaternion(q1); // Transform it to local space
	        let maxDot = -Infinity;
	        // Naive O(n) support function, loop over all points and find the one with the biggest dot
	        for (let i = 0; i < this.points.length; i++) {
	            let point = this.points[i];
	            let dot = point.dot(localDirection);
	            if (dot > maxDot) {
	                maxDot = dot;
	                dst.copy(point);
	            }
	        }
	        this.body.transformPoint(dst); // Transform it from local into world space
	        if (this.margin > 0)
	            dst.add(v1.copy(direction).setLength(this.margin));
	        return dst;
	    }
	    getCenter(dst) {
	        return this.body.transformPoint(dst.copy(this.localCenter));
	    }
	    updateBoundingBox() {
	        this.boundingBox.copy(this.localAabb);
	        super.updateBoundingBox();
	    }
	}
	/** Represents the convex hull of two other collision shapes. */
	class CombinedCollisionShape extends CollisionShape {
	    constructor(s1, s2) {
	        super();
	        this.s1 = s1;
	        this.s2 = s2;
	    }
	    updateInertiaTensor() { }
	    support(dst, direction) {
	        // Simply return the max of the two support functions
	        let supp1 = this.s1.support(v4, direction);
	        let supp2 = this.s2.support(v5, direction);
	        if (supp1.dot(direction) > supp2.dot(direction))
	            dst.copy(supp1);
	        else
	            dst.copy(supp2);
	        return dst;
	    }
	    getCenter(dst) {
	        // Return the average, this is probably not correct
	        return this.s1.getCenter(dst).add(this.s2.getCenter(v4)).multiplyScalar(0.5);
	    }
	}
	/** Represents the shape that's just a single dot at the origin, so C = { (0, 0, 0)^T } */
	class SingletonCollisionShape extends CollisionShape {
	    updateInertiaTensor() { }
	    support(dst) {
	        return dst.copy(this.body.position);
	    }
	    getCenter(dst) {
	        return dst.copy(this.body.position);
	    }
	}
	//# sourceMappingURL=collision_shape.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Class representing a 2D vector. */
	class Vector2 {
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    get width() {
	        return this.x;
	    }
	    set width(value) {
	        this.x = value;
	    }
	    get height() {
	        return this.y;
	    }
	    set height(value) {
	        this.y = value;
	    }
	    /** Sets the x and y components of this vector. */
	    set(x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    }
	    /** Sets the x and y values of this vector both equal to scalar. */
	    setScalar(scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        return this;
	    }
	    /** Replaces this vector's x value with `x`. */
	    setX(x) {
	        this.x = x;
	        return this;
	    }
	    /** Replaces this vector's y value with `y`. */
	    setY(y) {
	        this.y = y;
	        return this;
	    }
	    /** If index equals 0 set x to value. If index equals 1 set y to value */
	    setComponent(index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	        return this;
	    }
	    /** If index equals 0 returns the x value. If index equals 1 returns the y value. */
	    getComponent(index) {
	        switch (index) {
	            case 0:
	                return this.x;
	            case 1:
	                return this.y;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	    }
	    /** Returns a new Vector2 with the same x and y values as this one. */
	    clone() {
	        return new Vector2(this.x, this.y);
	    }
	    /** Copies the values of the passed Vector2's x and y properties to this Vector2. */
	    copy(v) {
	        this.x = v.x;
	        this.y = v.y;
	        return this;
	    }
	    /** Adds `v` to this vector. */
	    add(v) {
	        this.x += v.x;
	        this.y += v.y;
	        return this;
	    }
	    /** Adds the scalar value `s` to this vector's x and y values. */
	    addScalar(s) {
	        this.x += s;
	        this.y += s;
	        return this;
	    }
	    /** Sets this vector to `a` + `b`. */
	    addVectors(a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        return this;
	    }
	    /** Adds the multiple of `v` and `s` to this vector. */
	    addScaledVector(v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        return this;
	    }
	    /** Subtracts `v` from this vector. */
	    sub(v) {
	        this.x -= v.x;
	        this.y -= v.y;
	        return this;
	    }
	    /** Subtracts `s` from this vector's x and y components. */
	    subScalar(s) {
	        this.x -= s;
	        this.y -= s;
	        return this;
	    }
	    /** Sets this vector to `a` - `b`. */
	    subVectors(a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        return this;
	    }
	    /** Multiplies this vector by `v`. */
	    multiply(v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        return this;
	    }
	    /** Multiplies this vector by scalar `s`. */
	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        return this;
	    }
	    /** Divides this vector by `v`. */
	    divide(v) {
	        this.x /= v.x;
	        this.y /= v.y;
	        return this;
	    }
	    /** Divides this vector by scalar `s`. */
	    divideScalar(scalar) {
	        return this.multiplyScalar(1 / scalar);
	    }
	    /** Multiplies this vector (with an implicit 1 as the 3rd component) by `m`. */
	    applyMatrix3(m) {
	        const x = this.x, y = this.y;
	        const e = m.elements;
	        this.x = e[0] * x + e[3] * y + e[6];
	        this.y = e[1] * x + e[4] * y + e[7];
	        return this;
	    }
	    /** If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value. */
	    min(v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        return this;
	    }
	    /** If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value. */
	    max(v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        return this;
	    }
	    /** If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value. If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value. */
	    clamp(min, max) {
	        // assumes min < max, componentwise
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        return this;
	    }
	    /** If this vector's x or y values are greater than the max value, they are replaced by the max value. If this vector's x or y values are less than the min value, they are replaced by the min value. */
	    clampScalar(minVal, maxVal) {
	        this.x = Math.max(minVal, Math.min(maxVal, this.x));
	        this.y = Math.max(minVal, Math.min(maxVal, this.y));
	        return this;
	    }
	    /** If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value. */
	    clampLength(min, max) {
	        const length = this.length();
	        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	    }
	    /** The components of this vector are rounded down to the nearest integer value. */
	    floor() {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        return this;
	    }
	    /** The components of this vector are rounded up to the nearest integer value. */
	    ceil() {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        return this;
	    }
	    /** The components of this vector are rounded to the nearest integer value. */
	    round() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        return this;
	    }
	    /** The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value. */
	    roundToZero() {
	        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	        return this;
	    }
	    /** Inverts this vector - i.e. sets x = -x and y = -y. */
	    negate() {
	        this.x = -this.x;
	        this.y = -this.y;
	        return this;
	    }
	    /** Calculates the dot product of this vector and v. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y;
	    }
	    /** Calculates the cross product of this vector and v. Note that a 'cross-product' in 2D is not well-defined. This function computes a geometric cross-product often used in 2D graphics. */
	    cross(v) {
	        return this.x * v.y - this.y * v.x;
	    }
	    /** Computes the square of the Euclidean length (straight-line length) from (0, 0) to (x, y). */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y;
	    }
	    /** Computes the Euclidean length (straight-line length) from (0, 0) to (x, y). */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    }
	    /** Computes the Manhattan length of this vector. */
	    manhattanLength() {
	        return Math.abs(this.x) + Math.abs(this.y);
	    }
	    /** Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1. */
	    normalize() {
	        return this.divideScalar(this.length() || 1);
	    }
	    /** Computes the angle in radians of this vector with respect to the positive x-axis. */
	    angle() {
	        // computes the angle in radians with respect to the positive x-axis
	        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
	        return angle;
	    }
	    /** Computes the distance from this vector to v. */
	    distanceTo(v) {
	        return Math.sqrt(this.distanceToSquared(v));
	    }
	    /** Computes the squared distance from this vector to v. */
	    distanceToSquared(v) {
	        const dx = this.x - v.x, dy = this.y - v.y;
	        return dx * dx + dy * dy;
	    }
	    /** Computes the Manhattan distance from this vector to v. */
	    manhattanDistanceTo(v) {
	        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	    }
	    /** Sets this vector to a vector with the same direction as this one, but length l. */
	    setLength(length) {
	        return this.normalize().multiplyScalar(length);
	    }
	    /** Linearly interpolates between this vector and `v`, where `alpha` is the percent distance along the line - `alpha` = 0 will be this vector, and `alpha` = 1 will be `v`. */
	    lerp(v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        return this;
	    }
	    /** Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2. */
	    lerpVectors(v1, v2, alpha) {
	        this.x = v1.x + (v2.x - v1.x) * alpha;
	        this.y = v1.y + (v2.y - v1.y) * alpha;
	        return this;
	    }
	    /** Returns true if the components of this vector and v are strictly equal; false otherwise. */
	    equals(v) {
	        return v.x === this.x && v.y === this.y;
	    }
	    /** Sets this vector's x value to be array[ offset ] and y value to be array[ offset + 1 ]. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        return this;
	    }
	    /** Returns an array [x, y], or copies x and y into the provided array. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        return array;
	    }
	    /** Sets this vector's x and y values from an object. */
	    fromObject(object) {
	        this.x = object.x;
	        this.y = object.y;
	        return this;
	    }
	    /** Rotates this vector around center by angle radians. */
	    rotateAround(center, angle) {
	        const c = Math.cos(angle), s = Math.sin(angle);
	        const x = this.x - center.x;
	        const y = this.y - center.y;
	        this.x = x * c - y * s + center.x;
	        this.y = x * s + y * c + center.y;
	        return this;
	    }
	    /** Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1. */
	    random() {
	        this.x = Math.random();
	        this.y = Math.random();
	        return this;
	    }
	    *[Symbol.iterator]() {
	        yield this.x;
	        yield this.y;
	    }
	}
	//# sourceMappingURL=vector2.js.map

	let v1$1 = new Vector3$1();
	class Util$1 {
	    static async init() {
	        var _a;
	        // Fetch the keyboard map for instant access later
	        this.keyboardMap = await ((_a = navigator.keyboard) === null || _a === void 0 ? void 0 : _a.getLayoutMap());
	    }
	    static degToRad(deg) {
	        return deg / 180 * Math.PI;
	    }
	    static randomFromArray(arr) {
	        return arr[Math.floor(Math.random() * arr.length)];
	    }
	    /** Rotates and/or flips an image with a canvas and returns the canvas. */
	    static modifyImageWithCanvas(image, rotate, flip = false) {
	        let canvas = document.createElement('canvas');
	        canvas.setAttribute('width', image.width.toString());
	        canvas.setAttribute('height', image.height.toString());
	        let ctx = canvas.getContext('2d');
	        ctx.translate(image.width / 2, image.height / 2);
	        if (flip)
	            ctx.scale(1, -1);
	        ctx.rotate(rotate);
	        ctx.translate(-image.width / 2, -image.height / 2);
	        ctx.drawImage(image, 0, 0, image.width, image.height);
	        return canvas;
	    }
	    /** Removes the alpha channel from an image (sets all alpha values to 1) */
	    static removeAlphaChannel(image) {
	        let canvas = document.createElement('canvas');
	        canvas.setAttribute('width', image.width.toString());
	        canvas.setAttribute('height', image.height.toString());
	        let ctx = canvas.getContext('2d');
	        ctx.drawImage(image, 0, 0);
	        let imageData = ctx.getImageData(0, 0, image.width, image.height);
	        for (let i = 0; i < imageData.data.length; i += 4) {
	            imageData.data[i + 3] = 255;
	        }
	        ctx.putImageData(imageData, 0, 0);
	        return canvas;
	    }
	    static async downsampleImage(image, newWidth, newHeight) {
	        let canvas = document.createElement('canvas');
	        canvas.setAttribute('width', newWidth.toString());
	        canvas.setAttribute('height', newHeight.toString());
	        let ctx = canvas.getContext('2d');
	        ctx.drawImage(image, 0, 0, newWidth, newHeight);
	        let data = canvas.toDataURL();
	        let newImage = new Image();
	        newImage.src = data;
	        await new Promise(resolve => newImage.onload = resolve);
	        return newImage;
	    }
	    static clamp(value, min, max) {
	        if (value < min)
	            return min;
	        if (value > max)
	            return max;
	        return value;
	    }
	    static lerp(a, b, t) {
	        return (1 - t) * a + t * b;
	    }
	    static avg(a, b) {
	        return (a + b) / 2;
	    }
	    /** Add a vector to another vector while making sure not to exceed a certain magnitude. */
	    static addToVectorCapped(target, add, magnitudeCap) {
	        let direction = add.clone().normalize();
	        let dot = Math.max(0, target.dot(direction));
	        if (dot + add.length() > magnitudeCap) {
	            let newLength = Math.max(0, magnitudeCap - dot);
	            add.normalize().multiplyScalar(newLength);
	        }
	        target.add(add);
	    }
	    static leftPadZeroes(str, amount) {
	        return "0".repeat(Math.max(0, amount - str.length)) + str;
	    }
	    /** Forces an element's layout to be recalculated. */
	    static forceLayout(element) {
	        element.clientWidth; // It's hacky, but simply accessing this forces it.
	    }
	    /** Get the value of a key for the corresponding button code. For example, KeyA -> A. Respects the user's keyboard layout. */
	    static getKeyForButtonCode(code) {
	        outer: if (this.keyboardMap) {
	            let value = this.keyboardMap.get(code);
	            if (!value)
	                break outer;
	            // Use the value from the keyboard map. This maps things like KeyZ to Y for German keyboards, for example.
	            return (value.toUpperCase().length > 1) ? value : value.toUpperCase(); // This special handling here is for characters that turn into more than one letter when capitalized (like ß).
	        }
	        if (code.startsWith("Key"))
	            return code.slice(3);
	        if (code.startsWith("Digit"))
	            return code.slice(5);
	        if (code.startsWith('Arrow'))
	            return code.slice(5);
	        if (code === "Space")
	            return "Space Bar";
	        if (code === "LMB")
	            return "the Left Mouse Button";
	        if (code === "MMB")
	            return "the Middle Mouse Button";
	        if (code === "RMB")
	            return "the Right Mouse Button";
	        return code;
	    }
	    static setsHaveOverlap(a, b) {
	        for (let val of a) {
	            if (b.has(val))
	                return true;
	        }
	        return false;
	    }
	    /** Compute the value of a 1D Catmull-Rom spline. */
	    static catmullRom(t, p0, p1, p2, p3) {
	        let point = t * t * t * ((-1) * p0 + 3 * p1 - 3 * p2 + p3) / 2;
	        point += t * t * (2 * p0 - 5 * p1 + 4 * p2 - p3) / 2;
	        point += t * ((-1) * p0 + p2) / 2;
	        point += p1;
	        return point;
	    }
	    /** Clones an object using JSON. */
	    static jsonClone(obj) {
	        return JSON.parse(JSON.stringify(obj));
	    }
	    static lerpColors(c1, c2, t) {
	        return {
	            r: Util$1.lerp(c1.r, c2.r, t),
	            g: Util$1.lerp(c1.g, c2.g, t),
	            b: Util$1.lerp(c1.b, c2.b, t),
	            a: Util$1.lerp(c1.a, c2.a, t)
	        };
	    }
	    /** Returns a random point within the unit circle, distributed uniformly. */
	    static randomPointInUnitCircle() {
	        let r = Math.sqrt(Math.random());
	        let theta = Math.random() * Math.PI * 2;
	        return new Vector2(r * Math.cos(theta), r * Math.sin(theta));
	    }
	    /** Removes an item from an array, or does nothing if it isn't contained in it. */
	    static removeFromArray(arr, item) {
	        let index = arr.indexOf(item);
	        if (index !== -1)
	            arr.splice(index, 1);
	    }
	    /** Used to transform normal vectors. Shamelessly copied from Torque's source code. */
	    static m_matF_x_vectorF(matrix, v) {
	        let m = matrix.transpose().elements;
	        let v0 = v.x, v1 = v.y, v2 = v.z;
	        let m0 = m[0], m1 = m[1], m2 = m[2];
	        let m4 = m[4], m5 = m[5], m6 = m[6];
	        let m8 = m[8], m9 = m[9], m10 = m[10];
	        matrix.transpose();
	        let vresult_0 = m0 * v0 + m1 * v1 + m2 * v2;
	        let vresult_1 = m4 * v0 + m5 * v1 + m6 * v2;
	        let vresult_2 = m8 * v0 + m9 * v1 + m10 * v2;
	        v.set(vresult_0, vresult_1, vresult_2);
	    }
	    /** Creates a cylinder-shaped convex hull geometry, aligned with the y-axis. */
	    static createCylinderConvexHull(radius, halfHeight, radialSegments = 32, scale = new Vector3$1(1, 1, 1)) {
	        let vertices = [];
	        for (let i = 0; i < 2; i++) {
	            for (let j = 0; j < radialSegments; j++) {
	                let angle = j / radialSegments * Math.PI * 2;
	                let x = Math.cos(angle);
	                let z = Math.sin(angle);
	                vertices.push(new Vector3$1(x * radius * scale.x, (i ? halfHeight : -halfHeight) * scale.y, z * radius * scale.z));
	            }
	        }
	        return new ConvexHullCollisionShape(vertices);
	    }
	    static uppercaseFirstLetter(str) {
	        if (!str)
	            return str;
	        return str[0].toUpperCase() + str.slice(1);
	    }
	    /** Returns a promise that resolves after `ms` milliseconds. */
	    static wait(ms) {
	        return new Promise((resolve) => setTimeout(resolve, ms));
	    }
	    /** Modulo, but works as expected for negative numbers too. */
	    static adjustedMod(a, n) {
	        return ((a % n) + n) % n;
	    }
	    static concatArrays(arrays) {
	        if (arrays.length === 0)
	            return [];
	        return arrays[0].concat(...arrays.slice(1));
	    }
	    static isInFullscreen() {
	        var _a, _b;
	        // Only check the height for now because Android has those nav buttons
	        // Also weird edge case here with phone thinking it's still in portrait
	        return ( /*window.innerWidth === screen.width && */window.innerHeight === screen.height || (((_b = (_a = screen.orientation) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.includes('portrait')) && window.innerHeight === screen.width)) || !!document.fullscreenElement;
	    }
	    static swapInArray(arr, i1, i2) {
	        let temp = arr[i1];
	        arr[i1] = arr[i2];
	        arr[i2] = temp;
	    }
	    /** Makes the camera look at a point directly, meaning with the shortest rotation change possible and while ignoring the camera's up vector. */
	    static cameraLookAtDirect(camera, target) {
	        let lookVector = new Vector3$1(0, 0, -1);
	        lookVector.applyQuaternion(camera.orientation);
	        let quat = new Quaternion$1();
	        quat.setFromUnitVectors(lookVector, target.clone().sub(camera.position).normalize());
	        camera.orientation.copy(quat.multiply(camera.orientation));
	    }
	    static arrayBufferToString(buf) {
	        let str = "";
	        let view = new Uint8Array(buf);
	        for (let i = 0; i < buf.byteLength; i++) {
	            str += String.fromCharCode(view[i]);
	        }
	        return str;
	    }
	    static stringToArrayBuffer(str) {
	        let view = new Uint8Array(str.length);
	        for (let i = 0; i < str.length; i++) {
	            view[i] = str.charCodeAt(i);
	        }
	        return view.buffer;
	    }
	    static stringIsOnlyWhitespace(str) {
	        return str.trim().length === 0;
	    }
	    /** Unescapes escaped (\) characters. */
	    static unescape(str) {
	        let cEscapeRegex = /(^|[^\\])\\x([0-9a-f]{2})/gi; // Matches \xhh
	        let match = null;
	        while ((match = cEscapeRegex.exec(str)) !== null) {
	            let code = Number.parseInt(match[2], 16);
	            let char = this.macRomanToUtf8(code); // DUMB
	            str = str.slice(0, match.index) + match[1] + char + str.slice(match.index + match[0].length); // match[1] is "negative lookbehind"
	            cEscapeRegex.lastIndex -= 3;
	        }
	        let regex = /\\(.)/g;
	        let specialCases = {
	            '\\': '\\',
	            't': '\t',
	            'v': '\v',
	            '0': '\0',
	            'f': '\f',
	            'n': '\n',
	            'r': '\r'
	        };
	        while ((match = regex.exec(str)) !== null) {
	            let replaceWith;
	            if (specialCases[match[1]])
	                replaceWith = specialCases[match[1]];
	            else
	                replaceWith = match[1];
	            str = str.slice(0, match.index) + replaceWith + str.slice(match.index + match[0].length);
	            regex.lastIndex--;
	        }
	        return str;
	    }
	    /** Splits a string like String.prototype.split, but ignores the splitter if it appears inside string literal tokens. */
	    static splitIgnoreStringLiterals(str, splitter, strLiteralToken = '"') {
	        let indices = [];
	        let inString = false;
	        for (let i = 0; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	            else if (c === splitter)
	                indices.push(i);
	        }
	        let parts = [];
	        let remaining = str;
	        for (let i = 0; i < indices.length; i++) {
	            let index = indices[i] - (str.length - remaining.length);
	            let part = remaining.slice(0, index);
	            remaining = remaining.slice(index + 1);
	            parts.push(part);
	        }
	        parts.push(remaining);
	        return parts;
	    }
	    /** Gets the index of a substring like String.prototype.indexOf, but only if that index lies outside of string literals. */
	    static indexOfIgnoreStringLiterals(str, searchString, position = 0, strLiteralToken = '"') {
	        let inString = false;
	        for (let i = position; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	            else if (str.startsWith(searchString, i))
	                return i;
	        }
	        return -1;
	    }
	    /** Returns true iff the supplied index is part of a string literal. */
	    static indexIsInStringLiteral(str, index, strLiteralToken = '"') {
	        let inString = false;
	        for (let i = 0; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (i === index)
	                    return true;
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	        }
	        return false;
	    }
	    /** Reorders an array with the given index map. */
	    static remapIndices(arr, indices) {
	        return indices.map(i => arr[i]);
	    }
	    /** Finds the last element in an array that fulfills a predicate. */
	    static findLast(arr, predicate) {
	        for (let i = arr.length - 1; i >= 0; i--) {
	            let item = arr[i];
	            if (predicate(item))
	                return item;
	        }
	    }
	    /** Removes diacritics from a string. */
	    static normalizeString(str) {
	        // https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
	        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
	    }
	    static removeSpecialCharacters(str) {
	        return str.replace(/[-!$%^&*()_+|~=`{}\[\]:";'<>?,.\/]/g, '');
	    }
	    /** Gets the last item in an array. */
	    static last(arr) {
	        return arr[arr.length - 1];
	    }
	    static isSafari() {
	        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	    }
	    static isFirefox() {
	        return navigator.userAgent.includes('Firefox');
	    }
	    static download(url, filename) {
	        let element = document.createElement('a');
	        element.setAttribute('href', url);
	        element.setAttribute('download', filename);
	        element.style.display = 'none';
	        document.body.appendChild(element);
	        element.click();
	        document.body.removeChild(element);
	    }
	    /** Removes all characters from a string that aren't letters or digits. */
	    static removeSpecialChars(str) {
	        let regex = /[^\w\d]/gi;
	        let match = null;
	        while ((match = regex.exec(str)) !== null) {
	            str = str.slice(0, match.index) + str.slice(match.index + match[0].length);
	            regex.lastIndex -= match[0].length;
	        }
	        return str;
	    }
	    /** Checks if a string is likely to be naughty or inappropriate based on its words. */
	    static isNaughty(str) {
	        let words = str.toLowerCase().split(' ');
	        for (let word of words)
	            if (this.naughtyWords.includes(word))
	                return true;
	        return false;
	    }
	    static shallowClone(obj) {
	        let clone = {};
	        for (let key in obj) {
	            clone[key] = obj[key];
	        }
	        return clone;
	    }
	    static deepClone(data) {
	        if (!data) {
	            return data;
	        }
	        else if (typeof data === 'object') {
	            if (Array.isArray(data))
	                return data.map(x => this.deepClone(x));
	            return Object.fromEntries(Object.entries(data).map(([key, value]) => [key, this.deepClone(value)]));
	        }
	        else {
	            return data;
	        }
	    }
	    static isMac() {
	        return window.navigator.platform.toLowerCase().includes('mac');
	    }
	    // https://stackoverflow.com/questions/9038625/detect-if-device-is-ios
	    static isIOS() {
	        return [
	            'iPad Simulator',
	            'iPhone Simulator',
	            'iPod Simulator',
	            'iPad',
	            'iPhone',
	            'iPod'
	        ].includes(navigator.platform)
	            // iPad on iOS 13 detection
	            || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
	    }
	    /** Converts seconds into a time string as seen in the game clock at the top, for example. */
	    static secondsToTimeString(seconds, decimalDigits = this.getDefaultSecondsToTimeStringDecimalDigits()) {
	        let abs = Math.abs(seconds);
	        let minutes = Math.floor(abs / 60);
	        let string = Util$1.leftPadZeroes(minutes.toString(), 2) + ':' + Util$1.leftPadZeroes(Math.floor(abs % 60).toString(), 2) + '.' + Util$1.leftPadZeroes(Math.floor(abs * 10 ** decimalDigits % 10 ** decimalDigits).toString(), decimalDigits);
	        if (seconds < 0)
	            string = '-' + string;
	        return string;
	    }
	    static async arrayBufferToBase64(buf) {
	        let blob = new Blob([buf]);
	        let dataUrl = await new Promise((resolve) => {
	            let reader = new FileReader();
	            reader.onload = (e) => resolve(e.target.result);
	            reader.readAsDataURL(blob);
	        });
	        return dataUrl.slice(dataUrl.indexOf(',') + 1); // Remove the stupid preamble
	    }
	    /** Gets the next random number. Will be equal to the number returned by `peekRandomNumber(0)`. */
	    static popRandomNumber() {
	        if (this.randomNumberQueue.length > 0) {
	            return this.randomNumberQueue.shift();
	        }
	        else {
	            return Math.random();
	        }
	    }
	    /** See what the (`index` + 1)th next call of `popRandomNumber()` will return. */
	    static peekRandomNumber(index = 0) {
	        while (this.randomNumberQueue.length <= index) {
	            this.randomNumberQueue.push(Math.random());
	        }
	        return this.randomNumberQueue[index];
	    }
	    /** Compares two major.minor.patch version number strings. */
	    static compareVersions(v1, v2) {
	        let parts1 = v1.split('.').map(x => Number(x));
	        let parts2 = v2.split('.').map(x => Number(x));
	        for (let i = 0; i < parts1.length; i++) {
	            let a = parts1[i];
	            let b = parts2[i];
	            if (a > b)
	                return 1;
	            if (a < b)
	                return -1;
	        }
	        return 0;
	    }
	    /** Returns true if the current device is a mobile device or a tablet. If it's a computer with a touch screen, it will return false. */
	    static checkIsTouchDevice() {
	        return 'ontouchstart' in window; // Let's see if this suffices for now actually (this doesn't match my touchscreen laptop)
	    }
	    static signedSqrt(x) {
	        return Math.sign(x) * Math.sqrt(Math.abs(x));
	    }
	    static signedSquare(x) {
	        return x * Math.abs(x);
	    }
	    static htmlEscape(raw) {
	        this.htmlEscapeElem.textContent = raw;
	        return this.htmlEscapeElem.innerHTML;
	    }
	    /** Generates a (probably universally-unique) identifier. Uses its own format, not the standard cringe. */
	    static uuid() {
	        crypto.getRandomValues(this.uuidBuffer);
	        let res = '';
	        for (let i = 0; i < 12; i++) {
	            let char = this.base62[Math.floor(this.uuidBuffer[i] / 65536 * this.base62.length)];
	            res += char;
	        }
	        return res;
	    }
	    static roundToMultiple(val, fac) {
	        if (!fac)
	            return val;
	        return Math.round(val / fac) * fac;
	    }
	    /** Checks if a ray intersects an AABB. Expects a normalized ray direction. Uses the algorithm described at https://tavianator.com/2011/ray_box.html. */
	    static rayIntersectsBox(rayOrigin, rayDirection, lambdaMax, box) {
	        if (box.containsPoint(rayOrigin))
	            return true;
	        let tx1 = (box.min.x - rayOrigin.x) / rayDirection.x;
	        let tx2 = (box.max.x - rayOrigin.x) / rayDirection.x;
	        let tmin = Math.min(tx1, tx2);
	        let tmax = Math.max(tx1, tx2);
	        let ty1 = (box.min.y - rayOrigin.y) / rayDirection.y;
	        let ty2 = (box.max.y - rayOrigin.y) / rayDirection.y;
	        tmin = Math.max(tmin, Math.min(ty1, ty2));
	        tmax = Math.min(tmax, Math.max(ty1, ty2));
	        let tz1 = (box.min.z - rayOrigin.z) / rayDirection.z;
	        let tz2 = (box.max.z - rayOrigin.z) / rayDirection.z;
	        tmin = Math.max(tmin, Math.min(tz1, tz2));
	        tmax = Math.min(tmax, Math.max(tz1, tz2));
	        v1$1.copy(rayOrigin).addScaledVector(rayDirection, (tmin >= 0) ? tmin : tmax); // use tmax if the ray starts inside the box
	        if (rayOrigin.distanceToSquared(v1$1) > lambdaMax ** 2)
	            return false;
	        return tmax >= tmin;
	    }
	    /** Some fonts were apparently compiled on Mac and use this encoding instead of something sensible. Stupid. */
	    static macRomanToUtf8(char) {
	        if (char < 128)
	            return String.fromCharCode(char);
	        else
	            return this.macRomanToUtf8Map[char - 128];
	    }
	    /** Manually ensures all numbers in the element's text have the same width so they align nicely. */
	    static monospaceNumbers(element, ems = 0.5) {
	        element.innerHTML = element.textContent.split('').map(x => (x >= '0' && x <= '9') ? `<span style="width: ${ems}em; display: inline-block; text-align: center;">${x}</span>` : x).join('');
	    }
	    /** Fires a callback when the user has held down a given element for a longer amount of time. Allows "right clicking" on touch devices. */
	    static onLongTouch(element, callback) {
	        let id;
	        let kicked = false;
	        element.addEventListener('touchstart', (e) => {
	            id = setTimeout(() => {
	                callback(e);
	                kicked = true;
	            }, 500);
	        });
	        element.addEventListener('touchend', (e) => {
	            clearTimeout(id);
	            if (kicked) {
	                e.stopPropagation();
	                e.preventDefault();
	                kicked = false;
	            }
	        });
	    }
	    /** Returns an array of permutations of the input array. */
	    static getPermutations(arr) {
	        if (arr.length === 0)
	            return [];
	        if (arr.length === 1)
	            return [arr.slice()];
	        let res = [];
	        for (let i = 0; i < arr.length; i++) {
	            let first = arr[i];
	            let spliced = arr.slice();
	            spliced.splice(i, 1);
	            let subpermutations = this.getPermutations(spliced);
	            res.push(...subpermutations.map(x => (x.unshift(first), x)));
	        }
	        return res;
	    }
	    static pushArray(target, toPush) {
	        for (let elem of toPush)
	            target.push(elem);
	    }
	    static requestPointerLock() {
	        var _a, _b;
	        let ret = (_b = (_a = document.documentElement).requestPointerLock) === null || _b === void 0 ? void 0 : _b.call(_a);
	        if (ret && ret instanceof Promise)
	            ret.catch(() => { });
	    }
	    /** Returns true iff `b` is a subsequence of `a`. */
	    static isSubsequenceOf(b, a) {
	        if (b.length > a.length)
	            return false; // Early out
	        let j = 0;
	        for (let i = 0; i < b.length; i++) {
	            while (a[j] !== b[i] && j < a.length)
	                j++;
	            if (j === a.length)
	                return false;
	            j++;
	        }
	        return true;
	    }
	    static isPowerOf2(x) {
	        return !(x & (x - 1));
	    }
	    static ceilPowerOf2(x) {
	        let power = 1;
	        while (power < x)
	            power *= 2;
	        return power;
	    }
	    static assert(bool) {
	        if (!bool)
	            throw new Error("Assertion failed.");
	    }
	    static getBoxVertices(box) {
	        let dx = new Vector3$1(box.max.x - box.min.x, 0, 0);
	        let dy = new Vector3$1(0, box.max.y - box.min.y, 0);
	        let dz = new Vector3$1(0, 0, box.max.z - box.min.z);
	        return [
	            box.min.clone(),
	            box.min.clone().add(dx),
	            box.min.clone().add(dy),
	            box.min.clone().add(dz),
	            box.min.clone().add(dx).add(dy),
	            box.min.clone().add(dx).add(dz),
	            box.min.clone().add(dy).add(dz),
	            box.max.clone()
	        ];
	    }
	    static computeMedian(values) {
	        if (values.length === 0)
	            return NaN;
	        let sorted = values.slice().sort((a, b) => a - b);
	        if (sorted.length % 2)
	            return sorted[Math.floor(values.length / 2)];
	        else
	            return Util$1.avg(sorted[Math.floor(values.length / 2) - 1], sorted[Math.floor(values.length / 2)]);
	    }
	    static filterInPlace(arr, pred) {
	        for (let i = 0; i < arr.length; i++) {
	            if (!pred(arr[i]))
	                arr.splice(i--, 1);
	        }
	        return arr;
	    }
	    /** Inserts an element into in array already sorted using the given comparator function. */
	    static insertSorted(arr, item, comparator) {
	        let low = 0;
	        let high = arr.length - 1;
	        let ans = -1;
	        // Binary search our way there
	        while (low <= high) {
	            let mid = Math.floor(low + (high - low + 1) / 2);
	            let midVal = arr[mid];
	            let comp = comparator(item, midVal);
	            if (comp > 0) {
	                ans = mid;
	                low = mid + 1;
	            }
	            else {
	                high = mid - 1;
	            }
	        }
	        arr.splice(ans + 1, 0, item);
	        return ans + 1;
	    }
	    static areEqualDeep(o1, o2) {
	        if (o1 === o2)
	            return true;
	        if (typeof o1 !== 'object' || typeof o2 !== 'object')
	            return o1 === o2;
	        if (Array.isArray(o1) !== Array.isArray(o2))
	            return false;
	        if (Array.isArray(o1)) {
	            if (o1.length !== o2.length)
	                return false;
	            for (let i = 0; i < o1.length; i++)
	                if (!this.areEqualDeep(o1[i], o2[i]))
	                    return false;
	        }
	        else {
	            for (let key in o2)
	                if (!(key in o1))
	                    return false;
	            for (let key in o1) {
	                if (!this.areEqualDeep(o1[key], o2[key]))
	                    return false;
	            }
	        }
	        return true;
	    }
	    /** Super-simple general-purpose 32-bit hash function taken from https://gist.github.com/iperelivskiy/4110988. */
	    static simpleHash(s) {
	        let h = 0xdeadbeef;
	        for (let i = 0; i < s.length; i++)
	            h = Math.imul(h ^ s.charCodeAt(i), 2654435761);
	        return (h ^ h >>> 16) >>> 0;
	    }
	    /** Returns the `n`th random number generated by a PRNG seeded with `seed`. Internally works by iterating xorshift128+ multiple times. Based on https://github.com/AndreasMadsen/xorshift. */
	    static seededRandom(seed, n = 0) {
	        // Sufficiently scramble the starting state from the seed
	        let state0U = this.simpleHash(seed.toString());
	        let state0L = this.simpleHash(state0U.toString() + seed);
	        let state1U = this.simpleHash(state0L.toString() + seed);
	        let state1L = this.simpleHash(state1U.toString() + seed);
	        let resU;
	        let resL;
	        for (let i = 0; i < 5 + n; i++) { // Always do at least 5 iterations so the state gets even more scrambled
	            let s1U = state0U, s1L = state0L;
	            let s0U = state1U, s0L = state1L;
	            let sumL = (s0L >>> 0) + (s1L >>> 0);
	            resU = (s0U + s1U + (sumL / 2 >>> 31)) >>> 0;
	            resL = sumL >>> 0;
	            state0U = s0U;
	            state0L = s0L;
	            let t1U = 0, t1L = 0;
	            let t2U = 0, t2L = 0;
	            let a1 = 23;
	            let m1 = 0xFFFFFFFF << (32 - a1);
	            t1U = (s1U << a1) | ((s1L & m1) >>> (32 - a1));
	            t1L = s1L << a1;
	            s1U = s1U ^ t1U;
	            s1L = s1L ^ t1L;
	            t1U = s1U ^ s0U;
	            t1L = s1L ^ s0L;
	            let a2 = 18;
	            let m2 = 0xFFFFFFFF >>> (32 - a2);
	            t2U = s1U >>> a2;
	            t2L = (s1L >>> a2) | ((s1U & m2) << (32 - a2));
	            t1U = t1U ^ t2U;
	            t1L = t1L ^ t2L;
	            let a3 = 5;
	            let m3 = 0xFFFFFFFF >>> (32 - a3);
	            t2U = s0U >>> a3;
	            t2L = (s0L >>> a3) | ((s0U & m3) << (32 - a3));
	            t1U = t1U ^ t2U;
	            t1L = t1L ^ t2L;
	            state1U = t1U;
	            state1L = t1L;
	        }
	        // Map state to [0, 1)
	        return resU * 2.3283064365386963e-10 + (resL >>> 12) * 2.220446049250313e-16;
	    }
	    static roundRect(ctx, x, y, w, h, r) {
	        if (w < 2 * r)
	            r = w / 2;
	        if (h < 2 * r)
	            r = h / 2;
	        ctx.beginPath();
	        ctx.moveTo(x + r, y);
	        ctx.arcTo(x + w, y, x + w, y + h, r);
	        ctx.arcTo(x + w, y + h, x, y + h, r);
	        ctx.arcTo(x, y + h, x, y, r);
	        ctx.arcTo(x, y, x + w, y, r);
	        ctx.closePath();
	    }
	}
	/** Taken from https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/blob/master/en. Lmao. */
	Util$1.naughtyWords = ["2g1c", "2 girls 1 cup", "acrotomophilia", "alabama hot pocket", "alaskan pipeline", "anal", "anilingus", "anus", "apeshit", "arsehole", "ass", "asshole", "assmunch", "auto erotic", "autoerotic", "babeland", "baby batter", "baby juice", "ball gag", "ball gravy", "ball kicking", "ball licking", "ball sack", "ball sucking", "bangbros", "bangbus", "bareback", "barely legal", "barenaked", "bastard", "bastardo", "bastinado", "bbw", "bdsm", "beaner", "beaners", "beaver cleaver", "beaver lips", "beastiality", "bestiality", "big black", "big breasts", "big knockers", "big tits", "bimbos", "birdlock", "bitch", "bitches", "black cock", "blonde action", "blonde on blonde action", "blowjob", "blow job", "blow your load", "blue waffle", "blumpkin", "bollocks", "bondage", "boner", "boob", "boobs", "booty call", "brown showers", "brunette action", "bukkake", "bulldyke", "bullet vibe", "bullshit", "bung hole", "bunghole", "busty", "butt", "buttcheeks", "butthole", "camel toe", "camgirl", "camslut", "camwhore", "carpet muncher", "carpetmuncher", "chocolate rosebuds", "cialis", "circlejerk", "cleveland steamer", "clit", "clitoris", "clover clamps", "clusterfuck", "cock", "cocks", "coprolagnia", "coprophilia", "cornhole", "coon", "coons", "creampie", "cum", "cumming", "cumshot", "cumshots", "cunnilingus", "cunt", "darkie", "date rape", "daterape", "deep throat", "deepthroat", "dendrophilia", "dick", "dildo", "dingleberry", "dingleberries", "dirty pillows", "dirty sanchez", "doggie style", "doggiestyle", "doggy style", "doggystyle", "dog style", "dolcett", "domination", "dominatrix", "dommes", "donkey punch", "double dong", "double penetration", "dp action", "dry hump", "dvda", "eat my ass", "ecchi", "ejaculation", "erotic", "erotism", "escort", "eunuch", "fag", "faggot", "fecal", "felch", "fellatio", "feltch", "female squirting", "femdom", "figging", "fingerbang", "fingering", "fisting", "foot fetish", "footjob", "frotting", "fuck", "fuck buttons", "fuckin", "fucking", "fucktards", "fudge packer", "fudgepacker", "futanari", "gangbang", "gang bang", "gay sex", "genitals", "giant cock", "girl on", "girl on top", "girls gone wild", "goatcx", "goatse", "god damn", "gokkun", "golden shower", "goodpoop", "goo girl", "goregasm", "grope", "group sex", "g-spot", "guro", "hand job", "handjob", "hard core", "hardcore", "hentai", "homoerotic", "honkey", "hooker", "horny", "hot carl", "hot chick", "how to kill", "how to murder", "huge fat", "humping", "incest", "intercourse", "jack off", "jail bait", "jailbait", "jelly donut", "jerk off", "jigaboo", "jiggaboo", "jiggerboo", "jizz", "juggs", "kike", "kinbaku", "kinkster", "kinky", "knobbing", "leather restraint", "leather straight jacket", "lemon party", "livesex", "lolita", "lovemaking", "make me come", "male squirting", "masturbate", "masturbating", "masturbation", "menage a trois", "milf", "missionary position", "mong", "motherfucker", "mound of venus", "mr hands", "muff diver", "muffdiving", "nambla", "nawashi", "negro", "neonazi", "nigga", "nigger", "nig nog", "nimphomania", "nipple", "nipples", "nsfw", "nsfw images", "nude", "nudity", "nutten", "nympho", "nymphomania", "octopussy", "omorashi", "one cup two girls", "one guy one jar", "orgasm", "orgy", "paedophile", "paki", "panties", "panty", "pedobear", "pedophile", "pegging", "penis", "phone sex", "piece of shit", "pikey", "pissing", "piss pig", "pisspig", "playboy", "pleasure chest", "pole smoker", "ponyplay", "poof", "poon", "poontang", "punany", "poop chute", "poopchute", "porn", "porno", "pornography", "prince albert piercing", "pthc", "pubes", "pussy", "queaf", "queef", "quim", "raghead", "raging boner", "rape", "raping", "rapist", "rectum", "reverse cowgirl", "rimjob", "rimming", "rosy palm", "rosy palm and her 5 sisters", "rusty trombone", "sadism", "santorum", "scat", "schlong", "scissoring", "semen", "sex", "sexcam", "sexo", "sexy", "sexual", "sexually", "sexuality", "shaved beaver", "shaved pussy", "shemale", "shibari", "shit", "shitblimp", "shitty", "shota", "shrimping", "skeet", "slanteye", "slut", "s&m", "smut", "snatch", "snowballing", "sodomize", "sodomy", "spastic", "spic", "splooge", "splooge moose", "spooge", "spread legs", "spunk", "strap on", "strapon", "strappado", "strip club", "style doggy", "suck", "sucks", "suicide girls", "sultry women", "swastika", "swinger", "tainted love", "taste my", "tea bagging", "threesome", "throating", "thumbzilla", "tied up", "tight white", "tit", "tits", "titties", "titty", "tongue in a", "topless", "tosser", "towelhead", "tranny", "tribadism", "tub girl", "tubgirl", "tushy", "twat", "twink", "twinkie", "two girls one cup", "undressing", "upskirt", "urethra play", "urophilia", "vagina", "venus mound", "viagra", "vibrator", "violet wand", "vorarephilia", "voyeur", "voyeurweb", "voyuer", "vulva", "wank", "wetback", "wet dream", "white power", "whore", "worldsex", "wrapping men", "wrinkled starfish", "xx", "xxx", "yaoi", "yellow showers", "yiffy", "zoophilia", "🖕"];
	/** Override dis if you want. */
	Util$1.getDefaultSecondsToTimeStringDecimalDigits = () => 3;
	Util$1.randomNumberQueue = [];
	Util$1.htmlEscapeElem = document.createElement('p');
	Util$1.base62 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	Util$1.uuidBuffer = new Uint16Array(12);
	Util$1.macRomanToUtf8Map = ['Ä', 'Å', 'Ç', 'É', 'Ñ', 'Ö', 'Ü', 'á', 'à', 'â', 'ä', 'ã', 'å', 'ç', 'é', 'è', 'ê', 'ë', 'í', 'ì', 'î', 'ï', 'ñ', 'ó', 'ò', 'ô', 'ö', 'õ', 'ú', 'ù', 'û', 'ü', '†', '°', '¢', '£', '§', '•', '¶', 'ß', '®', '©', '™', '´', '¨', '≠', 'Æ', 'Ø', '∞', '±', '≤', '≥', '¥', 'µ', '∂', '∑', '∏', 'π', '∫', 'ª', 'º', 'Ω', 'æ', 'ø', '¿', '¡', '¬', '√', 'ƒ', '≈', '∆', '«', '»', '…', ' ', 'À', 'Ã', 'Õ', 'Œ', 'œ', '–', '—', '“', '”', '‘', '’', '÷', '◊', 'ÿ', 'Ÿ', '⁄', '€', '‹', '›', 'ﬁ', 'ﬂ', '‡', '·', '‚', '„', '‰', 'Â', 'Ê', 'Á', 'Ë', 'È', 'Í', 'Î', 'Ï', 'Ì', 'Ó', 'Ô', '🍎', 'Ò', 'Ú', 'Û', 'Ù', 'ı', 'ˆ', '˜', '¯', '˘', '˙', '˚', '¸', '˝', '˛', 'ˇ'];
	/** Produces a funny easter egg once in a while based on a stupid pun. */
	Util$1.isWeeb = Math.random() < 0.001; // Mazik <3
	Util$1.isTouchDevice = Util$1.checkIsTouchDevice(); // Precompute the thing
	/** A scheduler can be used to schedule tasks in the future which will be executed when it's time. */
	class Scheduler$1 {
	    constructor() {
	        this.scheduled = [];
	    }
	    tickSchedule(time) {
	        for (let item of this.scheduled.slice()) {
	            if (time >= item.time) {
	                Util$1.removeFromArray(this.scheduled, item);
	                item.callback();
	            }
	        }
	    }
	    schedule(time, callback, id = null) {
	        this.scheduled.push({ time, callback, id });
	    }
	    clearSchedule() {
	        this.scheduled.length = 0;
	    }
	    clearScheduleId(id) {
	        for (let i = 0; i < this.scheduled.length; i++) {
	            if (this.scheduled[i].id === id)
	                this.scheduled.splice(i--, 1);
	        }
	    }
	}
	//# sourceMappingURL=util.js.map

	function workerBody() {
	    const respond = (msgId, payload) => {
	        self.postMessage({
	            msgId: msgId,
	            data: payload
	        });
	    };
	    let url = null;
	    self.onmessage = (e) => {
	        if (!url) {
	            // The first message received will be the url
	            url = e.data;
	            self.importScripts(url + 'lib/pako.js');
	            return;
	        }
	        let data = e.data;
	        if (data.command === 'compress') {
	            let compressed = pako.deflate(data.data);
	            respond(e.data.msgId, compressed);
	        }
	    };
	}
	// Create the worker by converting the function into a blob resource
	let entire = workerBody.toString();
	let body = entire.slice(entire.indexOf("{") + 1, entire.lastIndexOf("}"));
	let blob = new Blob([body]);
	let worker = new Worker(URL.createObjectURL(blob));
	let currentPromiseResolves = new Map();
	// https://stackoverflow.com/questions/22172426/using-importsscripts-within-blob-in-a-karma-environment
	worker.postMessage(window.location.href.slice(0, window.location.href.lastIndexOf('/') + 1));
	worker.onmessage = (e) => {
	    currentPromiseResolves.get(e.data.msgId)(e.data.data);
	};
	/** Executes a command with a payload on the worker. Returns a promise that resolves with the result. */
	const executeOnWorker$1 = (command, payload) => {
	    let msgId = Util$1.uuid();
	    worker.postMessage({
	        msgId: msgId,
	        command: command,
	        data: payload
	    });
	    let promise = new Promise((resolve) => {
	        currentPromiseResolves.set(msgId, resolve);
	    });
	    return promise;
	};
	function timerWorkerBody() {
	    let idMap = new Map();
	    self.onmessage = (e) => {
	        let data = e.data;
	        if (data.command === 'setTimeout') {
	            let internalId = setTimeout(() => {
	                self.postMessage({
	                    externalId: data.externalId
	                });
	            }, data.timeout);
	            idMap.set(data.externalId, internalId);
	        }
	        else if (data.command === 'setInterval') {
	            let internalId = setInterval(() => {
	                self.postMessage({
	                    externalId: data.externalId
	                });
	            }, data.timeout);
	            idMap.set(data.externalId, internalId);
	        }
	        else if (data.command === 'clear') {
	            clearTimeout(idMap.get(data.externalId));
	            clearInterval(idMap.get(data.externalId));
	        }
	    };
	}
	let timerEntire = timerWorkerBody.toString();
	let timerBody = timerEntire.slice(timerEntire.indexOf("{") + 1, timerEntire.lastIndexOf("}"));
	let timerWorker = new Worker(URL.createObjectURL(new Blob([timerBody])));
	let timerId = 0;
	let handlerMap = new Map();
	timerWorker.onmessage = (ev) => {
	    let handler = handlerMap.get(ev.data.externalId);
	    handler === null || handler === void 0 ? void 0 : handler();
	};
	/** Works exactly like setInterval, except that the timer runs on a Web Worker that keeps running in background tabs. */
	const workerSetInterval = (handler, timeout = 0) => {
	    timerWorker.postMessage({
	        command: 'setInterval',
	        timeout: timeout,
	        externalId: timerId
	    });
	    handlerMap.set(timerId, handler);
	    return timerId++;
	};
	/** Works exactly like clearTimeout and clearInterval. */
	const workerClearTimeoutOrInterval = (externalId) => {
	    handlerMap.delete(externalId);
	    timerWorker.postMessage({
	        command: 'clear',
	        externalId: externalId
	    });
	};
	//# sourceMappingURL=worker.js.map

	const MAX_SCORE_TIME = (99 * 60 + 59) * 1000 + 999.99; // The 99:59.999 thing
	const DEFAULT_STORAGE_DATA = {
	    settings: {
	        resolution: 2,
	        videoDriver: 0,
	        screenStyle: 0,
	        colorDepth: 1,
	        shadows: false,
	        musicVolume: 0.5,
	        soundVolume: 0.7,
	        gameButtonMapping: {
	            "up": "KeyW",
	            "down": "KeyS",
	            "left": "KeyA",
	            "right": "KeyD",
	            "jump": "Space",
	            "use": "LMB",
	            "cameraUp": "ArrowUp",
	            "cameraDown": "ArrowDown",
	            "cameraLeft": "ArrowLeft",
	            "cameraRight": "ArrowRight",
	            "freeLook": "RMB",
	            "restart": "KeyR",
	            "blast": "KeyE"
	        },
	        mouseSensitivity: 0.2,
	        keyboardSensitivity: 0.1,
	        invertMouse: 0,
	        alwaysFreeLook: true,
	        marbleReflectivity: 0,
	        showFrameRate: true,
	        showThousandths: true,
	        fov: 60,
	        fancyShaders: true,
	        pixelRatio: 2,
	        inputType: 0,
	        frameRateCap: 7,
	        canvasDesynchronized: false,
	        joystickPosition: 0,
	        joystickSize: 250,
	        joystickLeftOffset: 75,
	        joystickVerticalPosition: 0.5,
	        actionButtonOrder: 0,
	        actionButtonSize: 120,
	        actionButtonRightOffset: 30,
	        actionButtonBottomOffset: 30,
	        actionButtonAsJoystickMultiplier: 1.5
	    },
	    bestTimes: {},
	    lastUsedName: '',
	    randomId: Util$1.uuid(),
	    bestTimeSubmissionQueue: {},
	    lastSeenVersion: null,
	    collectedEggs: [],
	    modification: 'platinum',
	    username: null
	};
	const VERSION_UPGRADE_PROCEDURES = {
	    '2.1.5': async () => {
	        // Got more performant now, so encourage people to have this on :)
	        StorageManager$1.data.settings.marbleReflectivity = 0;
	        await StorageManager$1.store();
	    },
	    '2.3.0': async () => {
	        // Got super pretty now, so encourage people to have this on :)
	        StorageManager$1.data.settings.marbleReflectivity = 0;
	        await StorageManager$1.store();
	    }
	};
	/** Manages storage and persistence. */
	class StorageManager$1 {
	    static async init() {
	        // Setup the IndexedDB
	        this.idbDatabase = new Promise((resolve) => {
	            let request = indexedDB.open("mb-database", 3);
	            request.onsuccess = (e) => {
	                resolve(e.target.result);
	            };
	            request.onupgradeneeded = (e) => {
	                let db = e.target.result;
	                let transaction = e.target.transaction;
	                // For storing replays
	                try {
	                    db.createObjectStore('replays', {});
	                }
	                catch (error) {
	                    transaction.objectStore('replays');
	                }
	                // A simple key-value store
	                try {
	                    db.createObjectStore('keyvalue', {});
	                }
	                catch (error) {
	                    transaction.objectStore('keyvalue');
	                }
	            };
	        });
	        // Old storage format detected, let's migrate it
	        if (localStorage.getItem('mb-storage'))
	            await this.migrate();
	        // Get the storage data
	        let storageData = await this.databaseGet('keyvalue', 'storageData');
	        if (storageData) {
	            // Correct fields incase the stored data is stale / from an older version
	            this.data = this.correctFields(DEFAULT_STORAGE_DATA, storageData);
	        }
	        else {
	            this.data = DEFAULT_STORAGE_DATA;
	        }
	        // Override the inferred type
	        if (this.data.settings.inputType === 1)
	            Util$1.isTouchDevice = false;
	        else if (this.data.settings.inputType === 2)
	            Util$1.isTouchDevice = true;
	        // Get the best times and uncompress them
	        this.data.bestTimes = {};
	        let compressedBestTimes = await this.databaseGet('keyvalue', 'bestTimes');
	        if (compressedBestTimes) {
	            try {
	                let uncompressed = pako.inflate(compressedBestTimes, { to: 'string' });
	                let json = JSON.parse(uncompressed);
	                this.data.bestTimes = json;
	            }
	            catch (e) {
	                console.error("Error decoding best times!", e);
	            }
	        }
	        // Here we correct an oopsie: Because I accidentally released MBU levels too early, remove all local scores on those levels that happened before the *proper* MBU level release, as they are invalid.
	        let changed = false;
	        for (let missionPath in this.data.bestTimes) {
	            if (!missionPath.startsWith('mbu/'))
	                continue;
	            for (let i = 0; i < this.data.bestTimes[missionPath].length; i++) {
	                let score = this.data.bestTimes[missionPath][i];
	                if (score[3] < 1634861292099) {
	                    this.data.bestTimes[missionPath].splice(i--, 1);
	                    changed = true;
	                }
	            }
	            if (this.data.bestTimes[missionPath].length === 0)
	                delete this.data.bestTimes[missionPath];
	        }
	        if (changed)
	            await this.storeBestTimes();
	        Util$1.getDefaultSecondsToTimeStringDecimalDigits = () => this.data.settings.showThousandths ? 3 : 2;
	    }
	    /** Migrates from localStorage to IndexedDB. */
	    static async migrate() {
	        let stored = JSON.parse(localStorage.getItem('mb-storage'));
	        this.data = stored;
	        for (let key in stored.bestTimes) {
	            for (let bestTime of stored.bestTimes[key]) {
	                bestTime[3] = 0; // Set timestamp to 0, indicating that this score shouldn't be uploaded to the leaderboards.
	            }
	        }
	        await this.store();
	        await this.storeBestTimes();
	        localStorage.removeItem('mb-storage');
	    }
	    static async store() {
	        let obj = Util$1.shallowClone(this.data);
	        delete obj.bestTimes;
	        await this.databasePut('keyvalue', obj, 'storageData');
	    }
	    static async storeBestTimes() {
	        let string = JSON.stringify(this.data.bestTimes);
	        let compressed = await executeOnWorker$1('compress', string); // Compress the best times to make them take up less space and harder to modify from the outside.
	        await this.databasePut('keyvalue', compressed, 'bestTimes');
	    }
	    /** Get the three best times for a mission path. */
	    static getBestTimesForMission(path, count, placeholderName) {
	        let result = [];
	        let stored = this.data.bestTimes[path];
	        if (stored) {
	            result.push(...stored);
	        }
	        result.sort((a, b) => a[1] - b[1]); // Make sure they're in ascending order
	        let remaining = count - result.length;
	        for (let i = 0; i < remaining; i++) {
	            // Fill the remaining slots with Nardo Polo scores
	            result.push([placeholderName, MAX_SCORE_TIME, "", 0]);
	        }
	        return result;
	    }
	    /** Register a new time for a mission. Note that time must be in milliseconds.
	     * @returns The inserted score and the index at which at was inserted. Returns null, if the score wasn't inserted (so, not in the top maxScoresPerLevel best times).
	     */
	    static insertNewTime(path, name, timeInMs) {
	        var _a;
	        let stored = (_a = this.data.bestTimes[path]) !== null && _a !== void 0 ? _a : [];
	        let scoreId = Util$1.uuid();
	        let toInsert = [name, timeInMs, scoreId, Date.now()];
	        // Determine the correct index to insert the time at
	        let index;
	        for (index = 0; index < stored.length; index++) {
	            if (stored[index][1] > timeInMs)
	                break;
	        }
	        stored.splice(index, 0, toInsert);
	        // Shorten the array if needed
	        if (stored.length > this.maxScoresPerLevel) {
	            let lost = stored[this.maxScoresPerLevel];
	            stored = stored.slice(0, this.maxScoresPerLevel);
	            if (lost[2]) {
	                this.databaseGet('replays', lost[2]).then(replayData => {
	                    if (!replayData)
	                        return;
	                    this.databaseDelete('replays', lost[2]); // Delete the replay
	                });
	            }
	        }
	        this.data.bestTimes[path] = stored;
	        this.storeBestTimes();
	        if (index === this.maxScoresPerLevel)
	            return null;
	        return {
	            index,
	            score: toInsert
	        };
	    }
	    /** Gets an entry from an IndexedDB store by key. */
	    static async databaseGet(storeName, key) {
	        var _a;
	        let db = await this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readonly');
	        let store = transaction.objectStore(storeName);
	        let request = store.get(key);
	        await new Promise(resolve => request.onsuccess = resolve);
	        return (_a = request.result) !== null && _a !== void 0 ? _a : null;
	    }
	    /** Puts an entry into an IndexedDB store by key. */
	    static async databasePut(storeName, value, key) {
	        let db = await this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readwrite');
	        let store = transaction.objectStore(storeName);
	        store.put(value, key);
	        await new Promise(resolve => transaction.addEventListener('complete', resolve));
	    }
	    /** Deletes an entry from an IndexedDB store by key. */
	    static async databaseDelete(storeName, key) {
	        let db = await this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readwrite');
	        let store = transaction.objectStore(storeName);
	        store.delete(key);
	        await new Promise(resolve => transaction.addEventListener('complete', resolve));
	    }
	    /** Counts all entries in an IndexedDB store with a specific key. */
	    static async databaseCount(storeName, key) {
	        var _a;
	        let db = await this.idbDatabase;
	        let transaction = db.transaction(storeName, 'readonly');
	        let store = transaction.objectStore(storeName);
	        let request = store.count(key);
	        await new Promise(resolve => request.onsuccess = resolve);
	        return (_a = request.result) !== null && _a !== void 0 ? _a : null;
	    }
	    /** Makes sure the second parameter has the same deep structure as the first. */
	    static correctFields(truth, obj) {
	        // Look for all fields present in the truth but not present in the object
	        for (let key in truth) {
	            if (!(key in obj))
	                obj[key] = truth[key]; // Copy the value
	            // If it's a non-empty non-array object, recurse
	            if (truth[key] && typeof truth[key] === 'object' && !Array.isArray(truth[key]) && Object.keys(truth[key]).length)
	                this.correctFields(truth[key], obj[key]);
	        }
	        // Look for all fields not present in the truth but present in the object
	        for (let key in obj) {
	            if (!(key in truth))
	                delete obj[key];
	        }
	        return obj;
	    }
	    /** Performs a series of modification needed to upgrade an old version. */
	    static async onVersionUpgrade(from) {
	        for (let vers in VERSION_UPGRADE_PROCEDURES) {
	            if (Util$1.compareVersions(from, vers) >= 0)
	                continue;
	            await VERSION_UPGRADE_PROCEDURES[vers]();
	        }
	    }
	}
	StorageManager$1.maxScoresPerLevel = 5;
	//# sourceMappingURL=storage.js.map

	/** Represents a WebGL program composed of a vertex and fragment shader. */
	class Program {
	    constructor(renderer, vertexSource, fragmentSource, defineChunk = "") {
	        /** For each vertex buffer group, store a VAO for faster binding later. */
	        this.vertexArrayObjects = new Map();
	        this.uniformLocations = new Map();
	        this.attributeLocations = new Map();
	        this.compileStatusChecked = false;
	        this.renderer = renderer;
	        let { gl } = renderer;
	        if (!(gl instanceof WebGLRenderingContext)) {
	            // We need to convert the shader to version 300 in order to use fancy WebGL2 features
	            [vertexSource, fragmentSource] = this.convertFromGLSL100ToGLSL300(vertexSource, fragmentSource);
	        }
	        // Inject definitions into both shaders
	        let useLogDepthBuf = !(gl instanceof WebGLRenderingContext) || !!renderer.extensions.EXT_frag_depth;
	        let definitions = `
			${useLogDepthBuf ? '#define LOG_DEPTH_BUF' : ''}
			${(gl instanceof WebGLRenderingContext) ? '#define IS_WEBGL1' : ''}
			${defineChunk}
		`;
	        vertexSource = vertexSource.replace('#include <definitions>', definitions);
	        fragmentSource = fragmentSource.replace('#include <definitions>', definitions);
	        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
	        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	        gl.shaderSource(this.vertexShader, vertexSource);
	        gl.shaderSource(this.fragmentShader, fragmentSource);
	        gl.compileShader(this.vertexShader);
	        gl.compileShader(this.fragmentShader);
	        let program = gl.createProgram();
	        gl.attachShader(program, this.vertexShader);
	        gl.attachShader(program, this.fragmentShader);
	        gl.linkProgram(program);
	        // We don't check compile/link status here because it's a synchronous operation that blocks until compilation completes. It's much more efficient to check it later.
	        this.glProgram = program;
	    }
	    convertFromGLSL100ToGLSL300(vertSrc, fragSrc) {
	        vertSrc = '#version 300 es\n' + vertSrc;
	        fragSrc = '#version 300 es\n' + fragSrc;
	        vertSrc = vertSrc.replace(/\nattribute /g, '\nin ');
	        vertSrc = vertSrc.replace(/\nvarying /g, '\nout ');
	        fragSrc = fragSrc.replace(/\nvarying /g, '\nin ');
	        fragSrc = fragSrc.replace('\nvoid main()', 'out vec4 FragColor;\nvoid main()'); // There is no gl_FragColor, so we make our own one
	        fragSrc = fragSrc.replace(/gl_FragColor/g, 'FragColor');
	        fragSrc = fragSrc.replace(/gl_FragDepthEXT/g, 'gl_FragDepth');
	        // Create alises for the sampler functions
	        let definitions = `
			#define texture2D texture
			#define textureCube texture
			#include <definitions>
		`;
	        vertSrc = vertSrc.replace('#include <definitions>', definitions);
	        fragSrc = fragSrc.replace('#include <definitions>', definitions);
	        return [vertSrc, fragSrc];
	    }
	    checkCompileStatus() {
	        let { gl } = this.renderer;
	        this.compileStatusChecked = true;
	        if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
	            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(this.vertexShader));
	            return;
	        }
	        if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
	            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(this.fragmentShader));
	            return;
	        }
	        if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) {
	            console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(this.glProgram));
	            return;
	        }
	    }
	    /** Enables this program and properly cleans up the previously-enabled program. */
	    use() {
	        var _a;
	        if (this.renderer.currentProgram === this)
	            return;
	        if (!this.compileStatusChecked)
	            this.checkCompileStatus();
	        (_a = this.renderer.currentProgram) === null || _a === void 0 ? void 0 : _a.unuse();
	        this.renderer.gl.useProgram(this.glProgram);
	        this.renderer.currentProgram = this;
	    }
	    unuse() {
	        let { gl } = this.renderer;
	        this.renderer.bindVertexArray(null); // Disable the VAO first so that VBO changes aren't stored into it
	        for (let [, loc] of this.attributeLocations)
	            gl.disableVertexAttribArray(loc);
	    }
	    /** Binds a group of VBOs and stores the state in a VAO for faster reuse later. */
	    bindVertexBufferGroup(group) {
	        if (this.vertexArrayObjects.has(group)) {
	            // We've already seen this vertex group, just bind the VAO
	            this.renderer.bindVertexArray(this.vertexArrayObjects.get(group));
	            return;
	        }
	        let { gl } = this.renderer;
	        let vao = this.renderer.createVertexArray();
	        this.renderer.bindVertexArray(vao);
	        for (let buffer of group.buffers)
	            this.bindVertexBuffer(buffer);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); // VAOs also store the currently-bound element array buffer, and since we want a clean VAO, just bind null here
	        this.vertexArrayObjects.set(group, vao);
	    }
	    /** Binds a single vertex buffer and all attributes associated with it. */
	    bindVertexBuffer(buf) {
	        let { gl } = this.renderer;
	        gl.bindBuffer(gl.ARRAY_BUFFER, buf.buffer);
	        let offset = 0;
	        // Simply loop over all attributes and create vertex attribute pointers for them
	        for (let attribute in buf.attributes) {
	            let itemSize = buf.attributes[attribute];
	            let thisOffset = offset;
	            offset += itemSize;
	            let location = this.attributeLocations.get(attribute);
	            if (location === undefined) {
	                location = gl.getAttribLocation(this.glProgram, attribute);
	                if (location >= 0)
	                    this.attributeLocations.set(attribute, location);
	            }
	            if (location === -1)
	                continue;
	            gl.enableVertexAttribArray(location);
	            gl.vertexAttribPointer(location, itemSize, gl.FLOAT, false, Float32Array.BYTES_PER_ELEMENT * buf.stride, Float32Array.BYTES_PER_ELEMENT * thisOffset);
	        }
	    }
	    getUniformLocation(name) {
	        if (this.uniformLocations.has(name))
	            return this.uniformLocations.get(name);
	        let { gl } = this.renderer;
	        let location = gl.getUniformLocation(this.glProgram, name);
	        this.uniformLocations.set(name, location);
	        return location;
	    }
	    cleanUp() {
	        // We only need to trash the VAO
	        this.renderer.bindVertexArray(null);
	        for (let [, vao] of this.vertexArrayObjects)
	            this.renderer.deleteVertexArray(vao);
	        this.vertexArrayObjects.clear();
	    }
	}
	//# sourceMappingURL=program.js.map

	var shadowMapVert = "precision highp float;\r\nprecision highp int;\r\n\r\n#include <definitions>\r\n\r\nattribute vec3 position;\r\nattribute float meshInfoIndex;\r\n\r\nuniform highp sampler2D meshInfos;\r\nuniform int meshInfoTextureWidth;\r\nuniform int meshInfoTextureHeight;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nint _mod(int a, int n) {\r\n\t#ifdef IS_WEBGL1\r\n\t\treturn a - n * (a / n);\r\n\t#else\r\n\t\treturn a % n;\r\n\t#endif\r\n}\r\n\r\n// Refer to material_vert.glsl for an explanation of what this does\r\nmat4 getMeshInfo(int index) {\r\n\tivec2 coords = ivec2(\r\n\t\t_mod(4 * index, meshInfoTextureWidth),\r\n\t\t(4 * index) / meshInfoTextureWidth\r\n\t);\r\n\r\n\t#ifdef IS_WEBGL1\r\n\t\treturn mat4(\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(0, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(1, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(2, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(3, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight))\r\n\t\t);\r\n\t#else\r\n\t\treturn mat4(\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(0, 0), 0),\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(1, 0), 0),\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(2, 0), 0),\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(3, 0), 0)\r\n\t\t);\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\tmat4 meshInfo = getMeshInfo(int(meshInfoIndex + 0.1)); // + 0.1 to make sure it casts correctly, lol\r\n\tmat4 transform = meshInfo;\r\n\ttransform[0][3] = 0.0;\r\n\ttransform[1][3] = 0.0;\r\n\ttransform[2][3] = 0.0;\r\n\ttransform[3][3] = 1.0;\r\n\tfloat opacity = meshInfo[0][3];\r\n\r\n\tif (opacity < 1.0) {\r\n\t\t// Non-opaque objects don't cast shadows in our perfect world\r\n\t\tgl_Position = vec4(0.0);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Simply transform the vertex and we're done\r\n\tmat4 mvp = projectionMatrix * viewMatrix * transform;\r\n\tgl_Position = mvp * vec4(position, 1.0);\r\n}";

	var shadowMapFrag = "precision mediump float;\r\n\r\n#include <definitions>\r\n\r\nvoid main() {\r\n\tgl_FragColor = vec4(1.0); // Simple pass-through shader\r\n}";

	var particleVert = "precision highp float;\r\n\r\n#include <definitions>\r\n\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\nattribute float particleSpawnTime;\r\nattribute float particleLifetime;\r\nattribute vec3 particlePosition;\r\nattribute vec3 particleVelocity;\r\nattribute float particleInitialSpin;\r\n\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nuniform float time;\r\nuniform float acceleration;\r\nuniform float spinSpeed;\r\nuniform float dragCoefficient;\r\nuniform vec4 times;\r\nuniform vec4 sizes;\r\nuniform mat4 colors;\r\n\r\nvarying vec2 vUv;\r\nvarying float vFragDepth;\r\nvarying float vIsPerspective;\r\nvarying vec4 color;\r\n\r\nbool isPerspectiveMatrix(mat4 m) {\r\n\treturn m[2][3] == -1.0;\r\n}\r\n\r\n// Dynamic access of vecs and mats doesn't work properly in WebGL, so wrap the functionality in a function that does it the ugly way.\r\nfloat accessDynamically(vec4 data, int idx) {\r\n\t#ifdef IS_WEBGL1\r\n\t\t// Since all these indices are known at compile-time, this works just fine\r\n\t\tif (idx == 0) return data[0];\r\n\t\tif (idx == 1) return data[1];\r\n\t\tif (idx == 2) return data[2];\r\n\t\treturn data[3];\r\n\t#else\r\n\t\treturn data[idx];\r\n\t#endif\r\n}\r\n\r\nvec4 accessDynamically(mat4 data, int idx) {\r\n\t#ifdef IS_WEBGL1\r\n\t\tif (idx == 0) return data[0];\r\n\t\tif (idx == 1) return data[1];\r\n\t\tif (idx == 2) return data[2];\r\n\t\treturn data[3];\r\n\t#else\r\n\t\treturn data[idx];\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\tfloat elapsed = time - particleSpawnTime;\r\n\tfloat completion = clamp(elapsed / particleLifetime, 0.0, 1.0);\r\n\r\n\tif (completion == 1.0) {\r\n\t\t// We're dead, don't render\r\n\t\tgl_Position = vec4(0.0);\r\n\t\treturn;\r\n\t}\r\n\r\n\tfloat velElapsed = elapsed / 1000.0;\r\n\tvelElapsed = pow(velElapsed, 1.0 - dragCoefficient);\r\n\r\n\t// Compute the position\r\n\tvec3 computedPosition = particlePosition + particleVelocity * (velElapsed + acceleration * velElapsed * velElapsed / 2.0);\r\n\tfloat rotation = particleInitialSpin + spinSpeed * elapsed / 1000.0;\r\n\r\n\t// Check where we are in the times array\r\n\tint indexLow = 0;\r\n\tint indexHigh = 1;\r\n\tfor (int i = 2; i < 4; i++) {\r\n\t\tif (times[indexHigh] >= completion) break;\r\n\r\n\t\tindexLow = indexHigh;\r\n\t\tindexHigh = i;\r\n\t}\r\n\tif (times[1] > 1.0) indexHigh = indexLow; // Basically checking if (this.o.times.length === 1)\r\n\tfloat timeLow = accessDynamically(times, indexLow);\r\n\tfloat timeHigh = accessDynamically(times, indexHigh);\r\n\tfloat t = (completion - timeLow) / (timeHigh - timeLow);\r\n\r\n\t// Compute the color to send to the fragment shader\r\n\tcolor = mix(accessDynamically(colors, indexLow), accessDynamically(colors, indexHigh), t);\r\n\tcolor.a = pow(color.a, 1.5); // Adjusted because additive mixing can be kind of extreme\r\n\r\n\tvec4 viewPosition = viewMatrix * vec4(computedPosition, 1.0);\r\n\r\n\tvec2 scale = vec2(1.0);\r\n\tscale *= mix(accessDynamically(sizes, indexLow), accessDynamically(sizes, indexHigh), t); // Adjust sizing\r\n\r\n\t// Enable the following code if you don't want to attenuate the size with growing distance:\r\n\t// scale *= -viewPosition.z;\r\n\r\n\tvec2 center = vec2(0.5, 0.5); // Fixed, for now\r\n\tvec2 alignedPosition = (position - (center - vec2(0.5))) * scale;\r\n\tvec2 rotatedPosition;\r\n\r\n\trotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\r\n\trotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\r\n\tviewPosition.xy += rotatedPosition;\r\n\r\n\tgl_Position = projectionMatrix * viewPosition;\r\n\r\n\tvUv = uv;\r\n\r\n\t#ifdef LOG_DEPTH_BUF\r\n\t\tvFragDepth = 1.0 + gl_Position.w;\r\n\t\tvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\r\n\t#endif\r\n}";

	var particleFrag = "precision mediump float;\r\n\r\n#include <definitions>\r\n\r\nvarying vec2 vUv;\r\nvarying float vFragDepth;\r\nvarying float vIsPerspective;\r\nvarying vec4 color;\r\n\r\nuniform sampler2D diffuseMap;\r\nuniform float logDepthBufFC;\r\n\r\n#if defined(LOG_DEPTH_BUF) && defined(IS_WEBGL1)\r\n\t#extension GL_EXT_frag_depth : enable\r\n#endif\r\n\r\nvoid main() {\r\n\tgl_FragColor = color * texture2D(diffuseMap, vUv);\r\n\t\r\n\t#ifdef LOG_DEPTH_BUF\r\n\t\t// We always need to set gl_FragDepthEXT when it's present in the file, otherwise it gets real weird\r\n\t\t// Also: Doing a strict comparison with == 1.0 can cause noise artifacts\r\n\t\tgl_FragDepthEXT = (vIsPerspective != 0.0)? log2(vFragDepth) * logDepthBufFC * 0.5 : gl_FragCoord.z;\r\n\t#endif\r\n}";

	class Texture {
	    constructor(image) {
	        this.id = Util$1.uuid();
	        /** A single texture instance can be used by multiple renderering contexts, that's why we use a map here. */
	        this.glTextures = new Map();
	        if (!image.complete)
	            throw new Error("Can only pass loaded images into Texture.");
	        this.image = image;
	    }
	    /** Gets a WebGLTexture object for this texture for a given renderer. Creates one if it doesn't exist yet. */
	    getGLTexture(renderer) {
	        let glTexture = this.glTextures.get(renderer);
	        if (glTexture)
	            return glTexture;
	        let { gl } = renderer;
	        glTexture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, glTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
	        gl.generateMipmap(gl.TEXTURE_2D); // Make sure to enable mipmapping
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	        if (renderer.extensions.EXT_texture_filter_anisotropic)
	            gl.texParameteri(gl.TEXTURE_2D, renderer.extensions.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, 4); // Anisotropy to make it loop *sharp*
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        this.glTextures.set(renderer, glTexture);
	    }
	}
	//# sourceMappingURL=texture.js.map

	const imageCacheElement = document.querySelector('#image-cache');
	const MBP_REDIRECT_RULES = {
	    'assets/data_mbp/sound/gotgem.wav': 'assets/data_mbp/sound/gotdiamond.wav',
	    'assets/data_mbp/sound/gotallgems.wav': 'assets/data_mbp/sound/gotalldiamonds.wav',
	    'assets/data_mbp/sound/music/groovepolice': 'assets/data_mbp/sound/music/groove police',
	};
	/** Manages loading and caching of resources. */
	class ResourceManager$1 {
	    static get mainDataPath() {
	        return (G$1.modification === 'gold') ? './assets/data/' : './assets/data_mbp/';
	    }
	    static async init() {
	        let promiseMbg = this.loadResource('./api/directory_structure');
	        let promiseMbp = this.loadResource('./api/directory_structure_mbp');
	        let [responseMbg, responseMbp] = await Promise.all([promiseMbg, promiseMbp]);
	        this.dataDirectoryStructure = JSON.parse(await this.readBlobAsText(responseMbg));
	        this.dataMbpDirectoryStructure = JSON.parse(await this.readBlobAsText(responseMbp));
	    }
	    /** Creates a Texture from the path, or returns the cached version. */
	    static getTexture(path, prependPath = this.mainDataPath) {
	        let fullPath = prependPath + path;
	        let cached = this.textureCache.get(fullPath);
	        if (cached)
	            return Promise.resolve(cached);
	        if (this.loadTexturePromises.get(fullPath))
	            return this.loadTexturePromises.get(fullPath);
	        let promise = new Promise(async (resolve) => {
	            let image = await this.loadImage(fullPath);
	            let texture = new Texture(image);
	            texture.getGLTexture(mainRenderer$1); // Any texture is immediately uploaded to the main renderer context as a preloading measure. This avoids flickering later.
	            this.textureCache.set(fullPath, texture);
	            resolve(texture);
	        });
	        this.loadTexturePromises.set(fullPath, promise);
	        return promise;
	    }
	    static getTextureFromCache(path, prependPath = this.mainDataPath) {
	        let fullPath = prependPath + path;
	        let cached = this.textureCache.get(fullPath);
	        if (cached)
	            return cached;
	        return null;
	    }
	    /** Gets the full filenames (with extension) of the file located at the given path (without extension). */
	    static getFullNamesOf(path, mbp = G$1.modification === 'platinum') {
	        let parts = path.split('/');
	        let current = mbp ? this.dataMbpDirectoryStructure : this.dataDirectoryStructure;
	        while (parts.length) {
	            let part = parts.shift();
	            if (parts.length === 0) {
	                let results = [];
	                for (let name in current) {
	                    if (name.toLowerCase().startsWith(part.toLowerCase())
	                        // Make sure nothing or only the extension follows
	                        && (name.length === part.length || part.length === name.lastIndexOf('.')))
	                        results.push(name);
	                }
	                return results;
	            }
	            else {
	                current = current[part];
	                if (!current)
	                    return [];
	            }
	        }
	    }
	    static redirectPath(path) {
	        if (G$1.modification !== 'gold') {
	            for (let key in MBP_REDIRECT_RULES) {
	                if (path.includes(key))
	                    return path.replace(key, MBP_REDIRECT_RULES[key]);
	            }
	        }
	        return path;
	    }
	    /** Loads a resource from a path. Retries until it worked. */
	    static loadResource(path) {
	        path = this.redirectPath(path);
	        let cached = this.cachedResources.get(path);
	        if (cached)
	            return Promise.resolve(cached);
	        if (this.loadResourcePromises.get(path))
	            return this.loadResourcePromises.get(path);
	        let promise = new Promise((resolve) => {
	            const attempt = async () => {
	                try {
	                    let response = await fetch(path);
	                    if (!response.ok) {
	                        this.cachedResources.set(path, null);
	                        resolve(null);
	                        return;
	                    }
	                    // Retrieve the blob and store it
	                    let blob = await response.blob();
	                    this.cachedResources.set(path, blob);
	                    resolve(blob);
	                }
	                catch (e) {
	                    // Try again in a second
	                    setTimeout(attempt, 1000);
	                }
	            };
	            attempt();
	        });
	        this.loadResourcePromises.set(path, promise);
	        return promise;
	    }
	    /** Preloads an image at a given path. */
	    static loadImage(path) {
	        if (this.loadedImages.get(path))
	            return Promise.resolve(this.loadedImages.get(path));
	        if (this.loadImagePromises.get(path))
	            return this.loadImagePromises.get(path);
	        let promise = new Promise((resolve) => {
	            let image = new Image();
	            image.src = path;
	            image.onload = () => {
	                imageCacheElement.appendChild(image);
	                this.loadedImages.set(path, image);
	                resolve(image);
	            };
	        });
	        this.loadImagePromises.set(path, promise);
	        return promise;
	    }
	    static loadImages(paths) {
	        return Promise.all(paths.map((path) => this.loadImage(path)));
	    }
	    static getImageFromCache(path) {
	        return this.loadedImages.get(path) || null;
	    }
	    static readBlobAsText(blob, encoding) {
	        if (blob.text)
	            return blob.text();
	        else
	            return new Promise((resolve) => {
	                let reader = new FileReader();
	                reader.onload = (e) => resolve(e.target.result);
	                reader.readAsText(blob, encoding);
	            });
	    }
	    static async readBlobAsJson(blob, encoding) {
	        let text = await this.readBlobAsText(blob, encoding);
	        return JSON.parse(text);
	    }
	    static readBlobAsArrayBuffer(blob) {
	        if (blob.arrayBuffer)
	            return blob.arrayBuffer();
	        else
	            return new Promise((resolve) => {
	                let reader = new FileReader();
	                reader.onload = (e) => resolve(e.target.result);
	                reader.readAsArrayBuffer(blob);
	            });
	    }
	    static readBlobAsDataUrl(blob) {
	        return new Promise((resolve) => {
	            let reader = new FileReader();
	            reader.onload = (e) => resolve(e.target.result);
	            reader.readAsDataURL(blob);
	        });
	    }
	    /** Converts a blob to a temporary URL. Returns a cached URL whenever possible. */
	    static getUrlToBlob(blob) {
	        if (this.urlCache.get(blob))
	            return this.urlCache.get(blob);
	        let url = URL.createObjectURL(blob);
	        this.urlCache.set(blob, url);
	        return url;
	    }
	    /** Fetches a URL until a response a received. */
	    static retryFetch(input, init) {
	        return new Promise(resolve => {
	            const attempt = async () => {
	                try {
	                    let response = await fetch(input, init);
	                    let blob = await response.blob();
	                    resolve(blob);
	                }
	                catch (e) {
	                    setTimeout(attempt, 1000);
	                }
	            };
	            attempt();
	        });
	    }
	}
	ResourceManager$1.textureCache = new Map();
	ResourceManager$1.loadTexturePromises = new Map();
	/** The structure in the assets/data directory. Used mainly to look up file extensions. */
	ResourceManager$1.dataDirectoryStructure = {};
	ResourceManager$1.dataMbpDirectoryStructure = {};
	ResourceManager$1.loadResourcePromises = new Map();
	ResourceManager$1.cachedResources = new Map();
	ResourceManager$1.loadImagePromises = new Map();
	ResourceManager$1.loadedImages = new Map();
	ResourceManager$1.urlCache = new Map();
	//# sourceMappingURL=resources.js.map

	var BlendingType;
	(function (BlendingType) {
	    BlendingType[BlendingType["Normal"] = 0] = "Normal";
	    BlendingType[BlendingType["Additive"] = 1] = "Additive";
	    BlendingType[BlendingType["Subtractive"] = 2] = "Subtractive";
	})(BlendingType || (BlendingType = {}));
	const DEFAULT_CONTEXT_OPTIONS = {
	    alpha: false,
	    desynchronized: false
	};
	/** The renderer is the central keeper of the WebGL rendering context and performs the actual rendering of a scene. */
	class Renderer {
	    constructor(options) {
	        this.currentProgram = null;
	        /** Maps #define chunks, which uniquely identify a shader, to the program containing that shader. */
	        this.materialShaders = new Map();
	        this.pixelRatio = 1;
	        this.currentFramebuffer = null;
	        this.extensions = {
	            EXT_texture_filter_anisotropic: null,
	            EXT_frag_depth: null,
	            OES_element_index_uint: null,
	            WEBGL_depth_texture: null,
	            OES_standard_derivatives: null,
	            KHR_parallel_shader_compile: null,
	            OES_texture_float: null,
	            OES_vertex_array_object: null
	        };
	        options = { ...DEFAULT_CONTEXT_OPTIONS, ...options };
	        this.options = options;
	        let ctxOptions = {
	            desynchronized: options.desynchronized,
	            depth: true,
	            stencil: true,
	            antialias: false,
	            powerPreference: 'high-performance',
	            alpha: options.alpha,
	            premultipliedAlpha: true
	        };
	        this.gl = options.canvas.getContext('webgl2', ctxOptions);
	        if (!this.gl)
	            this.gl = options.canvas.getContext('webgl', ctxOptions);
	        let { gl } = this;
	        // Get all the extensions we need; many of these are enabled in WebGL2 by default:
	        this.extensions.EXT_texture_filter_anisotropic =
	            gl.getExtension('EXT_texture_filter_anisotropic') ||
	                gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
	                gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
	        this.extensions.EXT_frag_depth = gl.getExtension('EXT_frag_depth');
	        this.extensions.OES_element_index_uint = gl.getExtension('OES_element_index_uint');
	        this.extensions.WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');
	        this.extensions.OES_standard_derivatives = gl.getExtension('OES_standard_derivatives');
	        this.extensions.KHR_parallel_shader_compile = gl.getExtension('KHR_parallel_shader_compile');
	        this.extensions.OES_texture_float = gl.getExtension('OES_texture_float');
	        this.extensions.OES_vertex_array_object = gl.getExtension('OES_vertex_array_object');
	        this.shadowMapProgram = new Program(this, shadowMapVert, shadowMapFrag);
	        this.particleProgram = new Program(this, particleVert, particleFrag);
	        gl.clearColor(0.0, 0.0, 0.0, Number(!options.alpha));
	        gl.clearDepth(1.0);
	        gl.enable(gl.DEPTH_TEST);
	        gl.depthFunc(gl.LEQUAL);
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.BACK);
	        gl.frontFace(gl.CCW);
	    }
	    setSize(width, height) {
	        this.width = width;
	        this.height = height;
	        this.updateCanvasDimensions();
	    }
	    setPixelRatio(pixelRatio) {
	        this.pixelRatio = pixelRatio;
	        this.updateCanvasDimensions();
	    }
	    updateCanvasDimensions() {
	        this.options.canvas.setAttribute('width', Math.ceil(this.width * this.pixelRatio).toString());
	        this.options.canvas.setAttribute('height', Math.ceil(this.height * this.pixelRatio).toString());
	    }
	    setClearColor(r, g, b, a) {
	        this.gl.clearColor(r, g, b, a);
	    }
	    /** Renders a scene to a framebuffer (or the canvas) from the perspective of a camera. */
	    render(scene, camera, framebuffer = null, clearColorBuffer = true) {
	        if (!scene.compiled)
	            throw new Error("Scene not compiled! Can't render it.");
	        if (!scene.preparedForRender)
	            throw new Error("Scene not prepared for render! Can't render it.");
	        let { gl } = this;
	        this.drawCalls = 0;
	        if (framebuffer) {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);
	            gl.viewport(0, 0, framebuffer.width, framebuffer.height);
	        }
	        else {
	            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	            gl.viewport(0, 0, Math.ceil(this.width * this.pixelRatio), Math.ceil(this.height * this.pixelRatio));
	        }
	        this.currentFramebuffer = framebuffer;
	        gl.depthMask(true);
	        gl.clear(gl.DEPTH_BUFFER_BIT);
	        if (clearColorBuffer)
	            gl.clear(gl.COLOR_BUFFER_BIT);
	        // Precompute some uniform values
	        let uViewMatrix = new Float32Array(camera.matrixWorldInverse.elements);
	        let uProjectionMatrix = new Float32Array(camera.projectionMatrix.elements);
	        let uInverseProjectionMatrix = new Float32Array(camera.projectionMatrix.clone().invert().elements);
	        let uLogDepthBufFC = 2.0 / (Math.log(camera.far + 1.0) / Math.LN2); // Used for logarithmic depth buffer
	        let uEyePosition = new Float32Array(camera.position.toArray());
	        // Init the uniforms needed by all programs
	        for (let defineChunk of scene.allDefineChunks) {
	            let program = this.materialShaders.get(defineChunk);
	            program.use();
	            gl.uniformMatrix4fv(program.getUniformLocation('viewMatrix'), false, uViewMatrix);
	            gl.uniformMatrix4fv(program.getUniformLocation('projectionMatrix'), false, uProjectionMatrix);
	            gl.uniformMatrix4fv(program.getUniformLocation('inverseProjectionMatrix'), false, uInverseProjectionMatrix);
	            gl.uniform1f(program.getUniformLocation('logDepthBufFC'), uLogDepthBufFC);
	            gl.uniform3fv(program.getUniformLocation('eyePosition'), uEyePosition);
	            gl.uniform3fv(program.getUniformLocation('ambientLight'), scene.ambientLightBuffer);
	            gl.uniform3fv(program.getUniformLocation('directionalLightColor'), scene.directionalLightColorBuffer);
	            gl.uniform3fv(program.getUniformLocation('directionalLightDirection'), scene.directionalLightDirectionBuffer);
	            gl.uniformMatrix4fv(program.getUniformLocation('directionalLightTransform'), false, scene.directionalLightTransformBuffer);
	            gl.uniform1i(program.getUniformLocation('diffuseMap'), 0);
	            gl.uniform1i(program.getUniformLocation('envMap'), 1);
	            gl.uniform1i(program.getUniformLocation('directionalLightShadowMap'), 2);
	            gl.uniform1i(program.getUniformLocation('normalMap'), 3);
	            gl.uniform1i(program.getUniformLocation('specularMap'), 4);
	            gl.uniform1i(program.getUniformLocation('noiseMap'), 5);
	            gl.uniform1i(program.getUniformLocation('meshInfos'), 7);
	        }
	        // First, we draw all opaque objects
	        gl.disable(gl.BLEND);
	        this.renderMaterialGroups(scene, scene.staticOpaqueMaterialGroups, true);
	        this.renderMaterialGroups(scene, scene.dynamicOpaqueMaterialGroups, true);
	        // Then, we draw all transparent objects
	        gl.enable(gl.BLEND);
	        this.renderMaterialGroups(scene, scene.transparentMaterialGroups, false);
	        // Lastly, we render particles
	        if (scene.particleManager)
	            this.renderParticles(scene.particleManager, camera);
	    }
	    renderMaterialGroups(scene, groups, skipTransparent) {
	        var _a, _b, _c, _d, _e, _f;
	        let { gl } = this;
	        let lastMeshInfoTexture = null;
	        for (let group of groups) {
	            if (group.indexGroups.length === 0 || group.indexGroups[0].indices.length === 0)
	                continue; // No need to waste gl calls on an empty material group
	            let material = group.material;
	            if (!material.visible)
	                continue;
	            let program = this.materialShaders.get(group.defineChunk);
	            program.use();
	            program.bindVertexBufferGroup(group.vertexBufferGroup); // Bind the VAO, this will automatically set up all vertex attribute pointers
	            // Set uniforms related to the material
	            gl.uniform1i(program.getUniformLocation('skipTransparent'), Number(skipTransparent));
	            gl.uniform1f(program.getUniformLocation('materialOpacity'), material.opacity);
	            gl.uniform1f(program.getUniformLocation('specularIntensity'), material.specularIntensity);
	            gl.uniform1f(program.getUniformLocation('shininess'), material.shininess);
	            gl.uniform1f(program.getUniformLocation('reflectivity'), material.reflectivity);
	            gl.uniform1f(program.getUniformLocation('secondaryMapUvFactor'), material.secondaryMapUvFactor);
	            if (material.blending === BlendingType.Normal)
	                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // Premultiplied alpha
	            else if (material.blending === BlendingType.Additive)
	                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	            else if (material.blending === BlendingType.Subtractive)
	                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // I actually dunno if this one's correct
	            gl.depthMask(material.depthWrite);
	            // Bind all textures
	            if (material.receiveShadows || material.isShadow)
	                (_a = scene.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.bindShadowMap(); // Will bind to texture unit 2
	            this.bindTexture((_b = material.diffuseMap) === null || _b === void 0 ? void 0 : _b.getGLTexture(this), 0, gl.TEXTURE_2D);
	            this.bindTexture((_c = material.envMap) === null || _c === void 0 ? void 0 : _c.glTexture, 1, gl.TEXTURE_CUBE_MAP);
	            this.bindTexture((_d = material.normalMap) === null || _d === void 0 ? void 0 : _d.getGLTexture(this), 3, gl.TEXTURE_2D);
	            this.bindTexture((_e = material.specularMap) === null || _e === void 0 ? void 0 : _e.getGLTexture(this), 4, gl.TEXTURE_2D);
	            this.bindTexture((_f = material.noiseMap) === null || _f === void 0 ? void 0 : _f.getGLTexture(this), 5, gl.TEXTURE_2D);
	            this.bindMeshInfoTexture(group.meshInfoTexture, program, group.meshInfoTexture !== lastMeshInfoTexture);
	            lastMeshInfoTexture = group.meshInfoTexture;
	            // And now, draw all objects with this material in a single draw call :)
	            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, group.indexBuffer);
	            gl.drawElements(gl.TRIANGLES, group.count, gl.UNSIGNED_INT, group.offset * Uint32Array.BYTES_PER_ELEMENT);
	            this.drawCalls++;
	        }
	    }
	    renderParticles(particleManager, camera) {
	        let { gl } = this;
	        let program = this.particleProgram;
	        program.use();
	        program.bindVertexBufferGroup(particleManager.bufferGroup);
	        // Set up the uniforms we need
	        let uViewMatrix = new Float32Array(camera.matrixWorldInverse.elements);
	        let uProjectionMatrix = new Float32Array(camera.projectionMatrix.elements);
	        let uLogDepthBufFC = 2.0 / (Math.log(camera.far + 1.0) / Math.LN2);
	        gl.uniformMatrix4fv(program.getUniformLocation('viewMatrix'), false, uViewMatrix);
	        gl.uniformMatrix4fv(program.getUniformLocation('projectionMatrix'), false, uProjectionMatrix);
	        gl.uniform1f(program.getUniformLocation('logDepthBufFC'), uLogDepthBufFC);
	        gl.uniform1i(program.getUniformLocation('diffuseMap'), 0);
	        gl.uniform1f(program.getUniformLocation('time'), particleManager.currentRenderTime); // Since the particle is simulated in-shader, the shader needs to know the current simulation time
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, particleManager.indexBuffer);
	        gl.depthMask(false);
	        gl.enable(gl.BLEND);
	        // Now draw all particle groups
	        for (let [options, group] of particleManager.particleGroups) {
	            if (group.particles.length === 0)
	                continue;
	            let diffuseMap = ResourceManager$1.getTextureFromCache(options.texture);
	            this.bindTexture(diffuseMap.getGLTexture(this), 0, gl.TEXTURE_2D);
	            if (options.blending === BlendingType.Normal)
	                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // No premultiplied alpha
	            else if (options.blending === BlendingType.Additive)
	                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	            else if (options.blending === BlendingType.Subtractive)
	                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	            // Bind uniforms describing the particle simulation
	            gl.uniform1f(program.getUniformLocation('acceleration'), group.uniforms.acceleration);
	            gl.uniform1f(program.getUniformLocation('spinSpeed'), group.uniforms.spinSpeed);
	            gl.uniform1f(program.getUniformLocation('dragCoefficient'), group.uniforms.dragCoefficient);
	            gl.uniform4fv(program.getUniformLocation('times'), group.uniforms.times);
	            gl.uniform4fv(program.getUniformLocation('sizes'), group.uniforms.sizes);
	            gl.uniformMatrix4fv(program.getUniformLocation('colors'), false, group.uniforms.colors);
	            program.bindVertexBuffer(group.vertexBuffer);
	            gl.drawElements(gl.TRIANGLES, 6 * group.particles.length, gl.UNSIGNED_INT, 0);
	            this.drawCalls++;
	        }
	    }
	    /** Binds a mesh info data texture and sets up the corresponding uniforms. */
	    bindMeshInfoTexture(meshInfoTexture, program, bindTexture = true) {
	        let { gl } = this;
	        if (bindTexture)
	            this.bindTexture(meshInfoTexture.texture, 7, gl.TEXTURE_2D);
	        gl.uniform1i(program.getUniformLocation('meshInfoTextureWidth'), meshInfoTexture.width);
	        gl.uniform1i(program.getUniformLocation('meshInfoTextureHeight'), meshInfoTexture.height);
	    }
	    /** Binds a texture to a specific texture unit and texture target. If the texture doesn't exist, it unbinds the texture from the unit. */
	    bindTexture(texture, unit, target) {
	        var _a;
	        let { gl } = this;
	        gl.activeTexture(gl.TEXTURE0 + unit);
	        if (((_a = this.currentFramebuffer) === null || _a === void 0 ? void 0 : _a.colorTexture) === texture || !texture)
	            gl.bindTexture(target, null);
	        else
	            gl.bindTexture(target, texture);
	    }
	    /** Wrapper around createVertexArray[OES]. */
	    createVertexArray() {
	        let { gl } = this;
	        let ext = this.extensions.OES_vertex_array_object;
	        return (gl instanceof WebGLRenderingContext) ? ext.createVertexArrayOES() : gl.createVertexArray();
	    }
	    /** Wrapper around bindVertexArray[OES]. */
	    bindVertexArray(vao) {
	        let { gl } = this;
	        let ext = this.extensions.OES_vertex_array_object;
	        if (gl instanceof WebGLRenderingContext)
	            ext.bindVertexArrayOES(vao);
	        else
	            gl.bindVertexArray(vao);
	    }
	    /** Wrapper around deleteVertexArray[OES]. */
	    deleteVertexArray(vao) {
	        let { gl } = this;
	        let ext = this.extensions.OES_vertex_array_object;
	        if (gl instanceof WebGLRenderingContext)
	            ext.deleteVertexArrayOES(vao);
	        else
	            gl.deleteVertexArray(vao);
	    }
	    cleanUp() {
	        for (let [, program] of this.materialShaders)
	            program.cleanUp();
	    }
	}

	let q1$1 = new Quaternion$1();
	/** A class used as an utility for sound playback. */
	class AudioManager$1 {
	    static async init() {
	        var _a;
	        let AudioContext = (_a = window.AudioContext) !== null && _a !== void 0 ? _a : window.webkitAudioContext; // Safari
	        this.context = new AudioContext();
	        this.masterGain = this.context.createGain();
	        this.masterGain.gain.value = 1;
	        this.masterGain.connect(this.context.destination);
	        this.soundGain = this.context.createGain();
	        this.soundGain.gain.value = 0; // These values will be overwritten by the options anyway
	        this.soundGain.connect(this.masterGain);
	        this.musicGain = this.context.createGain();
	        this.musicGain.gain.value = 0;
	        this.musicGain.connect(this.masterGain);
	        this.updateVolumes();
	        if (typeof OggdecModule !== 'undefined')
	            this.oggDecoder = OggdecModule();
	        window.onfocus = () => {
	            if (Util$1.isTouchDevice)
	                this.masterGain.gain.value = 1;
	        };
	        window.onblur = () => {
	            // If we're on a touch device, mute the site when we blur it
	            if (Util$1.isTouchDevice)
	                this.masterGain.gain.value = 0;
	        };
	    }
	    static setAssetPath(path) {
	        this.assetPath = path;
	    }
	    static toFullPath(path) {
	        let fullPath = this.assetPath + path;
	        return fullPath;
	    }
	    /** Loads an audio buffer from a path. Returns the cached version whenever possible. */
	    static loadBuffer(path) {
	        var _a;
	        let fullPath = this.toFullPath(path);
	        // If there's a current level, see if there's a sound file for this path contained in it
	        let mission = (_a = G$1.game) === null || _a === void 0 ? void 0 : _a.mission;
	        let zipFile;
	        if (mission && mission.zipDirectory && mission.zipDirectory.files['data/sound/' + path]) {
	            zipFile = mission.zipDirectory.files['data/sound/' + path];
	        }
	        else {
	            // Return the cached version if there is one
	            if (this.audioBufferCache.has(fullPath))
	                return this.audioBufferCache.get(fullPath);
	        }
	        let promise = new Promise(async (resolve, reject) => {
	            try {
	                let blob = zipFile ? await zipFile.async('blob') : await ResourceManager$1.loadResource(fullPath);
	                let arrayBuffer = await ResourceManager$1.readBlobAsArrayBuffer(blob);
	                let audioBuffer;
	                if (path.endsWith('.ogg') && Util$1.isSafari()) {
	                    // Safari can't deal with .ogg. Apparently Firefox can't deal with some of them either??
	                    audioBuffer = await this.oggDecoder.decodeOggData(arrayBuffer);
	                }
	                else if (window.AudioContext) {
	                    try {
	                        audioBuffer = await this.context.decodeAudioData(arrayBuffer);
	                    }
	                    catch (e) {
	                        // Firefox should hit this case sometimes
	                        audioBuffer = await this.oggDecoder.decodeOggData(arrayBuffer);
	                    }
	                }
	                else {
	                    audioBuffer = await new Promise((res, rej) => {
	                        this.context.decodeAudioData(arrayBuffer, buff => res(buff), err => rej(err));
	                    });
	                }
	                resolve(audioBuffer);
	            }
	            catch (e) {
	                reject(e);
	                console.log("Errored path: " + path);
	            }
	        });
	        if (!zipFile)
	            this.audioBufferCache.set(fullPath, promise);
	        return promise;
	    }
	    static loadBuffers(paths) {
	        return Promise.all(paths.map((path) => this.loadBuffer(path)));
	    }
	    /**
	     * Creates an audio source.
	     * @param path The path of the audio resource. If it's an array, a random one will be selected.
	     * @param destination The destination node of the audio.
	     * @param position Optional: The position of the audio source in 3D space.
	     * @param preferStreaming If true, uses a normal <audio> element instead of play the audio as quickly as possible.
	     */
	    static createAudioSource(path, destination = this.soundGain, position, preferStreaming = false) {
	        let chosenPath = (typeof path === "string") ? path : Util$1.randomFromArray(path);
	        let fullPath = this.toFullPath(chosenPath);
	        let audioSource;
	        if (chosenPath.endsWith('.ogg') && Util$1.isSafari())
	            preferStreaming = false; // We can't
	        if (preferStreaming) {
	            if (this.audioBufferCache.has(fullPath)) {
	                // We already got the buffer, prefer that over streaming
	                preferStreaming = false;
	            }
	            else {
	                let audioElement = new Audio();
	                audioElement.src = fullPath;
	                audioElement.preload = 'auto';
	                audioSource = new AudioSource(audioElement, destination, position);
	            }
	        }
	        if (!preferStreaming) {
	            let bufferPromise = this.loadBuffer(chosenPath);
	            audioSource = new AudioSource(bufferPromise, destination, position);
	        }
	        if (position) {
	            audioSource.updatePositionalAudio();
	        }
	        this.audioSources.push(audioSource);
	        return audioSource;
	    }
	    /** Utility method for creating an audio source and playing it immediately. */
	    static play(path, volume = 1, destination = this.soundGain, position) {
	        let audioSource = this.createAudioSource(path, destination, position);
	        audioSource.gain.gain.value = volume;
	        audioSource.play();
	    }
	    /** Updates the pan and volume of positional audio sources based on the listener's location. */
	    static updatePositionalAudio() {
	        for (let source of this.audioSources) {
	            if (!source.position)
	                continue;
	            source.updatePositionalAudio();
	        }
	    }
	    static updateVolumes() {
	        // Quadratic because it feels better
	        this.musicGain.gain.linearRampToValueAtTime(StorageManager$1.data.settings.musicVolume ** 2, this.context.currentTime + 0.01);
	        this.soundGain.gain.linearRampToValueAtTime(StorageManager$1.data.settings.soundVolume ** 2, this.context.currentTime + 0.01);
	    }
	    static stopAllAudio() {
	        for (let source of this.audioSources.slice()) {
	            source.stop();
	        }
	    }
	    /** Normalizes the volume of positional audio sources based on the sounds around them to prevent the user's permanent loss of hearing. */
	    static normalizePositionalAudioVolume() {
	        let sources = this.audioSources.filter(x => x.position); // Get all positional sources
	        for (let i = 0; i < sources.length; i++) {
	            let source = sources[i];
	            let receivedVolume = 0;
	            // Accumulate the total received volume at this point
	            for (let j = 0; j < sources.length; j++) {
	                if (i === j)
	                    continue;
	                let otherSource = sources[j];
	                let distance = source.position.distanceTo(otherSource.position);
	                let preceivedVolume = Util$1.clamp(1 - distance / 30, 0, 1);
	                receivedVolume += preceivedVolume;
	            }
	            // Normalize it
	            source.gainFactor = Math.min(1 / receivedVolume, 1);
	        }
	    }
	}
	AudioManager$1.audioBufferCache = new Map();
	/** Stores a list of all currently playing audio sources. */
	AudioManager$1.audioSources = [];
	/** A small wrapper around audio nodes that are used to play a sound. */
	class AudioSource {
	    constructor(source, destination, position) {
	        this.stopped = false;
	        this.playing = false;
	        this.gainFactor = 1;
	        this.loop = false;
	        this.playbackRate = 1;
	        if (source instanceof Promise) {
	            this.promise = source;
	        }
	        else {
	            this.audioElement = source;
	            this.promise = new Promise(resolve => {
	                source.addEventListener('canplaythrough', () => resolve());
	            });
	        }
	        this.destination = destination;
	        this.position = position;
	        this.gain = AudioManager$1.context.createGain();
	        this.attenuationGain = AudioManager$1.context.createGain();
	        if (AudioManager$1.context.createStereoPanner)
	            this.panner = AudioManager$1.context.createStereoPanner();
	        else
	            this.panner = AudioManager$1.context.createPanner();
	        this.gain.connect(this.panner);
	        this.panner.connect(this.attenuationGain);
	        this.attenuationGain.connect(this.destination);
	        if (source instanceof Promise) {
	            this.node = AudioManager$1.context.createBufferSource();
	        }
	        else {
	            this.node = AudioManager$1.context.createMediaElementSource(source);
	        }
	        this.node.connect(this.gain);
	    }
	    setPannerValue(val) {
	        if (AudioManager$1.context.createStereoPanner) {
	            this.panner.pan.value = val;
	        }
	        else {
	            // https://stackoverflow.com/a/59545726
	            this.panner.panningModel = 'equalpower';
	            this.panner.setPosition(val, 0, 1 - Math.abs(val));
	        }
	    }
	    setLoop(loop) {
	        if (this.audioElement)
	            this.audioElement.loop = loop;
	        else
	            this.node.loop = loop;
	        this.loop = loop;
	    }
	    setPlaybackRate(playbackRate) {
	        if (this.audioElement)
	            this.audioElement.playbackRate = playbackRate;
	        else
	            this.node.playbackRate.value = playbackRate;
	        this.playbackRate = playbackRate;
	    }
	    async play() {
	        var _a, _b;
	        if (this.playing)
	            return;
	        if (this.stopped) {
	            this.stopped = false;
	            if (this.node instanceof AudioBufferSourceNode) {
	                // Gotta recreate this stuff
	                this.node = AudioManager$1.context.createBufferSource();
	                this.node.connect(this.gain);
	                this.node.loop = this.loop;
	                this.node.playbackRate.value = this.playbackRate;
	                this.stopped = false;
	                AudioManager$1.audioSources.push(this);
	            }
	        }
	        let maybeBuffer = await this.promise;
	        if (this.stopped)
	            return;
	        if (this.node instanceof AudioBufferSourceNode) {
	            if (this.node.buffer)
	                return; // Async stuff idk, could happen
	            this.node.buffer = maybeBuffer;
	            this.node.start();
	            this.node.onended = () => {
	                this.stop(); // Call .stop for clean-up purposes
	            };
	        }
	        else {
	            (_a = this.audioElement) === null || _a === void 0 ? void 0 : _a.play();
	            (_b = this.audioElement) === null || _b === void 0 ? void 0 : _b.addEventListener('ended', () => this.stop());
	        }
	        this.playing = true;
	    }
	    stop() {
	        this.stopped = true;
	        this.playing = false;
	        try {
	            if (this.audioElement) {
	                this.audioElement.pause();
	                // https://stackoverflow.com/questions/40843798/hide-html5-audio-video-notification-in-android-chrome
	                // Okay this doesn't seem to be working actually
	                this.audioElement.currentTime = 0;
	                this.audioElement.load();
	            }
	            else {
	                this.node.stop();
	            }
	        }
	        catch (e) { }
	        Util$1.removeFromArray(AudioManager$1.audioSources, this);
	    }
	    /** Updates the pan and volume of positional audio sources based on the listener's location. */
	    updatePositionalAudio() {
	        if (!this.position)
	            return;
	        let camera = G$1.game.renderer.camera;
	        // Get the relative position of the audio source from the listener's POV
	        let relativePosition = this.position.clone().sub(camera.position);
	        relativePosition.applyQuaternion(q1$1.copy(camera.orientation).conjugate());
	        relativePosition.normalize();
	        let distance = this.position.distanceTo(camera.position);
	        let panRemoval = Util$1.clamp(distance / 1, 0, 1); // If the listener is very close to the center, start moving the audio source to the center.
	        this.setPannerValue(relativePosition.x * 0.7 * panRemoval);
	        this.attenuationGain.gain.value = Util$1.clamp(1 - distance / 30, 0, 1) * this.gainFactor;
	    }
	}
	//# sourceMappingURL=audio.js.map

	const buttonToDisplayNameMbg = {
	    up: 'Move Forward',
	    down: 'Move Backward',
	    left: 'Move Left',
	    right: 'Move Right',
	    use: 'Use PowerUp',
	    jump: 'Jump',
	    cameraUp: 'Rotate Camera Up',
	    cameraDown: 'Rotate Camera Down',
	    cameraLeft: 'Rotate Camera Left',
	    cameraRight: 'Rotate Camera Right',
	    freeLook: 'Free Look',
	    restart: 'Restart',
	    blast: 'Use Blast'
	};
	const buttonToDisplayNameMbp = {
	    up: 'Move Forward',
	    down: 'Move Backward',
	    left: 'Move Left',
	    right: 'Move Right',
	    use: 'Use PowerUp',
	    jump: 'Jump',
	    cameraUp: 'Look Up',
	    cameraDown: 'Look Down',
	    cameraLeft: 'Look Left',
	    cameraRight: 'Look Right',
	    freeLook: 'Free Look',
	    restart: 'Respawn',
	    blast: 'Use Blast'
	};
	class OptionsScreen {
	    constructor(menu) {
	        /** Stores the button that's currently being rebound. */
	        this.currentlyRebinding = null;
	        /** Stores the value that we currently want to rebind to. */
	        this.rebindValue = null;
	        this.rebindConfirmWarningEnding = `Do you want to undo this<br>mapping?`;
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.homeButton, this.homeButtonSrc, () => {
	            this.hide();
	            menu.home.show();
	        }, undefined, undefined, G$1.modification === 'gold');
	        window.addEventListener('keydown', (e) => {
	            if (!this.currentlyRebinding || this.rebindValue)
	                return;
	            if (e.code === 'Escape') {
	                // Exits keybinding without changing anything
	                this.currentlyRebinding = null;
	                this.rebindDialog.classList.add('hidden');
	            }
	            else {
	                this.setKeybinding(this.currentlyRebinding, e.code);
	            }
	        });
	        window.addEventListener('mousedown', (e) => {
	            if (!this.currentlyRebinding || this.rebindValue)
	                return;
	            let buttonName = ["LMB", "MMB", "RMB"][e.button];
	            if (!buttonName)
	                return;
	            this.setKeybinding(this.currentlyRebinding, buttonName);
	        });
	        menu.setupButton(this.rebindConfirmYes, this.rebindConfirmYesSrc, () => {
	            // Find the other value and nullify its binding value (empty string)
	            for (let key in StorageManager$1.data.settings.gameButtonMapping) {
	                let typedKey = key;
	                let otherValue = StorageManager$1.data.settings.gameButtonMapping[typedKey];
	                if (otherValue === this.rebindValue)
	                    StorageManager$1.data.settings.gameButtonMapping[typedKey] = '';
	            }
	            // Bind the new value
	            StorageManager$1.data.settings.gameButtonMapping[this.currentlyRebinding] = this.rebindValue;
	            StorageManager$1.store();
	            this.currentlyRebinding = null;
	            this.rebindValue = null;
	            this.rebindConfirm.classList.add('hidden');
	            this.refreshKeybindings();
	        });
	        menu.setupButton(this.rebindConfirmNo, this.rebindConfirmNoSrc, () => {
	            // Cancel the rebinding process.
	            this.currentlyRebinding = null;
	            this.rebindValue = null;
	            this.rebindConfirm.classList.add('hidden');
	        });
	    }
	    async init() { }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    /** Returns a nice string representation of the key that a button is bound to. */
	    formatKeybinding(button) {
	        let str = Util$1.getKeyForButtonCode(StorageManager$1.data.settings.gameButtonMapping[button]);
	        if (str.startsWith('the'))
	            return str.slice(str.indexOf(' ') + 1, str.lastIndexOf(' ')); // If the string starts with 'the', then it's a mouse button, and we clean it up by only keeping the middle part (dropping 'the' and 'button')
	        else
	            return str;
	    }
	    /** Starts the rebinding process and shows a dialog. */
	    changeKeybinding(button) {
	        if (Util$1.isTouchDevice)
	            return; // Don't
	        let map = (G$1.modification === 'gold') ? buttonToDisplayNameMbg : buttonToDisplayNameMbp;
	        this.rebindDialog.classList.remove('hidden');
	        this.rebindDialog.children[1].innerHTML = `Press a new key or button for<br>"${map[button]}"`;
	        this.currentlyRebinding = button;
	    }
	    /** Updates the binding for a given button. */
	    setKeybinding(button, value) {
	        let map = (G$1.modification === 'gold') ? buttonToDisplayNameMbg : buttonToDisplayNameMbp;
	        // Check for collisions with other bindings
	        for (let key in StorageManager$1.data.settings.gameButtonMapping) {
	            let typedKey = key;
	            let otherValue = StorageManager$1.data.settings.gameButtonMapping[typedKey];
	            if (otherValue === value && typedKey !== button) {
	                // We found another binding that binds to the same key, bring up the conflict dialog.
	                this.rebindDialog.classList.add('hidden');
	                this.rebindConfirm.classList.remove('hidden');
	                this.rebindConfirm.children[1].innerHTML = `"${this.formatKeybinding(typedKey)}" is already bound to "${map[typedKey]}"!<br>` + this.rebindConfirmWarningEnding;
	                this.rebindValue = value;
	                return;
	            }
	        }
	        // Simply store the keybind.
	        StorageManager$1.data.settings.gameButtonMapping[button] = value;
	        StorageManager$1.store();
	        this.currentlyRebinding = null;
	        this.rebindDialog.classList.add('hidden');
	        this.refreshKeybindings();
	    }
	    showMarbleTexturePicker() {
	        return new Promise(resolve => {
	            // Show an image picker
	            let fileInput = document.createElement('input');
	            fileInput.setAttribute('type', 'file');
	            fileInput.setAttribute('accept', "image/x-png,image/gif,image/jpeg");
	            fileInput.onchange = async () => {
	                let file = fileInput.files[0];
	                await StorageManager$1.databasePut('keyvalue', file, 'marbleTexture'); // Store the Blob in the IndexedDB
	                resolve();
	            };
	            fileInput.click();
	        });
	    }
	}
	//# sourceMappingURL=options.js.map

	const SLIDER_KNOB_LEFT = 217;
	const SLIDER_KNOB_RIGHT = 344;
	const FRAME_RATE_OPTIONS$1 = [30, 60, 90, 120, 144, 240, 360, Infinity];
	class MbpOptionsScreen extends OptionsScreen {
	    constructor() {
	        super(...arguments);
	        this.applyButton = document.querySelector('#mbp-options-apply');
	        this.generalButton = document.querySelector('#mbp-options-general');
	        this.hotkeysButton = document.querySelector('#mbp-options-hotkeys');
	        this.generalContainer = document.querySelector('#mbp-options-general-container');
	        this.hotkeysContainer = document.querySelector('#mbp-options-hotkeys-container');
	        /** Array of functions that cause each option element to be refreshed. */
	        this.updateFuncs = [];
	        this.rebindConfirmWarningEnding = `Do you want to undo this mapping?`; // Removed <br>
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-options');
	        this.homeButton = document.querySelector('#mbp-options-home');
	        this.rebindDialog = document.querySelector('#mbp-rebind-dialog');
	        this.rebindConfirm = document.querySelector('#mbp-rebind-confirm');
	        this.rebindConfirmYes = document.querySelector('#mbp-rebind-confirm-yes');
	        this.rebindConfirmNo = document.querySelector('#mbp-rebind-confirm-no');
	        this.homeButtonSrc = 'options/home';
	        this.rebindConfirmYesSrc = 'exit/yes';
	        this.rebindConfirmNoSrc = 'exit/no';
	    }
	    async init() {
	        this.menu.setupButton(this.applyButton, 'options/apply', () => { }, undefined, undefined, false); // no-op
	        this.menu.setupButton(this.generalButton, 'options/general', () => {
	            this.generalContainer.classList.remove('hidden');
	            this.hotkeysContainer.classList.add('hidden');
	            // Lock the one button in place
	            this.generalButton.src = this.generalButton.src.slice(0, -5) + 'd.png';
	            this.generalButton.setAttribute('data-locked', '');
	            this.hotkeysButton.src = this.hotkeysButton.src.slice(0, -5) + 'n.png';
	            this.hotkeysButton.removeAttribute('data-locked');
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.hotkeysButton, 'options/hotkeys', () => {
	            this.generalContainer.classList.add('hidden');
	            this.hotkeysContainer.classList.remove('hidden');
	            // Lock the one button in place
	            this.hotkeysButton.src = this.hotkeysButton.src.slice(0, -5) + 'd.png';
	            this.hotkeysButton.setAttribute('data-locked', '');
	            this.generalButton.src = this.generalButton.src.slice(0, -5) + 'n.png';
	            this.generalButton.removeAttribute('data-locked');
	        }, undefined, undefined, false);
	        this.generalButton.click();
	        this.updateSliders();
	        const handler = () => {
	            var _a;
	            if (this.currentSliderElement)
	                StorageManager$1.store();
	            else
	                return;
	            this.currentSliderElement = null;
	            (_a = this.soundTestingSound) === null || _a === void 0 ? void 0 : _a.stop();
	            this.soundTestingSound = null;
	        };
	        window.addEventListener('mouseup', handler);
	        window.addEventListener('touchend', handler);
	        // Add all the option elements
	        /* General */
	        this.addHeading(this.generalContainer, 'General');
	        // These here are commented out because, really, they're all no-ops.
	        //this.addDropdown(this.generalContainer, 'resolution', 'Screen Resolution', ['640x480', '800x600', '1024x768']);
	        //this.addDropdown(this.generalContainer, 'videoDriver', 'Video Driver', ['OpenGL', 'Direct3D']);
	        //this.addDropdown(this.generalContainer, 'screenStyle', 'Screen Style', ['Windowed', 'Full']);
	        //this.addDropdown(this.generalContainer, 'shadows', 'Shadows', ['Disabled', 'Enabled'], true);
	        //this.addDropdown(this.generalContainer, 'colorDepth', 'Color Depth', ['16 Bit', '32 Bit']);
	        this.addDropdown(this.generalContainer, 'alwaysFreeLook', 'Free-Look', ['Disabled', 'Enabled'], true);
	        this.addDropdown(this.generalContainer, 'invertMouse', 'Invert Mouse', ['None', 'X Only', 'Y only', 'X and Y']);
	        this.addDropdown(this.generalContainer, 'frameRateCap', 'Max Frame Rate', FRAME_RATE_OPTIONS$1.map(x => isFinite(x) ? x.toString() : 'Unlimited'), undefined, undefined, undefined, () => {
	            this.menu.showAlertPopup('About unlocking frame rate', `Browsers are v-synced by default, causing some input lag. Chrome can unlock its FPS by starting it with a special flag. Check <a href="https://www.reddit.com/r/KrunkerIO/comments/esz4gt/unlock_browser_fps_this_one_is_for_you/" target="_blank">this Reddit post</a> for more info. Once your FPS are unlocked, use this setting to ensure your CPU doesn't overheat.`);
	        });
	        this.addDropdown(this.generalContainer, 'showFrameRate', 'Frame Rate', ['Hidden', 'Visible'], true);
	        this.addDropdown(this.generalContainer, 'showThousandths', 'Thousandths', ['Disabled', 'Enabled'], true);
	        this.addMarbleTexturePicker(this.generalContainer);
	        this.addDropdown(this.generalContainer, 'marbleReflectivity', 'Reflective Marble', ['Contextual', 'Disabled', 'Enabled']);
	        this.addDropdown(this.generalContainer, 'fancyShaders', 'Fancy Shaders', ['Disabled', 'Enabled'], true);
	        this.addDropdown(this.generalContainer, 'pixelRatio', 'Pixel Ratio', ['Max 0.5', 'Max 1.0', 'Max 1.5', 'Max 2.0', 'Max ∞']);
	        this.addDropdown(this.generalContainer, 'canvasDesynchronized', 'Low-latency mode', ['Disabled', 'Enabled'], true, () => {
	            location.reload(); // Because we can't just modify a WebGL context after its creation
	        }, undefined, () => {
	            this.menu.showAlertPopup('About low-latency mode', `In Chromium-based browsers, enabling low-latency mode can considerably reduce visual latency during gameplay. On some systems however, this can introduce flickering artifacts.`);
	        });
	        this.addDropdown(this.generalContainer, 'inputType', 'Input Type', ['Auto', 'Keyboard + Mouse', 'Touch'], undefined, () => {
	            let before = Util$1.isTouchDevice;
	            Util$1.isTouchDevice = (StorageManager$1.data.settings.inputType === 1) ? false : (StorageManager$1.data.settings.inputType === 2) ? true : Util$1.checkIsTouchDevice();
	            if (before !== Util$1.isTouchDevice)
	                location.reload(); // Restart that shit, don't take any chances
	        });
	        this.addSlider(this.generalContainer, 'fov', 'Field of View', 30, 120, undefined, undefined, 1, x => x.toString());
	        this.addSlider(this.generalContainer, 'musicVolume', 'Music Volume', 0, 1, () => AudioManager$1.updateVolumes(), undefined, undefined, x => Math.ceil(x * 100).toString());
	        this.addSlider(this.generalContainer, 'mouseSensitivity', 'Mouse Speed', 0, 1);
	        this.addSlider(this.generalContainer, 'soundVolume', 'Sound Volume', 0, 1, () => AudioManager$1.updateVolumes(), () => {
	            if (!this.soundTestingSound) {
	                // Play this STUPID honk sound or whatever
	                this.soundTestingSound = AudioManager$1.createAudioSource('testing.wav');
	                this.soundTestingSound.setLoop(true);
	                this.soundTestingSound.play();
	            }
	        }, undefined, x => Math.ceil(x * 100).toString());
	        this.addSlider(this.generalContainer, 'keyboardSensitivity', 'Keyboard Speed', 0, 1);
	        /* Touch controls */
	        this.addHeading(this.generalContainer, 'Touch Controls');
	        this.addDropdown(this.generalContainer, 'joystickPosition', 'Joystick Position', ['Fixed', 'Dynamic'], undefined, undefined, true);
	        this.addSlider(this.generalContainer, 'joystickSize', 'Joystick Size', 100, 500, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'joystickLeftOffset', 'Joystick Left Offset', 0, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'joystickVerticalPosition', 'Joystick Vertical Pos', 0, 1, undefined, undefined, undefined, (x) => Math.floor(100 * x) + '%', true);
	        this.addDropdown(this.generalContainer, 'actionButtonOrder', 'Button Order (⤾)', Util$1.getPermutations(['Blast', 'Jump', 'Use']).map(x => x.join(' - ')), undefined, undefined, true);
	        this.addSlider(this.generalContainer, 'actionButtonSize', 'Button Size', 50, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'actionButtonRightOffset', 'Button Right Offset', 0, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'actionButtonBottomOffset', 'Button Bottom Offset', 0, 300, undefined, undefined, 1, (x) => (x | 0).toString(), true);
	        this.addSlider(this.generalContainer, 'actionButtonAsJoystickMultiplier', 'Button Sensitivity Fac', 0, 3, undefined, undefined, 0.1, (x) => (Math.floor(x * 10) / 10).toString(), true);
	        /* Hotkeys */
	        this.addHotkey(this.hotkeysContainer, 'up');
	        this.addHotkey(this.hotkeysContainer, 'left');
	        this.addHotkey(this.hotkeysContainer, 'down');
	        this.addHotkey(this.hotkeysContainer, 'right');
	        this.addHotkey(this.hotkeysContainer, 'cameraUp');
	        this.addHotkey(this.hotkeysContainer, 'cameraLeft');
	        this.addHotkey(this.hotkeysContainer, 'cameraDown');
	        this.addHotkey(this.hotkeysContainer, 'cameraRight');
	        this.addHotkey(this.hotkeysContainer, 'jump');
	        this.addHotkey(this.hotkeysContainer, 'use');
	        this.addHotkey(this.hotkeysContainer, 'freeLook');
	        this.addHotkey(this.hotkeysContainer, 'restart');
	        this.addHotkey(this.hotkeysContainer, 'blast');
	        // Preload dropdown images
	        await ResourceManager$1.loadImages(['small', 'medium', 'large', 'xlarge'].map(x => './assets/ui_mbp/options/dropdown-' + x + '.png'));
	    }
	    /** Handles dragging of the currently active slider. */
	    updateSliders() {
	        requestAnimationFrame(() => this.updateSliders());
	        if (!this.currentSliderElement)
	            return;
	        let box = this.currentSliderElement.getBoundingClientRect();
	        let leftOffset = currentMousePosition.x - box.left * SCALING_RATIO$1 - SLIDER_KNOB_LEFT;
	        let completion = Util$1.clamp(leftOffset / (SLIDER_KNOB_RIGHT - SLIDER_KNOB_LEFT), 0, 1);
	        this.currentSliderCallback(completion);
	    }
	    /** Adds a heading element. */
	    addHeading(container, label) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_heading');
	        element.textContent = label;
	        container.appendChild(element);
	    }
	    /** Adds a dropdown element for a given option. */
	    addDropdown(container, setting, label, choices, boolean = false, onChange, smallText = false, onInfoClick) {
	        const close = () => {
	            // Hide the dropdown
	            clickPreventer.classList.add('hidden');
	            dropdownBackground.classList.add('hidden');
	            optionsContainer.classList.add('hidden');
	            button.style.zIndex = '';
	            selectionLabel.style.zIndex = '';
	        };
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_dropdown');
	        if (smallText)
	            element.classList.add('_small-text');
	        let p = document.createElement('p');
	        p.textContent = label + ':';
	        let button = document.createElement('img');
	        this.menu.setupButton(button, 'options/dropdown', () => {
	            if (clickPreventer.classList.contains('hidden')) {
	                // Show the dropdown
	                clickPreventer.classList.remove('hidden');
	                dropdownBackground.classList.remove('hidden');
	                optionsContainer.classList.remove('hidden');
	                button.style.zIndex = '2';
	                selectionLabel.style.zIndex = '2';
	            }
	            else {
	                close();
	            }
	        });
	        let selectionLabel = document.createElement('p');
	        // Element that prevents anything else from being pressed while the dropdown is shown
	        let clickPreventer = document.createElement('div');
	        clickPreventer.classList.add('hidden');
	        clickPreventer.addEventListener('click', () => close());
	        let dropdownBackground = document.createElement('img');
	        dropdownBackground.classList.add('hidden');
	        dropdownBackground.src = './assets/ui_mbp/options/dropdown-' + ['small', 'medium', 'large', 'xlarge'][Math.min(3, choices.length - 2)] + '.png'; // Choose the size dynamically based on the amount of choices
	        let optionsContainer = document.createElement('div');
	        optionsContainer.classList.add('hidden');
	        for (let option of choices) {
	            let elem = document.createElement('div');
	            elem.textContent = option;
	            optionsContainer.appendChild(elem);
	            elem.addEventListener('mousedown', async () => {
	                close();
	                selectionLabel.textContent = option;
	                let previousValue = StorageManager$1.data.settings[setting];
	                let newValue = (boolean ? Boolean(choices.indexOf(option)) : choices.indexOf(option)); // TypeScript stupid and I'm lazy
	                if (previousValue === newValue)
	                    return;
	                StorageManager$1.data.settings[setting] = newValue;
	                await StorageManager$1.store();
	                onChange === null || onChange === void 0 ? void 0 : onChange();
	            });
	        }
	        element.append(p, button, selectionLabel, clickPreventer, dropdownBackground, optionsContainer);
	        if (onInfoClick) {
	            let infoButton = document.createElement('img');
	            infoButton.src = './assets/svg/info_black_24dp.svg';
	            infoButton.classList.add('_info');
	            element.append(infoButton);
	            infoButton.addEventListener('click', onInfoClick);
	        }
	        container.appendChild(element);
	        this.updateFuncs.push(() => selectionLabel.textContent = choices[Number(StorageManager$1.data.settings[setting])]);
	    }
	    /** Adds a slider element for a given option. */
	    addSlider(container, setting, label, min, max, onChange, onDragStart, step = 0, showValue, smallText = false) {
	        const updateThumb = () => {
	            let completion = (StorageManager$1.data.settings[setting] - min) / (max - min);
	            thumb.style.left = Math.floor(Util$1.lerp(SLIDER_KNOB_LEFT, SLIDER_KNOB_RIGHT, completion)) + 'px';
	            if (showValue)
	                valueElem.textContent = showValue(StorageManager$1.data.settings[setting]);
	        };
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_slider');
	        if (smallText)
	            element.classList.add('_small-text');
	        let p = document.createElement('p');
	        p.textContent = label + ':';
	        let bar = document.createElement('img');
	        bar.src = './assets/ui_mbp/options/bar.png';
	        const handler = () => {
	            this.currentSliderElement = element;
	            this.currentSliderCallback = (completion) => {
	                StorageManager$1.data.settings[setting] = Util$1.roundToMultiple(Util$1.lerp(min, max, completion), step);
	                updateThumb();
	                onChange === null || onChange === void 0 ? void 0 : onChange();
	            };
	            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart();
	        };
	        bar.addEventListener('mousedown', handler);
	        bar.addEventListener('touchstart', handler);
	        let thumb = document.createElement('img');
	        thumb.src = './assets/ui_mbp/options/slider.png';
	        let valueElem = document.createElement('p');
	        element.append(p, bar, thumb);
	        if (showValue)
	            element.append(valueElem);
	        container.appendChild(element);
	        this.updateFuncs.push(updateThumb);
	    }
	    /** Adds a hotkey rebind element for a given key. */
	    addHotkey(container, key) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_hotkey');
	        let p = document.createElement('p');
	        let map = (G$1.modification === 'gold') ? buttonToDisplayNameMbg : buttonToDisplayNameMbp;
	        p.textContent = map[key] + ':';
	        let button = document.createElement('img');
	        this.menu.setupButton(button, 'options/bind', () => {
	            this.changeKeybinding(key);
	        });
	        let bindingLabel = document.createElement('p');
	        element.append(p, button, bindingLabel);
	        container.appendChild(element);
	        this.updateFuncs.push(() => bindingLabel.textContent = this.formatKeybinding(key));
	    }
	    /** Adds a configurable button element. */
	    addButton(container, label, buttonLabel, onClick) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-options-element', '_button');
	        let p = document.createElement('p');
	        p.textContent = label + ':';
	        let button = document.createElement('img');
	        this.menu.setupButton(button, 'options/bind', () => onClick());
	        let buttonLabelP = document.createElement('p');
	        buttonLabelP.textContent = buttonLabel;
	        element.append(p, button, buttonLabelP);
	        container.appendChild(element);
	        return element;
	    }
	    addMarbleTexturePicker(container) {
	        let element = this.addButton(container, 'Marble Texture', 'Select File', async () => {
	            await this.showMarbleTexturePicker();
	            resetButton.classList.remove('hidden');
	        });
	        // Add an additional button that removes the texture again
	        let resetButton = document.createElement('img');
	        resetButton.src = './assets/ui_mbp/mp/team/nomarble.png';
	        resetButton.id = 'mbp-reset-marble-texture-button';
	        resetButton.title = "Clear texture";
	        resetButton.classList.add('hidden');
	        resetButton.addEventListener('click', () => {
	            StorageManager$1.databaseDelete('keyvalue', 'marbleTexture');
	            resetButton.classList.add('hidden');
	        });
	        element.appendChild(resetButton);
	        this.updateFuncs.push(async () => {
	            if ((await StorageManager$1.databaseCount('keyvalue', 'marbleTexture')) === 0) {
	                resetButton.classList.add('hidden');
	            }
	            else {
	                resetButton.classList.remove('hidden');
	            }
	        });
	    }
	    refreshKeybindings() {
	        this.updateAllElements(); // Can't hurt lol
	    }
	    updateAllElements() {
	        for (let func of this.updateFuncs)
	            func();
	    }
	    show() {
	        super.show();
	        this.updateAllElements();
	    }
	}
	//# sourceMappingURL=options_mbp.js.map

	/** Works exactly like the regular Map, except that getting a non-stored key sets that key to a default value and returns that value instead. */
	class DefaultMap {
	    constructor(createDefault) {
	        this.map = new Map();
	        this.createDefault = createDefault;
	    }
	    get size() {
	        return this.map.size;
	    }
	    clear() {
	        this.map.clear();
	    }
	    delete(key) {
	        this.map.delete(key);
	    }
	    get(key) {
	        var _a;
	        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : (this.map.set(key, this.createDefault()), this.map.get(key));
	    }
	    has(key) {
	        return this.map.has(key);
	    }
	    set(key, value) {
	        this.map.set(key, value);
	    }
	    [Symbol.iterator]() {
	        return this.map[Symbol.iterator]();
	    }
	    keys() {
	        return this.map.keys();
	    }
	    values() {
	        return this.map.values();
	    }
	    entries() {
	        return this.map.entries();
	    }
	}
	//# sourceMappingURL=default_map.js.map

	const nullable = Symbol('nullable');
	const union = Symbol('union');
	const partial = Symbol('partial');
	class FixedFormatBinarySerializer {
	    static init() {
	        this.buffer = new ArrayBuffer(2 ** 24); // Allocate a buffer large enough so we never need to enlarge
	        this.view = new DataView(this.buffer);
	        this.bytes = new Uint8Array(this.buffer);
	    }
	    static format(x) {
	        return x;
	    }
	    static encode(data, format) {
	        this.index = 0;
	        this.write(data, format);
	        return this.buffer.slice(0, this.index);
	    }
	    static write(data, format, discriminator) {
	        if (typeof format === 'string') {
	            this.writePrimitive(data, format);
	        }
	        else if (format[0] === nullable) {
	            this.view.setUint8(this.index++, Number(data !== null));
	            if (data !== null)
	                this.write(data, format[1]);
	        }
	        else if (format[0] === union) {
	            let discriminator = format[1];
	            let index;
	            for (let i = 2; i < format.length; i++) {
	                if (format[i][discriminator] === data[discriminator]) {
	                    index = i - 2;
	                    break;
	                }
	            }
	            if (index === undefined)
	                throw new Error(`${data[discriminator]} is not a valid discriminator for this union type.`);
	            this.writePrimitive(index, 'varint');
	            this.write(data, format[index + 2], discriminator);
	        }
	        else if (format[0] === partial) {
	            let keys = Object.keys(format[1]);
	            let count = 0;
	            for (let key in data) {
	                if (data[key] !== undefined && key in format[1])
	                    count++;
	            }
	            this.writePrimitive(count, 'varint');
	            for (let key in format[1]) {
	                if (data[key] === undefined)
	                    continue;
	                this.writePrimitive(keys.indexOf(key), 'varint');
	                this.write(data[key], format[1][key]);
	            }
	        }
	        else if (Array.isArray(format)) {
	            this.writePrimitive(data.length, 'varint');
	            for (let elem of data)
	                this.write(elem, format[0]);
	        }
	        else if (typeof format === 'object') {
	            for (let key in format) {
	                if (key === discriminator)
	                    continue;
	                this.write(data[key], format[key]);
	            }
	        }
	        else {
	            throw new Error("Incorrect format!");
	        }
	    }
	    static writePrimitive(data, format) {
	        let byteLength;
	        switch (format) {
	            case 'boolean':
	                this.view.setUint8(this.index++, Number(data));
	                break;
	            case 'u8':
	                this.view.setUint8(this.index++, data);
	                break;
	            case 's8':
	                this.view.setInt8(this.index++, data);
	                break;
	            case 'u16':
	                this.view.setUint16((this.index += 2) - 2, data, true);
	                break;
	            case 's16':
	                this.view.setInt16((this.index += 2) - 2, data, true);
	                break;
	            case 'u32':
	                this.view.setUint32((this.index += 4) - 4, data, true);
	                break;
	            case 's32':
	                this.view.setInt32((this.index += 4) - 4, data, true);
	                break;
	            case 'f32':
	                this.view.setFloat32((this.index += 4) - 4, data, true);
	                break;
	            case 'f64':
	                this.view.setFloat64((this.index += 8) - 8, data, true);
	                break;
	            case 'varint':
	                if (!Number.isInteger(data))
	                    throw new Error("Varint passed incorrect data: " + data);
	                data = (Math.abs(data) << 1) | Number(data < 0);
	                do {
	                    let value = data & 127;
	                    if (data >= 128)
	                        value |= 128;
	                    data >>= 7;
	                    this.view.setUint8(this.index++, value);
	                } while (data > 0);
	                break;
	            case 'string':
	                byteLength = this.stringToUtf8Bytes(data, this.stringBuffer, 0);
	                this.writePrimitive(byteLength, 'varint');
	                this.bytes.set(this.stringBuffer.subarray(0, byteLength), this.index);
	                this.index += byteLength;
	                break;
	            default:
	                throw new Error("Incorrect format: " + format);
	        }
	    }
	    static decode(buffer, format) {
	        this.index = 0;
	        this.decodeByteLength = buffer.byteLength;
	        this.bytes.set(new Uint8Array(buffer));
	        return this.read(format);
	    }
	    static read(format, discriminator) {
	        if (typeof format === 'string') {
	            return this.readPrimitive(format);
	        }
	        else if (format[0] === nullable) {
	            let isNull = !this.view.getUint8(this.index++);
	            if (isNull)
	                return null;
	            else
	                return this.read(format[1]);
	        }
	        else if (format[0] === union) {
	            let index = this.readPrimitive('varint');
	            let discriminator = format[1];
	            let obj = {
	                [discriminator]: format[index + 2][discriminator],
	                ...this.read(format[index + 2], discriminator)
	            };
	            return obj;
	        }
	        else if (format[0] === partial) {
	            let count = this.readPrimitive('varint');
	            let obj = {};
	            let keys = Object.keys(format[1]);
	            for (let i = 0; i < count; i++) {
	                let keyIndex = this.readPrimitive('varint');
	                let key = keys[keyIndex];
	                obj[key] = this.read(format[1][key]);
	            }
	            return obj;
	        }
	        else if (Array.isArray(format)) {
	            let arrayLength = this.read('varint');
	            let arr = [];
	            for (let i = 0; i < arrayLength; i++) {
	                if (this.index >= this.decodeByteLength)
	                    throw new Error("Out of bounds!"); // Gotta do this check so the decoder can't get cheesed by artifically manipulated data where the index is like a huge number
	                arr.push(this.read(format[0]));
	            }
	            return arr;
	        }
	        else if (typeof format === 'object') {
	            let obj = {};
	            for (let key in format) {
	                if (key === discriminator)
	                    continue;
	                obj[key] = this.read(format[key]);
	            }
	            return obj;
	        }
	    }
	    static readPrimitive(format) {
	        let res;
	        let byteLength;
	        switch (format) {
	            case 'boolean':
	                return !!this.view.getUint8(this.index++);
	            case 'u8':
	                return this.view.getUint8(this.index++);
	            case 's8':
	                return this.view.getInt8(this.index++);
	            case 'u16':
	                return this.view.getUint16((this.index += 2) - 2, true);
	            case 's16':
	                return this.view.getInt16((this.index += 2) - 2, true);
	            case 'u32':
	                return this.view.getUint32((this.index += 4) - 4, true);
	            case 's32':
	                return this.view.getInt32((this.index += 4) - 4, true);
	            case 'f32':
	                return this.view.getFloat32((this.index += 4) - 4, true);
	            case 'f64':
	                return this.view.getFloat64((this.index += 8) - 8, true);
	            case 'varint':
	                res = 0;
	                for (let i = 0; true; i++) {
	                    let nextByte = this.view.getUint8(this.index++);
	                    res += (nextByte & 127) << (7 * i);
	                    if (!(nextByte & 128))
	                        break;
	                }
	                res = (res >> 1) * (1 - 2 * (res & 1));
	                return res;
	            case 'string':
	                byteLength = this.readPrimitive('varint');
	                return this.utf8BytesToString(this.bytes, this.index, this.index += byteLength);
	        }
	    }
	    /** Converts a string into UTF-8 bytes. Done manually because it's significantly faster than TextEncoder. */
	    static stringToUtf8Bytes(str, out, offset) {
	        let p = offset;
	        for (let i = 0; i < str.length; i++) {
	            let c = str.charCodeAt(i);
	            if (c < 128) {
	                out[p++] = c;
	            }
	            else if (c < 2048) {
	                out[p++] = (c >> 6) | 192;
	                out[p++] = (c & 63) | 128;
	            }
	            else if (((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&
	                ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {
	                // Surrogate Pair
	                c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);
	                out[p++] = (c >> 18) | 240;
	                out[p++] = ((c >> 12) & 63) | 128;
	                out[p++] = ((c >> 6) & 63) | 128;
	                out[p++] = (c & 63) | 128;
	            }
	            else {
	                out[p++] = (c >> 12) | 224;
	                out[p++] = ((c >> 6) & 63) | 128;
	                out[p++] = (c & 63) | 128;
	            }
	        }
	        return p - offset;
	    }
	    /** Converts a UTF-8 bytes back into a string. Done manually because it's significantly faster than TextDecoder. */
	    static utf8BytesToString(bytes, start, end) {
	        let out = '', pos = start;
	        while (pos < end) {
	            let c1 = bytes[pos++];
	            if (c1 < 128) {
	                out += String.fromCharCode(c1);
	            }
	            else if (c1 > 191 && c1 < 224) {
	                let c2 = bytes[pos++];
	                out += String.fromCharCode((c1 & 31) << 6 | c2 & 63);
	            }
	            else if (c1 > 239 && c1 < 365) {
	                // Surrogate Pair
	                let c2 = bytes[pos++];
	                let c3 = bytes[pos++];
	                let c4 = bytes[pos++];
	                let u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;
	                out += String.fromCharCode(0xD800 + (u >> 10));
	                out += String.fromCharCode(0xDC00 + (u & 1023));
	            }
	            else {
	                let c2 = bytes[pos++];
	                let c3 = bytes[pos++];
	                out += String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
	            }
	        }
	        return out;
	    }
	    static encodeDecode(data, format) {
	        return this.decode(this.encode(data, format), format);
	    }
	}
	FixedFormatBinarySerializer.stringBuffer = new Uint8Array(2 ** 16);
	FixedFormatBinarySerializer.index = 0;
	FixedFormatBinarySerializer.init();
	//# sourceMappingURL=fixed_format_binary_serializer.js.map

	const vector2Format = { x: 'f32', y: 'f32' };
	const vector3Format = { x: 'f32', y: 'f32', z: 'f32' };
	const quaternionFormat = { x: 'f32', y: 'f32', z: 'f32', w: 'f32' };
	const powerUpStateFormat = {
	    pickUpFrame: [nullable, 'varint'],
	    pickedUpBy: [nullable, 'varint']
	};
	const entityStateFormat = [union, 'entityType', {
	        entityType: 'marble',
	        position: vector3Format,
	        orientation: quaternionFormat,
	        linearVelocity: vector3Format,
	        angularVelocity: vector3Format,
	        extras: [partial, {
	                heldPowerUp: 'varint',
	                helicopterEnableFrame: 'varint',
	                superBounceEnableFrame: 'varint',
	                shockAbsorberEnableFrame: 'varint',
	                megaMarbleEnableFrame: 'varint',
	                orientationQuat: quaternionFormat,
	                respawnFrame: 'varint',
	                outOfBoundsFrame: 'varint',
	                teleportStates: [{
	                        trigger: 'varint',
	                        entryFrame: [nullable, 'varint'],
	                        exitFrame: [nullable, 'varint']
	                    }],
	                teleportEnableTime: 'f32',
	                teleportDisableTime: 'f32',
	                blastAmount: 'f32',
	                inFinishState: 'boolean'
	            }]
	    }, {
	        entityType: 'player',
	        controlState: {
	            movement: vector2Format,
	            yaw: 'f32',
	            pitch: 'f32',
	            jumping: 'boolean',
	            using: 'boolean',
	            blasting: 'boolean'
	        }
	    }, {
	        entityType: 'clock',
	        time: 'f64',
	        elapsedTime: 'f64',
	        timeTravelBonus: 'f64'
	    }, {
	        entityType: 'pathedInterior',
	        currentTime: 'f64',
	        targetTime: 'f64',
	    }, {
	        entityType: 'gem',
	        pickedUpBy: [nullable, 'varint'],
	        pickUpFrame: [nullable, 'varint']
	    }, {
	        entityType: 'powerUp',
	        ...powerUpStateFormat
	    }, {
	        entityType: 'bumper',
	        lastContactTime: 'f64'
	    }, {
	        entityType: 'trapDoor',
	        lastContactTime: 'f64'
	    }, {
	        entityType: 'explosive',
	        disappearTime: 'f64'
	    }, {
	        entityType: 'pushButton',
	        lastContactTime: 'f64'
	    }, {
	        entityType: 'balloon',
	        position: vector3Format,
	        orientation: quaternionFormat,
	        linearVelocity: vector3Format,
	        angularVelocity: vector3Format
	    }, {
	        entityType: 'checkpointState',
	        currentCheckpoint: [nullable, 'varint'],
	        currentCheckpointTrigger: [nullable, 'varint'],
	        checkpointCollectedGems: ['varint'],
	        checkpointHeldPowerUp: [nullable, 'varint'],
	        checkpointUp: [nullable, vector3Format],
	        checkpointBlast: [nullable, 'f32']
	    }, {
	        entityType: 'randomPowerUp',
	        ...powerUpStateFormat,
	        probeCount: 'varint',
	        lastInstance: [nullable, 'varint']
	    }, {
	        entityType: 'finishState',
	        frame: [nullable, 'varint'],
	        time: [nullable, 'f64'],
	        elapsedTime: [nullable, 'f64'],
	        isLegal: 'boolean'
	    }];
	const entityUpdateFormat = {
	    updateId: 'varint',
	    entityId: 'varint',
	    frame: 'varint',
	    state: [nullable, entityStateFormat]
	};
	const playerFormat = {
	    id: 'varint',
	    sessionId: 'string',
	    marbleId: 'varint',
	    checkpointStateId: 'varint'
	};
	const gameServerCommandFormat = [union, 'command', {
	        command: 'ping',
	        timestamp: 'f32'
	    }, {
	        command: 'pong',
	        timestamp: 'f32',
	        subtract: 'f32'
	    }, {
	        command: 'join',
	        gameId: 'string'
	    }, {
	        command: 'clientStateBundle',
	        serverFrame: 'varint',
	        clientFrame: 'varint',
	        entityUpdates: [entityUpdateFormat],
	        affectionGraph: [{
	                from: 'varint',
	                to: 'varint'
	            }],
	        possibleConflictingEntities: ['varint'],
	        baseState: [nullable, {
	                frame: 'varint',
	                updates: [entityUpdateFormat]
	            }],
	        maxReceivedServerUpdateId: 'varint',
	        maxReceivedBaseStateId: 'varint'
	    }, {
	        command: 'serverStateBundle',
	        serverFrame: 'varint',
	        entityUpdates: [entityUpdateFormat],
	        baseStateRequests: ['varint'],
	        baseState: [{
	                id: 'varint',
	                responseFrame: 'varint',
	                update: entityUpdateFormat
	            }],
	        maxReceivedClientUpdateFrame: 'varint'
	    }, {
	        command: 'timeState',
	        serverFrame: 'varint',
	        targetFrame: 'varint'
	    }, {
	        command: 'gameJoinInfo',
	        serverFrame: 'varint',
	        clientFrame: 'varint',
	        players: [playerFormat],
	        localPlayerId: 'varint',
	        entityStates: [entityUpdateFormat]
	    }, {
	        command: 'playerJoin',
	        ...playerFormat
	    }, {
	        command: 'scheduleRestart',
	        frame: 'varint'
	    }, {
	        command: 'running'
	    }, {
	        command: 'restartIntent'
	    }, {
	        command: 'playerRestartIntentState',
	        playerId: 'varint',
	        state: 'boolean'
	    }, {
	        command: 'sendTextMessage',
	        body: 'string'
	    }, {
	        command: 'textMessage',
	        playerId: 'varint',
	        body: 'string'
	    }, {
	        command: 'leave'
	    }];
	const gameServerMessageFormat = FixedFormatBinarySerializer.format({
	    localPacketId: 'varint',
	    lastRemotePacketId: 'varint',
	    needsAck: 'boolean',
	    acks: ['varint'],
	    commandWrappers: [{
	            packetId: 'varint',
	            command: gameServerCommandFormat
	        }]
	});
	//# sourceMappingURL=game_server_format.js.map

	/** Returns a promise that resolves after `ms` milliseconds. */
	const wait = (ms) => {
	    return new Promise((resolve) => setTimeout(resolve, ms));
	};
	var Reliability;
	(function (Reliability) {
	    Reliability[Reliability["Unreliable"] = 0] = "Unreliable";
	    Reliability[Reliability["Urgent"] = 1] = "Urgent";
	    Reliability[Reliability["Relaxed"] = 2] = "Relaxed";
	})(Reliability || (Reliability = {}));
	class GameServerConnection {
	    constructor(socket) {
	        this.queuedCommands = [];
	        this.awaitingRelaxedAck = [];
	        this.queuedAcks = [];
	        this.localPacketId = 0;
	        this.lastRemotePacketId = -1;
	        this.tickTimeout = 0;
	        this.addedOneWayLatency = 0;
	        this.commandHandlers = new DefaultMap(() => []);
	        this.beforeTick = null;
	        this.onIncomingPacket = null;
	        this.onOutgoingPacket = null;
	        this.socket = socket;
	        this.socket.receive = async (data) => {
	            var _a;
	            let decoded = FixedFormatBinarySerializer.decode(data, gameServerMessageFormat);
	            if (this.addedOneWayLatency)
	                await wait(this.addedOneWayLatency);
	            (_a = this.onIncomingPacket) === null || _a === void 0 ? void 0 : _a.call(this, data.byteLength);
	            this.onMessage(decoded);
	        };
	    }
	    queueCommand(command, reliability) {
	        reliability = Reliability.Unreliable;
	        let commandObject = {
	            command,
	            reliability: reliability,
	            localPacketId: this.localPacketId
	        };
	        this.queuedCommands.push(commandObject);
	    }
	    tick() {
	        var _a;
	        (_a = this.beforeTick) === null || _a === void 0 ? void 0 : _a.call(this);
	        if (this.tickTimeout-- > 0 && this.queuedCommands.length === 0)
	            return;
	        this.sendCommands();
	        if (this.queuedCommands.length === 0)
	            this.tickTimeout = 2; // When we've got no more commands to send, our main function is simply to send over ACKs - we can do this at a reduced rate.
	    }
	    sendCommands() {
	        let message = {
	            localPacketId: this.localPacketId++,
	            lastRemotePacketId: this.lastRemotePacketId,
	            needsAck: this.queuedCommands.some(x => x.reliability === Reliability.Relaxed),
	            commandWrappers: this.queuedCommands.map(x => ({ packetId: x.localPacketId, command: x.command })),
	            acks: this.queuedAcks
	        };
	        this.send(message);
	        for (let i = 0; i < this.queuedCommands.length; i++) {
	            let cmd = this.queuedCommands[i];
	            if (cmd.reliability === Reliability.Unreliable || cmd.reliability === Reliability.Relaxed) {
	                this.queuedCommands.splice(i--, 1);
	                if (cmd.reliability === Reliability.Relaxed)
	                    this.awaitingRelaxedAck.push(cmd);
	            }
	        }
	        this.queuedAcks.length = 0;
	    }
	    async send(message) {
	        var _a;
	        let encoded = FixedFormatBinarySerializer.encode(message, gameServerMessageFormat);
	        if (this.addedOneWayLatency)
	            await wait(this.addedOneWayLatency);
	        (_a = this.onOutgoingPacket) === null || _a === void 0 ? void 0 : _a.call(this, encoded.byteLength);
	        if (this.socket.canSend())
	            this.socket.send(encoded);
	    }
	    onMessage(message) {
	        if (message.localPacketId <= this.lastRemotePacketId)
	            return; // Discard out-of-order messages
	        for (let i = 0; i < this.queuedCommands.length; i++) {
	            let cmd = this.queuedCommands[i];
	            if (cmd.reliability === Reliability.Urgent && cmd.localPacketId <= message.lastRemotePacketId)
	                this.queuedCommands.splice(i--, 1);
	        }
	        for (let wrapper of message.commandWrappers) {
	            if (wrapper.packetId <= this.lastRemotePacketId)
	                continue;
	            let arr = this.commandHandlers.get(wrapper.command.command);
	            for (let fn of arr)
	                fn(wrapper.command);
	        }
	        for (let i = 0; i < this.awaitingRelaxedAck.length; i++) {
	            let cmd = this.awaitingRelaxedAck[i];
	            if (message.acks.includes(cmd.localPacketId)) {
	                this.awaitingRelaxedAck.splice(i--, 1);
	            }
	            else if (message.lastRemotePacketId > cmd.localPacketId) {
	                this.awaitingRelaxedAck.splice(i--, 1);
	                this.queuedCommands.push(cmd); // Requeue the thing
	            }
	        }
	        this.lastRemotePacketId = message.localPacketId;
	        if (message.needsAck)
	            this.queuedAcks.push(message.localPacketId);
	    }
	    on(command, callback) {
	        let arr = this.commandHandlers.get(command);
	        arr.push(callback);
	    }
	    disconnect() {
	        this.socket.close();
	    }
	}
	//# sourceMappingURL=game_server_connection.js.map

	class Socket {
	    static init(url, wsConstructor) {
	        this.WebSocketConstructor = wsConstructor;
	        this.url = url;
	        this.establishWebSocketConnection();
	        setInterval(() => {
	            this.send('heartbeat', null); // Keeps the connection alive, especially over Cloudflare
	        }, 30 * 1000);
	    }
	    static establishWebSocketConnection() {
	        this.ws = new this.WebSocketConstructor(this.url);
	        this.plannedReconnect = false;
	        this.ws.onopen = () => {
	            for (let queued of this.sendQueue) {
	                if (this.ws.readyState === this.ws.OPEN) // For some reason this has to be checked again? Stupid I agree
	                    this.ws.send(queued);
	            }
	            this.sendQueue.length = 0;
	            this.ws.onmessage = (ev) => {
	                let { command, data } = JSON.parse(ev.data);
	                let arr = this.commandHandlers[command];
	                if (!arr)
	                    return;
	                for (let fn of arr)
	                    fn(data);
	            };
	        };
	        this.ws.onclose = this.ws.onerror = () => {
	            if (this.plannedReconnect)
	                return; // Don't request it more than once
	            this.plannedReconnect = true;
	            setTimeout(this.establishWebSocketConnection.bind(this), 2000);
	        };
	    }
	    static send(command, data) {
	        let serialized = JSON.stringify({ command, data });
	        if (this.ws.readyState === this.ws.OPEN) {
	            this.ws.send(serialized);
	        }
	        else {
	            this.sendQueue.push(serialized);
	        }
	    }
	    static on(command, callback) {
	        let arr = this.commandHandlers[command];
	        if (!arr) {
	            arr = this.commandHandlers[command] = [];
	        }
	        arr.push(callback);
	    }
	}
	Socket.commandHandlers = {};
	Socket.sendQueue = [];
	Socket.plannedReconnect = false;
	//# sourceMappingURL=socket.js.map

	const peerConnectionConfig = {
	    'iceServers': [
	        { 'urls': 'stun:stun.stunprotocol.org:3478' },
	        { 'urls': 'stun:stun.l.google.com:19302' },
	    ]
	};
	class RTCConnection {
	    constructor(RTCPeerConnectionConstructor) {
	        this.receive = null;
	        this.rtc = new RTCPeerConnectionConstructor(peerConnectionConfig);
	        this.rtc.onicecandidate = (ev) => this.gotIceCandidate(ev.candidate);
	        this.rtc.ondatachannel = (ev) => {
	            let channel = ev.channel;
	            this.initDataChannel(channel);
	        };
	    }
	    async createOffer() {
	        let channel = this.rtc.createDataChannel('main', {
	            ordered: false,
	            maxRetransmits: 0
	        });
	        this.initDataChannel(channel);
	        let offer = await this.rtc.createOffer();
	        this.createdDescription(offer);
	    }
	    async createdDescription(description) {
	        await this.rtc.setLocalDescription(description);
	    }
	    async gotIceFromServer(candidate) {
	        if (!candidate.candidate)
	            return; // "Expect line: candidate:<candidate-str>" bruh firefox moment
	        //if (this.rtc.signalingState === 'closed') return;
	        this.rtc.addIceCandidate(candidate);
	    }
	    async gotSdpFromServer(description) {
	        //if (this.rtc.signalingState === 'closed') return;
	        await this.rtc.setRemoteDescription(description);
	        if (description.type === 'offer') {
	            let answer = await this.rtc.createAnswer();
	            this.createdDescription(answer);
	        }
	    }
	    initDataChannel(channel) {
	        this.dataChannel = channel;
	        this.dataChannel.binaryType = 'arraybuffer';
	        this.dataChannel.onmessage = async (ev) => {
	            var _a;
	            (_a = this.receive) === null || _a === void 0 ? void 0 : _a.call(this, ev.data);
	        };
	        this.dataChannel.onopen = () => {
	            console.log("DC open! 🎉");
	        };
	    }
	    send(data) {
	        if (this.canSend())
	            this.dataChannel.send(data);
	    }
	    canSend() {
	        var _a;
	        return ((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.readyState) === 'open';
	    }
	    getStatus() {
	        // todo is this suffish
	        return this.canSend() ? 'connected' : 'connecting';
	    }
	    close() {
	        this.rtc.close();
	    }
	}
	//# sourceMappingURL=rtc_connection.js.map

	let gameServers$1 = [];
	const TICK_FREQUENCY = 30;
	class GameServerRTCConnection extends RTCConnection {
	    constructor(gameServerId) {
	        super(RTCPeerConnection);
	        this.connectionId = Util$1.uuid();
	        this.gameServerId = gameServerId;
	    }
	    gotIceCandidate(candidate) {
	        if (!candidate)
	            return;
	        Socket.send('rtcIce', {
	            ice: candidate,
	            gameServerId: this.gameServerId,
	            connectionId: this.connectionId
	        });
	    }
	    async createdDescription(description) {
	        await super.createdDescription(description);
	        Socket.send('rtcSdp', {
	            sdp: this.rtc.localDescription,
	            gameServerId: this.gameServerId,
	            connectionId: this.connectionId
	        });
	    }
	}
	class WebSocketGameServerSocket {
	    constructor(ws) {
	        this.ws = ws;
	        ws.binaryType = 'arraybuffer';
	        ws.onmessage = (ev) => {
	            this.receive(ev.data);
	        };
	        ws.onopen = () => {
	            console.log("opened");
	        };
	    }
	    send(data) {
	        if (this.canSend())
	            this.ws.send(data);
	    }
	    canSend() {
	        return this.ws.readyState === this.ws.OPEN;
	    }
	    getStatus() {
	        if (this.ws.readyState === 1)
	            return 'connected';
	        return 'connecting';
	    }
	    close() {
	        this.ws.close();
	    }
	}
	class GameServer {
	    constructor(id, wsUrl) {
	        this.connection = null;
	        this.id = id;
	        this.wsUrl = wsUrl;
	    }
	    static init() {
	        Socket.on('updateGameServerList', list => {
	            var _a, _b;
	            for (let gs of list) {
	                let exists = gameServers$1.some(x => x.id === gs.id);
	                if (exists)
	                    continue;
	                let gameServer = new GameServer(gs.id, gs.wsUrl);
	                gameServers$1.push(gameServer);
	            }
	            (_b = (_a = G$1.menu) === null || _a === void 0 ? void 0 : _a.lobbyScreen) === null || _b === void 0 ? void 0 : _b.updateGameServerList();
	        });
	        Socket.on('rtcIce', data => {
	            var _a;
	            (_a = gameServers$1.find(x => x.id === data.gameServerId)) === null || _a === void 0 ? void 0 : _a.rtcSocket.gotIceFromServer(new RTCIceCandidate(data.ice));
	        });
	        Socket.on('rtcSdp', data => {
	            var _a;
	            (_a = gameServers$1.find(x => x.id === data.gameServerId)) === null || _a === void 0 ? void 0 : _a.rtcSocket.gotSdpFromServer(new RTCSessionDescription(data.sdp));
	        });
	        workerSetInterval(() => {
	            var _a;
	            for (let gs of gameServers$1)
	                (_a = gs.connection) === null || _a === void 0 ? void 0 : _a.tick();
	        }, 1000 / TICK_FREQUENCY);
	    }
	    connect(type) {
	        if (type === 'rtc') {
	            this.rtcSocket = new GameServerRTCConnection(this.id);
	            this.rtcSocket.createOffer();
	            this.connection = new GameServerConnection(this.rtcSocket);
	        }
	        else {
	            let ws = new WebSocket(this.wsUrl);
	            let socket = new WebSocketGameServerSocket(ws);
	            this.connection = new GameServerConnection(socket);
	        }
	        this.connection.on('pong', ({ timestamp, subtract }) => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            let now = performance.now();
	            let rtt = now - timestamp - subtract;
	            game.recentRtts.push({
	                value: rtt,
	                timestamp: now
	            });
	        });
	        this.connection.on('gameJoinInfo', data => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            game.onGameJoinInfo(data);
	        });
	        this.connection.on('serverStateBundle', data => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            game.onServerStateBundle(data);
	        });
	        this.connection.on('timeState', data => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            game.state.supplyServerTimeState(data.serverFrame, data.targetFrame);
	        });
	        this.connection.on('playerJoin', data => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            game.addPlayer(data);
	        });
	        this.connection.on('scheduleRestart', data => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            Util$1.insertSorted(game.state.restartFrames, data.frame, (a, b) => a - b);
	        });
	        this.connection.on('playerRestartIntentState', data => {
	            let game = G$1.game;
	            if (!game)
	                return;
	            game.players.find(x => x.id === data.playerId).hasRestartIntent = data.state;
	        });
	        this.connection.on('textMessage', data => {
	            var _a, _b;
	            let game = G$1.game;
	            if (!game)
	                return;
	            let sessionId = (_a = game.players.find(x => x.id === data.playerId)) === null || _a === void 0 ? void 0 : _a.sessionId;
	            let username = (_b = G$1.lobby.sockets.find(x => x.id === sessionId)) === null || _b === void 0 ? void 0 : _b.name;
	            G$1.menu.hud.displayChatMessage(username !== null && username !== void 0 ? username : '???', data.body);
	        });
	    }
	    disconnect() {
	        if (!this.connection)
	            return;
	        this.connection.disconnect();
	        this.connection = null;
	        console.log("Guubai 🚪");
	    }
	}
	//# sourceMappingURL=game_server.js.map

	class Connectivity {
	    static async init() {
	        this.sessionId = Util$1.uuid();
	        GameServer.init();
	        let url = location.origin.replace('http', 'ws') + '/ws';
	        url += `?session-id=${encodeURIComponent(this.sessionId)}`;
	        Socket.init(url, WebSocket);
	    }
	}
	//# sourceMappingURL=connectivity.js.map

	const hudCanvas = document.querySelector('#hud-canvas');
	let hudCtx;
	const initHudCtx = () => {
	    hudCtx = hudCanvas.getContext('2d', {
	        desynchronized: StorageManager$1.data.settings.canvasDesynchronized
	    });
	};
	const numberSources = {
	    "0": "0.png",
	    "1": "1.png",
	    "2": "2.png",
	    "3": "3.png",
	    "4": "4.png",
	    "5": "5.png",
	    "6": "6.png",
	    "7": "7.png",
	    "8": "8.png",
	    "9": "9.png",
	    ":": "colon.png",
	    ".": "point.png",
	    "/": "slash.png",
	    "-": "dash.png"
	};
	const keybindRegex = /<func:bind (\w+)>/g;
	class Hud {
	    constructor(menu) {
	        this.frameTimeStore = [];
	        this.lastBlastMeterBodySrc = null;
	        this.lastBlastMeterFillSrc = null;
	        this.lastGemCount = null;
	        this.scoreboardRows = [];
	        this.chatMessageStartTimes = new WeakMap();
	        this.helpMessages = [];
	        this.alerts = [];
	        this.menu = menu;
	        this.gemCountElement = document.querySelector('#gem-count');
	        this.clockCanvas = document.querySelector('#clock');
	        this.clockCtx = this.clockCanvas.getContext('2d');
	        this.helpElement = document.querySelector('#help-text');
	        this.alertElement = document.querySelector('#alert-text');
	        this.announcementElement = document.querySelector('#announcement-text');
	        this.centerElement = document.querySelector('#center-text');
	        this.powerUpBorder = document.querySelector('#powerup-border');
	        this.clockBackground = document.querySelector('#clock-background');
	        this.fpsMeter = document.querySelector('#fps-meter');
	        this.fpsMeterValue = document.querySelector('#fps-meter-value');
	        this.blastMeter = document.querySelector('#blast-meter');
	        this.blastMeterBody = document.querySelector('#blast-meter-body');
	        this.blastMeterFill = document.querySelector('#blast-meter-fill');
	        this.scoreboard = document.querySelector('#scoreboard');
	        this.chatContainer = document.querySelector('#hud-chat');
	        this.chatInput = document.querySelector('#hud-chat input');
	        this.chatMessageContainer = document.querySelector('#hud-chat > div');
	        this.networkStats = document.querySelector('#network-stats');
	        this.initGameChat();
	    }
	    initGameChat() {
	        this.chatInput.parentElement.addEventListener('submit', e => {
	            e.preventDefault();
	            let body = this.chatInput.value.trim();
	            if (body) {
	                this.displayChatMessage(StorageManager$1.data.username, body);
	                G$1.game.connection.queueCommand({
	                    command: 'sendTextMessage',
	                    body: body
	                }, Reliability.Relaxed);
	            }
	            this.closeChat();
	        });
	        window.addEventListener('keydown', e => {
	            if (this.menu.gameUiDiv.classList.contains('hidden'))
	                return;
	            if (document.activeElement !== this.chatInput && e.code === 'Enter') {
	                e.stopPropagation();
	                e.preventDefault();
	                this.chatContainer.style.pointerEvents = 'auto';
	                this.chatInput.style.visibility = 'visible';
	                this.chatInput.style.pointerEvents = 'all';
	                this.chatMessageContainer.style.overflowY = 'auto';
	                this.chatMessageContainer.classList.add('highlighted');
	                this.chatInput.focus();
	            }
	            if (document.activeElement === this.chatInput && e.code === 'Escape') {
	                this.closeChat();
	            }
	        });
	    }
	    closeChat() {
	        this.chatContainer.style.pointerEvents = '';
	        this.chatInput.value = '';
	        this.chatInput.blur();
	        this.chatInput.style.visibility = '';
	        this.chatInput.style.pointerEvents = '';
	        this.chatMessageContainer.style.overflowY = '';
	        this.chatMessageContainer.scrollTop = 1e6;
	        this.chatMessageContainer.classList.remove('highlighted');
	        let now = performance.now();
	        for (let child of this.chatMessageContainer.children) {
	            child.style.animationDelay = -(now - this.chatMessageStartTimes.get(child)) + 'ms';
	        }
	    }
	    async load() {
	        await ResourceManager$1.loadImages(Object.values(numberSources).map(x => {
	            let files = [x];
	            if (this.supportNumberColors && !x.includes('slash') && !x.includes('dash')) {
	                // Also load the colored variants
	                files.push(x.slice(0, x.lastIndexOf('.')) + '_red.png');
	                files.push(x.slice(0, x.lastIndexOf('.')) + '_green.png');
	            }
	            return files.map(y => this.menu.uiAssetPath + "game/numbers/" + y);
	        }).flat());
	        await ResourceManager$1.loadImages(["ready.png", "set.png", "go.png", "outofbounds.png", "powerup.png"].map(x => this.menu.uiAssetPath + "game/" + x));
	        this.powerUpBorder.src = this.menu.uiAssetPath + 'game/powerup.png';
	        if (this.showClockBackground)
	            this.clockBackground.classList.remove('hidden');
	        else
	            this.clockBackground.classList.add('hidden');
	        this.menu.gameUiDiv.classList.remove('gold', 'platinum');
	        this.menu.gameUiDiv.classList.add(G$1.modification);
	        if (StorageManager$1.data.settings.showFrameRate && this.supportFpsMeter) {
	            this.fpsMeter.classList.remove('hidden');
	        }
	        else {
	            this.fpsMeter.classList.add('hidden');
	        }
	        this.setBlastMeterVisibility(G$1.game.mission.hasBlast);
	        if (G$1.game.mission.hasBlast) {
	            await ResourceManager$1.loadImages(["blastbar.png", "blastbar_charged.png", "blastbar_bargreen.png", "blastbar_bargray.png"].map(x => "./assets/ui_mbp/game/" + x));
	        }
	        if (G$1.game.type === 'singleplayer')
	            this.scoreboard.style.display = 'none';
	        else
	            this.scoreboard.style.display = '';
	        this.scoreboardRows.length = 0;
	        this.scoreboard.innerHTML = '';
	        this.chatContainer.style.display = G$1.game.type === 'singleplayer' ? 'none' : '';
	        this.chatMessageContainer.innerHTML = '';
	        this.helpMessages.length = 0;
	        this.alerts.length = 0;
	        hudCanvas.style.display = G$1.game.type === 'singleplayer' ? 'none' : '';
	        if (Util$1.isTouchDevice)
	            this.setupTouchControls();
	        this.lastGemCount = null;
	    }
	    setupTouchControls() {
	        // Change the offset based on whether or not there's a gem counter
	        pauseButton.style.top = G$1.game.totalGems ? '60px' : '';
	        restartButton.style.top = G$1.game.totalGems ? '60px' : '';
	        freeLookButton.style.top = G$1.game.totalGems ? '60px' : '';
	        // Kinda hacky here, don't wanna clean up: (Yes there's a good reason we don't set display)
	        blastButton.style.visibility = G$1.game.mission.hasBlast ? '' : 'hidden';
	        blastButton.style.pointerEvents = G$1.game.mission.hasBlast ? '' : 'none';
	        freeLookButton.style.visibility = StorageManager$1.data.settings.alwaysFreeLook ? 'hidden' : '';
	        freeLookButton.style.pointerEvents = StorageManager$1.data.settings.alwaysFreeLook ? 'none' : '';
	        this.fpsMeter.style.transform = 'scale(0.5)';
	        this.fpsMeter.querySelector('img').style.borderRight = '50px solid #ffffff4d'; // To make it visible with rounded corners
	        this.fpsMeterValue.style.marginRight = '50px';
	        this.blastMeter.style.left = '20px'; // Same thing here
	        this.blastMeter.style.bottom = '47px'; // Same thing here
	        // Adjust layout based on user settings:
	        let joystickSize = StorageManager$1.data.settings.joystickSize;
	        let joystickHandleSize = JOYSTICK_HANDLE_SIZE_FACTOR * joystickSize;
	        movementJoystick.style.width = joystickSize + 'px';
	        movementJoystick.style.height = joystickSize + 'px';
	        movementJoystick.style.borderRadius = joystickHandleSize / 2 + 'px';
	        movementJoystickHandle.style.width = joystickHandleSize + 'px';
	        movementJoystickHandle.style.height = joystickHandleSize + 'px';
	        let scale = StorageManager$1.data.settings.actionButtonSize / 120;
	        actionButtonContainer.style.right = StorageManager$1.data.settings.actionButtonRightOffset / scale + 'px';
	        actionButtonContainer.style.bottom = StorageManager$1.data.settings.actionButtonBottomOffset / scale + 'px';
	        actionButtonContainer.style.transform = `scale(${scale})`;
	        // Reorder the action buttons as needed
	        let offsets = [{ right: 0, bottom: 135 }, { right: 0, bottom: 0 }, { right: 135, bottom: 0 }];
	        let arr = Util$1.getPermutations([blastButton, jumpButton, useButton])[StorageManager$1.data.settings.actionButtonOrder];
	        for (let button of arr) {
	            button.style.right = offsets[arr.indexOf(button)].right + 'px';
	            button.style.bottom = offsets[arr.indexOf(button)].bottom + 'px';
	        }
	    }
	    /** Updates the game clock canvas. */
	    displayTime(seconds, specialColor) {
	        if (!this.supportNumberColors)
	            specialColor = undefined;
	        let string = Util$1.secondsToTimeString(seconds);
	        const defaultWidth = 43;
	        const defaultMarginRight = -19;
	        let totalWidth = (string.length - 1) * (defaultWidth + defaultMarginRight) - (2 * (defaultWidth + defaultMarginRight - 10)) + defaultWidth;
	        let baseOffset = Math.floor((this.clockCanvas.width - totalWidth) / 2);
	        let currentX = 0;
	        this.clockCtx.clearRect(0, 0, this.clockCanvas.width, this.clockCanvas.height);
	        // Draw every symbol
	        for (let i = 0; i < string.length; i++) {
	            let char = string[i];
	            let path = this.menu.uiAssetPath + "game/numbers/" + numberSources[char];
	            if (this.supportNumberColors && specialColor)
	                path = path.slice(0, path.lastIndexOf('.')) + '_' + specialColor + '.png';
	            let image = ResourceManager$1.getImageFromCache(path);
	            if (char === ':' || char === '.')
	                currentX -= 3;
	            this.clockCtx.drawImage(image, baseOffset + currentX, 0);
	            currentX += defaultWidth + defaultMarginRight;
	            if (char === ':' || char === '.')
	                currentX -= 7;
	        }
	    }
	    /** Makes the powerup button visible/invisible depending on state and forceUpdate, see code. */
	    setPowerupButtonState(enabled, forceUpdate = false) {
	        if (Util$1.isTouchDevice) {
	            setUseEnabled(enabled);
	            if (enabled || forceUpdate)
	                useButton.style.opacity = '0.5';
	            if (!enabled && forceUpdate)
	                useButton.style.opacity = '0.2';
	        }
	    }
	    /** Updates the gem count display. */
	    displayGemCount(count, total) {
	        if (total === 0)
	            return;
	        let hash = `${count}/${total}`;
	        if (this.lastGemCount === hash)
	            return;
	        this.lastGemCount = hash;
	        let string = Util$1.leftPadZeroes(count.toString(), this.gemCountMinDigits) + '/' + Util$1.leftPadZeroes(total.toString(), this.gemCountMinDigits);
	        // Generate the appropriate number of image elements
	        while (string.length > this.gemCountElement.children.length) {
	            let newChild = document.createElement('img');
	            this.gemCountElement.appendChild(newChild);
	        }
	        while (string.length < this.gemCountElement.children.length) {
	            this.gemCountElement.removeChild(this.gemCountElement.lastChild);
	        }
	        for (let i = 0; i < string.length; i++) {
	            let char = string[i];
	            let node = this.gemCountElement.children[i];
	            node.src = this.menu.uiAssetPath + "game/numbers/" + numberSources[char];
	        }
	    }
	    setGemVisibility(state) {
	        this.gemCountElement.style.display = state ? '' : 'none';
	    }
	    /** Displays a help message in the middle of the screen. */
	    displayHelp(getMessage, frame, playSound = true) {
	        let index = Util$1.insertSorted(this.helpMessages, { frame, getMessage }, (a, b) => a.frame - b.frame);
	        while (this.helpMessages[index - 1] && this.helpMessages[index - 1].frame === frame) {
	            this.helpMessages.splice(index - 1, 1);
	            index--;
	        }
	        let game = G$1.game;
	        if (playSound && getMessage() !== null)
	            game.simulator.executeNonDuplicatableEvent(() => {
	                AudioManager$1.play('infotutorial.wav');
	            }, `displayHelp`, true);
	    }
	    /** Displays an alert at the bottom of the screen. */
	    displayAlert(getMessage, frame) {
	        let index = Util$1.insertSorted(this.alerts, { frame, getMessage }, (a, b) => a.frame - b.frame);
	        while (this.alerts[index - 1] && this.alerts[index - 1].frame === frame) {
	            this.alerts.splice(index - 1, 1);
	            index--;
	        }
	    }
	    setCenterText(type) {
	        if (type === 'none')
	            this.centerElement.style.display = 'none';
	        else
	            this.centerElement.style.display = '';
	        if (type === 'ready')
	            this.centerElement.src = this.menu.uiAssetPath + 'game/ready.png';
	        if (type === 'set')
	            this.centerElement.src = this.menu.uiAssetPath + 'game/set.png';
	        if (type === 'go')
	            this.centerElement.src = this.menu.uiAssetPath + 'game/go.png';
	        if (type === 'outofbounds')
	            this.centerElement.src = this.menu.uiAssetPath + 'game/outofbounds.png';
	    }
	    displayFps() {
	        if (!(StorageManager$1.data.settings.showFrameRate && this.supportFpsMeter))
	            return;
	        let now = performance.now();
	        this.frameTimeStore.push(now);
	        // Remove all frame times that were over a second ago
	        while (this.frameTimeStore.length && this.frameTimeStore[0] + 1000 <= now)
	            this.frameTimeStore.shift();
	        let value = this.frameTimeStore.length;
	        //value /= Math.min(1, state.game level.timeState.timeSinceLoad / 1000 ?? 1); // Hack to make it reach the final frame rate faster
	        value = Math.floor(value);
	        let settingsTarget = FRAME_RATE_OPTIONS$1[StorageManager$1.data.settings.frameRateCap];
	        if (value === 59 || value === 119 || value === 143 || value === 239 || value === settingsTarget - 1)
	            value++; // Snap to the most common frame rates
	        if (value === 61 || value === 121 || value === 145 || value === 241 || value === settingsTarget + 1)
	            value--;
	        this.fpsMeterValue.textContent = 'FPS: ' + value;
	    }
	    setBlastMeterVisibility(state) {
	        if (state)
	            this.blastMeter.classList.remove('hidden');
	        else
	            this.blastMeter.classList.add('hidden');
	    }
	    displayBlastMeterFullness(amount) {
	        // The src inequality checks are here for performance reasons
	        let blastMeterBodySrc;
	        if (amount > 1)
	            blastMeterBodySrc = './assets/ui_mbp/game/blastbar_charged.png';
	        else
	            blastMeterBodySrc = './assets/ui_mbp/game/blastbar.png';
	        if (blastMeterBodySrc !== this.lastBlastMeterBodySrc) {
	            this.blastMeterBody.src = blastMeterBodySrc;
	            this.lastBlastMeterBodySrc = blastMeterBodySrc;
	        }
	        if (amount >= 0.2) {
	            if (!blastEnabled)
	                blastButton.style.opacity = '0.5';
	            setBlastEnabled(true);
	        }
	        else {
	            if (blastEnabled)
	                blastButton.style.opacity = '0.2';
	            setBlastEnabled(false);
	        }
	        let blastMeterFillSrc;
	        this.blastMeterFill.style.width = Util$1.clamp(amount, 0, 1) * 109 + 'px';
	        blastMeterFillSrc = `./assets/ui_mbp/game/blastbar_bar${(amount >= 0.2) ? 'green' : 'gray'}.png`;
	        if (blastMeterFillSrc !== this.lastBlastMeterFillSrc) {
	            this.blastMeterFill.src = blastMeterFillSrc;
	            this.lastBlastMeterFillSrc = blastMeterFillSrc;
	        }
	    }
	    displayScoreboard() {
	        let updatedRows = new WeakSet();
	        for (let socket of G$1.lobby.sockets) {
	            let row = this.scoreboardRows.find(x => x.sessionId === socket.id);
	            if (!row) {
	                row = new ScoreboardRow(socket.id);
	                row.add();
	                this.scoreboardRows.push(row);
	            }
	            row.update();
	            updatedRows.add(row);
	        }
	        for (let i = 0; i < this.scoreboardRows.length; i++) {
	            let row = this.scoreboardRows[i];
	            if (!updatedRows.has(row)) {
	                row.remove();
	                this.scoreboardRows.splice(i--, 1);
	            }
	        }
	    }
	    displayChatMessage(username, body) {
	        let div = document.createElement('div');
	        div.innerHTML = `<b>${Util$1.htmlEscape(username)}: </b>${Util$1.htmlEscape(body)}`;
	        this.chatMessageStartTimes.set(div, performance.now());
	        this.chatMessageContainer.insertBefore(div, this.chatMessageContainer.firstChild);
	    }
	    static processHelpMessage(message) {
	        keybindRegex.lastIndex = 0;
	        let match;
	        // Search the string for possible keybind references. If found, replace them with the key bound to that keybind.
	        while ((match = keybindRegex.exec(message)) !== null) {
	            let gameButton = {
	                "moveforward": "up",
	                "movebackward": "down",
	                "moveleft": "left",
	                "moveright": "right",
	                "jump": "jump",
	                "mousefire": "use",
	                "panup": "cameraUp",
	                "pandown": "cameraDown",
	                "panleft": "cameraLeft",
	                "panright": "cameraRight",
	                "turnup": "cameraUp",
	                "turndown": "cameraDown",
	                "turnleft": "cameraLeft",
	                "turnright": "cameraRight",
	                "freelook": "freeLook",
	                "useblast": "blast"
	            }[match[1].toLowerCase()];
	            if (!gameButton)
	                continue;
	            let keyName = Util$1.getKeyForButtonCode(StorageManager$1.data.settings.gameButtonMapping[gameButton]);
	            message = message.slice(0, match.index) + keyName + message.slice(match.index + match[0].length);
	            keybindRegex.lastIndex -= match[0].length;
	        }
	        // A few hardcoded messages from Marble Blast Mobile
	        if (message === 'MSG_FINDALLTHEGEMS')
	            message = "Find all the gems!";
	        if (message === 'MSG_RACETOTHEFINISH')
	            message = "Race to the finish!";
	        return message;
	    }
	}
	class ScoreboardRow {
	    constructor(sessionId) {
	        this.sessionId = sessionId;
	        this.div = document.createElement('div');
	        this.lhs = document.createElement('span');
	        this.rhs = document.createElement('span');
	        this.restartIntentIcon = document.createElement('img');
	        this.restartIntentIcon.src = "./assets/img/return.png";
	        this.restartIntentIcon.style.display = 'none';
	        this.div.append(this.lhs, this.rhs, this.restartIntentIcon);
	    }
	    update() {
	        let socket = G$1.lobby.sockets.find(x => x.id === this.sessionId);
	        let rhsText;
	        if (G$1.game.state.lastRestartFrame === -Infinity) {
	            if (socket.loadingCompletion < 1) {
	                rhsText = Math.floor(socket.loadingCompletion * 100) + '%';
	            }
	            else {
	                rhsText = '100% ✔';
	            }
	        }
	        else {
	            rhsText = 'Playing';
	        }
	        // todo: Figure out a way to highlight the local player without it looking ass
	        {
	            this.lhs.innerHTML = Util$1.htmlEscape(socket.name);
	        }
	        this.rhs.textContent = rhsText;
	        let hasRestartIntent = G$1.game.players.some(x => x.sessionId === socket.id && x.hasRestartIntent);
	        this.restartIntentIcon.style.display = hasRestartIntent ? '' : 'none';
	    }
	    add() {
	        G$1.menu.hud.scoreboard.appendChild(this.div);
	    }
	    remove() {
	        G$1.menu.hud.scoreboard.removeChild(this.div);
	    }
	}
	//# sourceMappingURL=hud.js.map

	const mainCanvas$1 = document.querySelector('#main-canvas');
	let mainRenderer$1;
	const initMainRenderer = () => {
	    mainRenderer$1 = new Renderer({
	        canvas: mainCanvas$1,
	        desynchronized: StorageManager$1.data.settings.canvasDesynchronized
	    });
	    resize$1(false);
	};
	const MIN_WIDTH = 640;
	const MIN_HEIGHT = 600;
	/** Ratio by which the entire body gets scaled by, while still fitting into the screen. */
	let SCALING_RATIO$1 = 1;
	const resize$1 = async (wait = true) => {
	    var _a, _b;
	    if (wait)
	        await Util$1.wait(100); // Sometimes you gotta give browser UI elements a little time to update
	    let ratio = Math.max(1, MIN_WIDTH / window.innerWidth, MIN_HEIGHT / window.innerHeight);
	    document.body.style.width = Math.ceil(window.innerWidth * ratio) + 'px';
	    document.body.style.height = Math.ceil(window.innerHeight * ratio) + 'px';
	    document.body.style.transform = `scale(${1 / ratio})`;
	    SCALING_RATIO$1 = ratio;
	    mainCanvas$1.style.width = '100%';
	    mainCanvas$1.style.height = '100%';
	    mainRenderer$1 === null || mainRenderer$1 === void 0 ? void 0 : mainRenderer$1.setSize(window.innerWidth, window.innerHeight);
	    mainRenderer$1 === null || mainRenderer$1 === void 0 ? void 0 : mainRenderer$1.setPixelRatio(Math.min(window.devicePixelRatio, [0.5, 1.0, 1.5, 2.0, Infinity][(_a = StorageManager$1.data) === null || _a === void 0 ? void 0 : _a.settings.pixelRatio]));
	    (_b = G$1.game) === null || _b === void 0 ? void 0 : _b.renderer.onResize();
	    // todo pixelratio
	    hudCanvas.setAttribute('width', window.innerWidth.toString());
	    hudCanvas.setAttribute('height', window.innerHeight.toString());
	};
	window.addEventListener('resize', resize$1);
	resize$1();
	/** Becomes true when the user has closed the fullscreen enforcer. */
	let dislikesFullscreen = false;
	const fullscreenEnforcer = document.querySelector('#fullscreen-enforcer');
	fullscreenEnforcer.addEventListener('click', () => {
	    document.documentElement.requestFullscreen();
	});
	fullscreenEnforcer.querySelector('img').addEventListener('click', (e) => {
	    dislikesFullscreen = true;
	    fullscreenEnforcer.classList.add('hidden');
	    e.stopPropagation();
	});
	const enterFullscreenButton = document.querySelector('#enter-fullscreen');
	enterFullscreenButton.addEventListener('click', () => {
	    document.documentElement.requestFullscreen();
	    dislikesFullscreen = false; // They changed their mind, yay
	});
	let fullscreenButtonVisibility = true;
	const setEnterFullscreenButtonVisibility = (state) => {
	    fullscreenButtonVisibility = state;
	    if (state && Util$1.isTouchDevice && !Util$1.isSafari() && !Util$1.isInFullscreen())
	        enterFullscreenButton.classList.remove('hidden');
	    else
	        enterFullscreenButton.classList.add('hidden');
	};
	// Periodically, check if the mobile user has left fullscreen and if so, remind them to re-enter it.
	let lastImmunityTime = -Infinity;
	setInterval(() => {
	    var _a, _b;
	    if (((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.tagName) === 'INPUT')
	        lastImmunityTime = performance.now();
	    if (Util$1.isTouchDevice && !Util$1.isSafari()) {
	        if (Util$1.isInFullscreen()) {
	            // They're in fullscreen, hide the overlay
	            fullscreenEnforcer.classList.add('hidden');
	        }
	        else if (!dislikesFullscreen && ((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.tagName) !== 'INPUT' && performance.now() - lastImmunityTime > 666) {
	            // They're not in fullscreen, show the overlay
	            fullscreenEnforcer.classList.remove('hidden');
	        }
	    }
	    setEnterFullscreenButtonVisibility(fullscreenButtonVisibility);
	}, 250);
	// Disable image dragging in Firefox
	window.addEventListener('dragstart', (e) => {
	    var _a;
	    if (((_a = e.target.nodeName) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === 'IMG') {
	        e.preventDefault();
	    }
	});
	// Assist with deselecting text because most things are user-select: none so they don't allow you to deselect selected text anymo'
	window.addEventListener('pointerdown', () => {
	    document.getSelection().empty();
	});
	//# sourceMappingURL=misc.js.map

	const currentMousePosition = {
	    x: 0,
	    y: 0
	};
	window.addEventListener('mousemove', (e) => {
	    var _a;
	    currentMousePosition.x = e.clientX * SCALING_RATIO$1;
	    currentMousePosition.y = e.clientY * SCALING_RATIO$1;
	    (_a = G$1.game) === null || _a === void 0 ? void 0 : _a.onMouseMove(e);
	});
	window.addEventListener('touchstart', (e) => {
	    let touch = e.changedTouches[0];
	    currentMousePosition.x = touch.clientX * SCALING_RATIO$1;
	    currentMousePosition.y = touch.clientY * SCALING_RATIO$1;
	});
	window.addEventListener('touchmove', (e) => {
	    let touch = e.changedTouches[0];
	    currentMousePosition.x = touch.clientX * SCALING_RATIO$1;
	    currentMousePosition.y = touch.clientY * SCALING_RATIO$1;
	});
	window.addEventListener('mousedown', (e) => {
	    if (!StorageManager$1.data)
	        return;
	    // Request pointer lock if we're currently in-game
	    if (G$1.game && !G$1.game.paused && !G$1.menu.finishScreen.scheduled && !Util$1.isTouchDevice)
	        Util$1.requestPointerLock();
	    let buttonName = ["LMB", "MMB", "RMB"][e.button];
	    if (buttonName && document.pointerLockElement) {
	        // Check if the mouse button is mapped to something
	        for (let button in StorageManager$1.data.settings.gameButtonMapping) {
	            let key = button;
	            if (buttonName !== StorageManager$1.data.settings.gameButtonMapping[key])
	                continue;
	            setPressed(key, buttonName, true);
	        }
	    }
	});
	window.addEventListener('mouseup', (e) => {
	    if (!StorageManager$1.data)
	        return;
	    let buttonName = ["LMB", "MMB", "RMB"][e.button];
	    if (buttonName) {
	        for (let button in StorageManager$1.data.settings.gameButtonMapping) {
	            let key = button;
	            if (buttonName !== StorageManager$1.data.settings.gameButtonMapping[key])
	                continue;
	            setPressed(key, buttonName, false);
	        }
	    }
	});
	window.addEventListener('keydown', (e) => {
	    if (!StorageManager$1.data)
	        return;
	    // Check if the key button is mapped to something
	    for (let button in StorageManager$1.data.settings.gameButtonMapping) {
	        let key = button;
	        if (e.code !== StorageManager$1.data.settings.gameButtonMapping[key])
	            continue;
	        setPressed(key, e.code, true);
	    }
	});
	window.addEventListener('keyup', (e) => {
	    if (!StorageManager$1.data)
	        return;
	    for (let button in StorageManager$1.data.settings.gameButtonMapping) {
	        let key = button;
	        if (e.code !== StorageManager$1.data.settings.gameButtonMapping[key])
	            continue;
	        setPressed(key, e.code, false);
	    }
	});
	window.addEventListener('contextmenu', (e) => e.preventDefault()); // Disable right click context menu for good
	window.addEventListener('beforeunload', (e) => {
	    return; // fixme
	});
	document.addEventListener('pointerlockchange', () => {
	    var _a;
	    // When pointer lock is left, we pause.
	    if (!document.pointerLockElement)
	        (_a = G$1.game) === null || _a === void 0 ? void 0 : _a.pause();
	});
	/** For each game button, a list of the keys/buttons corresponding to it that are currently pressed. */
	const gameButtons = {
	    up: [],
	    down: [],
	    left: [],
	    right: [],
	    jump: [],
	    use: [],
	    cameraUp: [],
	    cameraDown: [],
	    cameraLeft: [],
	    cameraRight: [],
	    freeLook: [],
	    restart: [],
	    pause: [],
	    blast: []
	};
	/** For each game button, a flag indicating whether it has been pressed since the flag was reset. Used to prevent things like entering and immediately leaving the pause menu. */
	const pressedSinceFlag = {
	    up: false,
	    down: false,
	    left: false,
	    right: false,
	    jump: false,
	    use: false,
	    cameraUp: false,
	    cameraDown: false,
	    cameraLeft: false,
	    cameraRight: false,
	    freeLook: false,
	    restart: false,
	    pause: false,
	    blast: false
	};
	/** Set a button's state based on a presser. */
	const setPressed = (buttonName, presser, buttonState) => {
	    var _a;
	    let incl = gameButtons[buttonName].includes(presser);
	    if (!buttonState && incl) {
	        gameButtons[buttonName] = gameButtons[buttonName].filter(x => x !== presser);
	    }
	    else if (buttonState && !incl) {
	        gameButtons[buttonName].push(presser);
	        pressedSinceFlag[buttonName] = true;
	    }
	    (_a = G$1.game) === null || _a === void 0 ? void 0 : _a.onButtonChange();
	};
	/** Determine if a button is pressed. */
	const isPressed$1 = (buttonName) => {
	    return (gameButtons[buttonName].length > 0);
	};
	/** Determine if a button is pressed by a gamepad. */
	const isPressedByGamepad = (buttonName) => {
	    return gameButtons[buttonName].find(x => x.startsWith('gamepadButton')) !== undefined;
	};
	/** Return whether a presser has pressed the button since the flag was reset. */
	const getPressedFlag$1 = (buttonName) => {
	    return pressedSinceFlag[buttonName];
	};
	/** Reset the pressed flag for a button. */
	const resetPressedFlag$1 = (buttonName) => {
	    pressedSinceFlag[buttonName] = false;
	};
	const releaseAllButtons$1 = () => {
	    for (let key in gameButtons) {
	        if (key !== 'pause')
	            gameButtons[key] = [];
	    }
	};
	/** The current position (-1 to 1) of the marble and camera axes. */
	const gamepadAxes$1 = {
	    marbleX: 0.0,
	    marbleY: 0.0,
	    cameraX: 0.0,
	    cameraY: 0.0
	};
	/** TODO: Make this configurable */
	const gamepadAxisMappings = ['marbleX', 'marbleY', 'cameraX', 'cameraY'];
	const gamepadButtonMappings = ['jump', 'use', 'blast', '', '', 'blast', 'jump', 'use', 'restart', 'pause', '', '', 'up', 'down', 'left', 'right', '', ''];
	/** The most recent controller a button was pressed on, used to select the controller to poll */
	let mostRecentGamepad = 0;
	/** Referring to the button state of the controller. */
	const previousButtonState = [false, false, false, false, false, false, false, false, false, false, false, false, false, false];
	/** Update the input from the gamepad, if it is connected. */
	const updateGamepadInput = () => {
	    var _a, _b;
	    let gamepads = navigator.getGamepads ? [...navigator.getGamepads()].filter(x => x) : [];
	    if (gamepads.length === 0) {
	        // No gamepad active
	        for (let key in gamepadAxes$1)
	            gamepadAxes$1[key] = 0.0;
	        return;
	    }
	    // Update the most recent gamepad
	    for (let i = 0; i < gamepads.length; i++) {
	        for (let j = 0; j < gamepads[i].buttons.length; j++) {
	            if (gamepads[i].buttons[j].value > 0.5) {
	                mostRecentGamepad = i;
	                break;
	            }
	        }
	    }
	    for (let i = 0; i < gamepads[mostRecentGamepad].buttons.length && i < 18; i++) {
	        let state = (gamepads[mostRecentGamepad].buttons[i].value > 0.5);
	        let presser = 'gamepadButton' + i;
	        let buttonName = gamepadButtonMappings[i];
	        if (buttonName !== '')
	            setPressed(buttonName, presser, state);
	    }
	    for (let i = 0; i < gamepads[mostRecentGamepad].axes.length && i < 4; i++) {
	        let axisName = gamepadAxisMappings[i];
	        if (axisName !== '') {
	            gamepadAxes$1[axisName] = gamepads[mostRecentGamepad].axes[i];
	            // Dead zone
	            if (Math.abs(gamepadAxes$1[axisName]) < 0.1)
	                gamepadAxes$1[axisName] = 0;
	        }
	    }
	    // Check for input on the level select screen
	    if (((_a = G$1.menu) === null || _a === void 0 ? void 0 : _a.levelSelect) && !G$1.menu.levelSelect.div.classList.contains('hidden'))
	        G$1.menu.levelSelect.handleControllerInput(gamepads[mostRecentGamepad]);
	    if ((_b = G$1.level) === null || _b === void 0 ? void 0 : _b.paused)
	        G$1.menu.pauseScreen.handleGamepadInput(gamepads[mostRecentGamepad]);
	    for (let i = 0; i < gamepads[mostRecentGamepad].buttons.length && i < 18; i++) {
	        previousButtonState[i] = (gamepads[mostRecentGamepad].buttons[i].value > 0.5);
	    }
	};
	window.setInterval(updateGamepadInput, 4);
	/* TOUCH STUFF: */
	const touchInputContainer = document.querySelector('#touch-input-container');
	const movementAreaElement = document.querySelector('#movement-area');
	const cameraAreaElement = document.querySelector('#camera-area');
	const movementJoystick = document.querySelector('#movement-joystick');
	const movementJoystickHandle = document.querySelector('#movement-joystick-handle');
	const actionButtonContainer = document.querySelector('#action-buttons');
	const jumpButton = document.querySelector('#jump-button');
	const useButton = document.querySelector('#use-button');
	const blastButton = document.querySelector('#blast-button');
	const pauseButton = document.querySelector('#pause-button');
	const restartButton = document.querySelector('#restart-button');
	const freeLookButton = document.querySelector('#free-look-button');
	const JOYSTICK_HANDLE_SIZE_FACTOR = 2 / 5;
	let joystickPosition = null;
	let normalizedJoystickHandlePosition = null;
	let movementAreaTouchIdentifier = null;
	let cameraAreaTouchIdentifier = null;
	let lastCameraTouch = null;
	let joystickAsCameraTouches = [];
	let useEnabled = false;
	let blastEnabled = false;
	const setUseEnabled = (value) => {
	    useEnabled = value;
	};
	const setBlastEnabled = (value) => {
	    blastEnabled = value;
	};
	const getUseEnabledOpacityAndEnabled = () => {
	    return {
	        opacity: useEnabled ? '0.5' : '0.2',
	        enabled: useEnabled
	    };
	};
	const getBlastEnabledOpacityAndEnabled = () => {
	    return {
	        opacity: blastEnabled ? '0.5' : '0.2',
	        enabled: blastEnabled
	    };
	};
	let touchendFuncs = [];
	const setupTouchButton = (element, button, onStart, onEnd, getOpacityAndEnabled) => {
	    let touchId = null;
	    element.addEventListener('touchstart', (e) => {
	        var _a;
	        let touch = e.changedTouches[0];
	        touchId = touch.identifier;
	        let oaenabled = (_a = getOpacityAndEnabled === null || getOpacityAndEnabled === void 0 ? void 0 : getOpacityAndEnabled().enabled) !== null && _a !== void 0 ? _a : true;
	        if (oaenabled)
	            element.style.opacity = '0.9';
	        else
	            element.style.opacity = '0.4';
	        setPressed(button, 'touch', true);
	        onStart === null || onStart === void 0 ? void 0 : onStart(touch);
	    });
	    touchendFuncs.push((touch, force) => {
	        var _a;
	        if (force || touch.identifier === touchId) {
	            touchId = null;
	            element.style.opacity = (_a = getOpacityAndEnabled === null || getOpacityAndEnabled === void 0 ? void 0 : getOpacityAndEnabled().opacity) !== null && _a !== void 0 ? _a : '';
	            setPressed(button, 'touch', false);
	            onEnd === null || onEnd === void 0 ? void 0 : onEnd(touch);
	        }
	    });
	};
	const startCameraMovement = (touch) => {
	    cameraAreaTouchIdentifier = touch.identifier;
	    lastCameraTouch = touch;
	};
	const startCameraMovementFromButton = (touch) => {
	    startCameraMovement(touch);
	    joystickAsCameraTouches.push(touch);
	};
	const endCameraMovementFromButton = (touch) => {
	    joystickAsCameraTouches.splice(joystickAsCameraTouches.indexOf(touch), 1);
	};
	setupTouchButton(jumpButton, 'jump', startCameraMovementFromButton, endCameraMovementFromButton);
	setupTouchButton(useButton, 'use', startCameraMovementFromButton, endCameraMovementFromButton, getUseEnabledOpacityAndEnabled);
	setupTouchButton(blastButton, 'blast', startCameraMovementFromButton, endCameraMovementFromButton, getBlastEnabledOpacityAndEnabled);
	setupTouchButton(pauseButton, 'pause');
	setupTouchButton(restartButton, 'restart');
	setupTouchButton(freeLookButton, 'freeLook');
	const hideTouchControls$1 = () => {
	    touchInputContainer.style.display = 'none';
	};
	const maybeShowTouchControls$1 = () => {
	    touchInputContainer.style.display = Util$1.isTouchDevice ? 'block' : 'none';
	};
	movementAreaElement.addEventListener('touchstart', (e) => {
	    let touch = e.changedTouches[0];
	    movementAreaTouchIdentifier = touch.identifier;
	    let x, y;
	    let joystickSize = StorageManager$1.data.settings.joystickSize;
	    if (StorageManager$1.data.settings.joystickPosition === 0) {
	        // Fixed
	        x = StorageManager$1.data.settings.joystickLeftOffset + joystickSize / 2;
	        y = window.innerHeight * (1 - StorageManager$1.data.settings.joystickVerticalPosition) * SCALING_RATIO$1;
	    }
	    else {
	        // Dynamic
	        x = Util$1.clamp(touch.clientX * SCALING_RATIO$1, joystickSize / 2, (window.innerWidth * SCALING_RATIO$1 - joystickSize) / 2);
	        y = Util$1.clamp(touch.clientY * SCALING_RATIO$1, joystickSize / 2, window.innerHeight * SCALING_RATIO$1 - joystickSize / 2);
	    }
	    movementJoystick.style.visibility = 'visible';
	    movementJoystick.style.left = x - joystickSize / 2 + 'px';
	    movementJoystick.style.top = y - joystickSize / 2 + 'px';
	    joystickPosition = { x: x, y: y };
	    normalizedJoystickHandlePosition = { x: 0, y: 0 };
	    updateJoystickHandlePosition(touch);
	});
	movementAreaElement.addEventListener('touchmove', (e) => {
	    let touch = [...e.changedTouches].find(x => x.identifier === movementAreaTouchIdentifier);
	    if (!touch)
	        return;
	    if (touch.identifier === movementAreaTouchIdentifier) {
	        updateJoystickHandlePosition(touch);
	    }
	});
	const updateJoystickHandlePosition = (touch) => {
	    let joystickSize = StorageManager$1.data.settings.joystickSize;
	    let joystickHandleSize = JOYSTICK_HANDLE_SIZE_FACTOR * StorageManager$1.data.settings.joystickSize;
	    let innerRadius = (joystickSize - joystickHandleSize) / 2;
	    normalizedJoystickHandlePosition.x = Util$1.clamp((touch.clientX * SCALING_RATIO$1 - joystickPosition.x) / innerRadius, -1, 1);
	    normalizedJoystickHandlePosition.y = Util$1.clamp((touch.clientY * SCALING_RATIO$1 - joystickPosition.y) / innerRadius, -1, 1);
	    movementJoystickHandle.style.left = (normalizedJoystickHandlePosition.x) * innerRadius + joystickSize / 2 - joystickHandleSize / 2 + 'px';
	    movementJoystickHandle.style.top = (normalizedJoystickHandlePosition.y) * innerRadius + joystickSize / 2 - joystickHandleSize / 2 + 'px';
	};
	window.addEventListener('touchend', (e) => {
	    for (let touch of e.changedTouches) {
	        if (touch.identifier === movementAreaTouchIdentifier) {
	            movementAreaTouchIdentifier = null;
	            movementJoystick.style.visibility = 'hidden';
	            normalizedJoystickHandlePosition = null;
	        }
	        if (touch.identifier === cameraAreaTouchIdentifier) {
	            cameraAreaTouchIdentifier = null;
	        }
	        for (let func of touchendFuncs)
	            func(touch, false);
	    }
	    if (e.touches.length === 0) {
	        // Just to be sure, end all the things. To prevent stuff from being stuck on screen forever
	        movementAreaTouchIdentifier = null;
	        movementJoystick.style.visibility = 'hidden';
	        normalizedJoystickHandlePosition = null;
	        cameraAreaTouchIdentifier = null;
	        for (let func of touchendFuncs)
	            func(null, true);
	    }
	});
	cameraAreaElement.addEventListener('touchstart', (e) => {
	    let touch = e.changedTouches[0];
	    startCameraMovement(touch);
	});
	// Put this on touchInputContainer instead of cameraAreaElement so it also works when you start the drag on a button
	touchInputContainer.addEventListener('touchmove', (e) => {
	    let touch = [...e.changedTouches].find(x => x.identifier === cameraAreaTouchIdentifier);
	    let level = G$1.level;
	    if (!touch)
	        return;
	    if (touch.identifier === cameraAreaTouchIdentifier) {
	        let movementX = (touch.clientX - lastCameraTouch.clientX) * SCALING_RATIO$1;
	        let movementY = (touch.clientY - lastCameraTouch.clientY) * SCALING_RATIO$1;
	        let factor = Util$1.lerp(1 / 1500, 1 / 50, StorageManager$1.data.settings.mouseSensitivity) * ((joystickAsCameraTouches.length !== 0) ? StorageManager$1.data.settings.actionButtonAsJoystickMultiplier : 1);
	        let yFactor = (StorageManager$1.data.settings.invertMouse & 0b10) ? -1 : 1;
	        let freeLook = StorageManager$1.data.settings.alwaysFreeLook || isPressed$1('freeLook');
	        level.yaw -= movementX * factor;
	        if (freeLook)
	            level.pitch += movementY * factor * yFactor;
	        lastCameraTouch = touch;
	    }
	});
	//# sourceMappingURL=input.js.map

	/** Stores and handles operations on the online leaderboard. */
	class Leaderboard {
	    static async init() {
	        // The first time we do this, the main purpose is to update the value of `latestTimestamp`.
	        await this.syncLeaderboard();
	    }
	    /** Loads the scores of all missions in the vicinity of the current mission. */
	    static loadLocal() {
	        let missionPaths = new Set();
	        let currentLevelArray = G$1.menu.levelSelect.currentMissionArray;
	        for (let i = -5; i <= 5; i++) {
	            let index = G$1.menu.levelSelect.getCycleMissionIndex(i);
	            let mission = currentLevelArray[index];
	            if (mission)
	                missionPaths.add(mission.path);
	        }
	        for (let mission of G$1.menu.levelSelect.getNextShuffledMissions())
	            missionPaths.add(mission.path);
	        this.loadForMissions([...missionPaths]);
	    }
	    /** Loads all scores for the given missions. */
	    static async loadForMissions(missionPaths) {
	        missionPaths = missionPaths.filter(x => !this.loading.has(x) && !this.scores.has(x)); // Filter out loaded or loading missions
	        if (missionPaths.length === 0)
	            return;
	        missionPaths.forEach(x => this.loading.add(x));
	        this.registerLeaderboardChange(missionPaths);
	        // Get all the scores
	        let blob = await ResourceManager$1.retryFetch('./api/scores', {
	            method: 'POST',
	            body: JSON.stringify({
	                missions: missionPaths
	            }),
	            headers: {
	                'Content-Type': 'application/json'
	            }
	        });
	        let data = await ResourceManager$1.readBlobAsJson(blob);
	        for (let missionPath in data) {
	            // Update the scores
	            this.scores.set(missionPath, data[missionPath]);
	            this.loading.delete(missionPath);
	        }
	        this.registerLeaderboardChange(missionPaths);
	    }
	    static isLoading(missionPath) {
	        return this.loading.has(missionPath);
	    }
	    /** Submits a new personal best time to the leaderboard. */
	    static async submitBestTime(missionPath, score) {
	        StorageManager$1.data.bestTimeSubmissionQueue[missionPath] = score;
	        StorageManager$1.store();
	        this.syncLeaderboard();
	    }
	    /** Synchronizes the leaderboard: Uploads new personal best times and gets all new/changed online scores and updates the leaderboard accordingly. */
	    static async syncLeaderboard() {
	        var _a;
	        let queue = StorageManager$1.data.bestTimeSubmissionQueue;
	        let payloadBestTimes = {};
	        let payloadReplays = {};
	        // Go over all scores in the submission queue
	        for (let missionPath in queue) {
	            let score = queue[missionPath];
	            payloadBestTimes[missionPath] = [score[0], score[1]];
	            let onlineScore = (_a = this.scores.get(missionPath)) === null || _a === void 0 ? void 0 : _a[0];
	            if ((!onlineScore || (score[1] < onlineScore[1])) && !missionPath.includes('custom/')) {
	                // This score is better than the top online score, therefore assume this is a new world record and prepare the replay for upload.
	                let replayData = await StorageManager$1.databaseGet('replays', score[2]);
	                if (!replayData)
	                    continue;
	                // Convert to base64 because we can't ship binary data over JSON
	                let base64 = await Util$1.arrayBufferToBase64(replayData);
	                payloadReplays[missionPath] = base64;
	            }
	        }
	        let payload = {
	            randomId: StorageManager$1.data.randomId,
	            bestTimes: Object.keys(queue).length ? await Util$1.arrayBufferToBase64(await executeOnWorker$1('compress', JSON.stringify(payloadBestTimes))) : null,
	            latestTimestamp: this.latestTimestamp,
	            replays: payloadReplays
	        };
	        let blob = await ResourceManager$1.retryFetch('./api/submit', {
	            method: 'POST',
	            body: JSON.stringify(payload),
	            headers: {
	                'Content-Type': 'application/json'
	            }
	        });
	        let data = await ResourceManager$1.readBlobAsJson(blob);
	        this.latestTimestamp = data.latestTimestamp;
	        for (let missionPath in data.scores) {
	            // Update the leaderboard with the new scores
	            this.scores.set(missionPath, data.scores[missionPath]);
	        }
	        this.registerLeaderboardChange(Object.keys(data.scores));
	        // Since a response arrived, empty the queue
	        StorageManager$1.data.bestTimeSubmissionQueue = {};
	        StorageManager$1.store();
	    }
	    /** Communicates that the given missions' leaderboards have changed somehow. Causes a visual update to the leaderboard if the missions are currently being viewed. */
	    static registerLeaderboardChange(changedMissions) {
	        var _a, _b;
	        // Legacy stuff here to purge outdated local scores:
	        let localScoreRemoved = false;
	        for (let missionPath in changedMissions) {
	            let onlineScore = (_a = this.scores.get(missionPath)) === null || _a === void 0 ? void 0 : _a[0];
	            let localScore = (_b = StorageManager$1.data.bestTimes[missionPath]) === null || _b === void 0 ? void 0 : _b[0];
	            if (!onlineScore || !localScore)
	                continue;
	            while (localScore && localScore[1] < Number(onlineScore[1]) && localScore[3] === 0) {
	                // Splice all timestamp 0 times that are faster than the current WR on the leaderboard. We do this because the score is outdated.
	                StorageManager$1.data.bestTimes[missionPath].splice(0, 1);
	                localScore = StorageManager$1.data.bestTimes[missionPath][0];
	                localScoreRemoved = true;
	            }
	            if (StorageManager$1.data.bestTimes[missionPath].length === 0)
	                delete StorageManager$1.data.bestTimes[missionPath];
	        }
	        if (localScoreRemoved)
	            StorageManager$1.storeBestTimes();
	        let currentMission = G$1.menu.levelSelect.currentMission;
	        if (changedMissions.includes(currentMission === null || currentMission === void 0 ? void 0 : currentMission.path))
	            G$1.menu.levelSelect.displayBestTimes(); // Redraw the leaderboard
	    }
	}
	/** The scores for each mission. */
	Leaderboard.scores = new Map();
	/** Whether a mission's scores are currently loading. */
	Leaderboard.loading = new Set();
	/** The latest score timestamp received from the user. Will be used to get any scores newer than this. */
	Leaderboard.latestTimestamp = null;
	//# sourceMappingURL=leaderboard.js.map

	class SharedUtil {
	    /** Unescapes escaped (\) characters. */
	    static unescape(str) {
	        let cEscapeRegex = /(^|[^\\])\\x([0-9a-f]{2})/gi; // Matches \xhh
	        let match = null;
	        while ((match = cEscapeRegex.exec(str)) !== null) {
	            let code = Number.parseInt(match[2], 16);
	            let char = this.macRomanToUtf8(code); // DUMB
	            str = str.slice(0, match.index) + match[1] + char + str.slice(match.index + match[0].length); // match[1] is "negative lookbehind"
	            cEscapeRegex.lastIndex -= 3;
	        }
	        let regex = /\\(.)/g;
	        let specialCases = {
	            '\\': '\\',
	            't': '\t',
	            'v': '\v',
	            '0': '\0',
	            'f': '\f',
	            'n': '\n',
	            'r': '\r'
	        };
	        while ((match = regex.exec(str)) !== null) {
	            let replaceWith;
	            if (specialCases[match[1]])
	                replaceWith = specialCases[match[1]];
	            else
	                replaceWith = match[1];
	            str = str.slice(0, match.index) + replaceWith + str.slice(match.index + match[0].length);
	            regex.lastIndex--;
	        }
	        return str;
	    }
	    /** Splits a string like String.prototype.split, but ignores the splitter if it appears inside string literal tokens. */
	    static splitIgnoreStringLiterals(str, splitter, strLiteralToken = '"') {
	        let indices = [];
	        let inString = false;
	        for (let i = 0; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	            else if (c === splitter)
	                indices.push(i);
	        }
	        let parts = [];
	        let remaining = str;
	        for (let i = 0; i < indices.length; i++) {
	            let index = indices[i] - (str.length - remaining.length);
	            let part = remaining.slice(0, index);
	            remaining = remaining.slice(index + 1);
	            parts.push(part);
	        }
	        parts.push(remaining);
	        return parts;
	    }
	    /** Gets the index of a substring like String.prototype.indexOf, but only if that index lies outside of string literals. */
	    static indexOfIgnoreStringLiterals(str, searchString, position = 0, strLiteralToken = '"') {
	        let inString = false;
	        for (let i = position; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	            else if (str.startsWith(searchString, i))
	                return i;
	        }
	        return -1;
	    }
	    /** Returns true iff the supplied index is part of a string literal. */
	    static indexIsInStringLiteral(str, index, strLiteralToken = '"') {
	        let inString = false;
	        for (let i = 0; i < str.length; i++) {
	            let c = str[i];
	            if (inString) {
	                if (i === index)
	                    return true;
	                if (c === strLiteralToken && str[i - 1] !== '\\')
	                    inString = false;
	                continue;
	            }
	            if (c === strLiteralToken)
	                inString = true;
	        }
	        return false;
	    }
	    /** Some fonts were apparently compiled on Mac and use this encoding instead of something sensible. Stupid. */
	    static macRomanToUtf8(char) {
	        if (char < 128)
	            return String.fromCharCode(char);
	        else
	            return this.macRomanToUtf8Map[char - 128];
	    }
	}
	SharedUtil.macRomanToUtf8Map = ['Ä', 'Å', 'Ç', 'É', 'Ñ', 'Ö', 'Ü', 'á', 'à', 'â', 'ä', 'ã', 'å', 'ç', 'é', 'è', 'ê', 'ë', 'í', 'ì', 'î', 'ï', 'ñ', 'ó', 'ò', 'ô', 'ö', 'õ', 'ú', 'ù', 'û', 'ü', '†', '°', '¢', '£', '§', '•', '¶', 'ß', '®', '©', '™', '´', '¨', '≠', 'Æ', 'Ø', '∞', '±', '≤', '≥', '¥', 'µ', '∂', '∑', '∏', 'π', '∫', 'ª', 'º', 'Ω', 'æ', 'ø', '¿', '¡', '¬', '√', 'ƒ', '≈', '∆', '«', '»', '…', ' ', 'À', 'Ã', 'Õ', 'Œ', 'œ', '–', '—', '“', '”', '‘', '’', '÷', '◊', 'ÿ', 'Ÿ', '⁄', '€', '‹', '›', 'ﬁ', 'ﬂ', '‡', '·', '‚', '„', '‰', 'Â', 'Ê', 'Á', 'Ë', 'È', 'Í', 'Î', 'Ï', 'Ì', 'Ó', 'Ô', '🍎', 'Ò', 'Ú', 'Û', 'Ù', 'ı', 'ˆ', '˜', '¯', '˘', '˙', '˚', '¸', '˝', '˛', 'ˇ'];
	//# sourceMappingURL=util.js.map

	var MissionElementType$1;
	(function (MissionElementType) {
	    MissionElementType[MissionElementType["SimGroup"] = 0] = "SimGroup";
	    MissionElementType[MissionElementType["ScriptObject"] = 1] = "ScriptObject";
	    MissionElementType[MissionElementType["MissionArea"] = 2] = "MissionArea";
	    MissionElementType[MissionElementType["Sky"] = 3] = "Sky";
	    MissionElementType[MissionElementType["Sun"] = 4] = "Sun";
	    MissionElementType[MissionElementType["InteriorInstance"] = 5] = "InteriorInstance";
	    MissionElementType[MissionElementType["StaticShape"] = 6] = "StaticShape";
	    MissionElementType[MissionElementType["Item"] = 7] = "Item";
	    MissionElementType[MissionElementType["Path"] = 8] = "Path";
	    MissionElementType[MissionElementType["Marker"] = 9] = "Marker";
	    MissionElementType[MissionElementType["PathedInterior"] = 10] = "PathedInterior";
	    MissionElementType[MissionElementType["Trigger"] = 11] = "Trigger";
	    MissionElementType[MissionElementType["AudioProfile"] = 12] = "AudioProfile";
	    MissionElementType[MissionElementType["MessageVector"] = 13] = "MessageVector";
	    MissionElementType[MissionElementType["TSStatic"] = 14] = "TSStatic";
	    MissionElementType[MissionElementType["ParticleEmitterNode"] = 15] = "ParticleEmitterNode";
	})(MissionElementType$1 || (MissionElementType$1 = {}));
	const elementHeadRegEx = /new\s+(\w+)\((.*?)\)\s*{/g;
	const blockCommentRegEx = /\/\*(.|\n)*?\*\//g;
	const lineCommentRegEx = /\/\/.*/g;
	const assignmentRegEx = /(\$(?:\w|\d)+)\s*=\s*(.+?);/g;
	const marbleAttributesRegEx = /setMarbleAttributes\("(\w+)",\s*(.+?)\);/g;
	const activatePackageRegEx = /activatePackage\((.+?)\);/g;
	const materialPropertyRegEx = /new MaterialProperty *\( *(.+?) *\)\s*{\s*((?:\w+ *= *(\d|\.)+;\s*)*)}/gi;
	const addMaterialMappingRegEx = /addMaterialMapping *\( *"(.+?)" *, *(.+?) *\)/gi;
	const keyValuePairRegEx = /([^\s]+?)\s*=\s*"(.*?)"\s*;/g;
	/** A parser for .mis files, which hold mission information. */
	class MisParser$1 {
	    constructor(text) {
	        this.index = 0;
	        this.currentElementId = 0;
	        this.text = text;
	    }
	    parse() {
	        // This is dirty, but prepend all material definitions to the top of the file so we can parse them incase any custom material of this level uses them.
	        this.text = materialPropertyDefinition + '\n\n' + this.text;
	        let objectWriteBeginIndex = this.text.indexOf("//--- OBJECT WRITE BEGIN ---");
	        let objectWriteEndIndex = this.text.lastIndexOf("//--- OBJECT WRITE END ---");
	        let outsideText = this.text.slice(0, objectWriteBeginIndex) + this.text.slice(objectWriteEndIndex);
	        // Find all specified variables
	        this.variables = { "$usermods": '""' }; // Just make $usermods point to nothing
	        assignmentRegEx.lastIndex = 0;
	        let match = null;
	        while ((match = assignmentRegEx.exec(outsideText)) !== null) {
	            // Only use the first variable found. This is because the variable is likely to be modified later on with conditional statements and that's too complex to parse right now.
	            if (!this.variables[match[1]])
	                this.variables[match[1]] = match[2];
	        }
	        // Parse any custom marble attributes specified at the top of the file
	        let marbleAttributes = {};
	        match = null;
	        marbleAttributesRegEx.lastIndex = 0;
	        while ((match = marbleAttributesRegEx.exec(outsideText)) !== null) {
	            marbleAttributes[match[1]] = this.resolveExpression(match[2]);
	        }
	        // Parse any packages that the mission file activates
	        let activatedPackages = [];
	        match = null;
	        activatePackageRegEx.lastIndex = 0;
	        while ((match = activatePackageRegEx.exec(outsideText)) !== null) {
	            activatedPackages.push(this.resolveExpression(match[1]));
	        }
	        let materialProperties = {};
	        match = null;
	        materialPropertyRegEx.lastIndex = 0;
	        while ((match = materialPropertyRegEx.exec(outsideText)) !== null) {
	            let pairs = match[2].split(';').filter(x => x.trim()).map(x => x.split('=').map(x => x.trim()));
	            materialProperties[match[1]] = {};
	            for (let pair of pairs) {
	                materialProperties[match[1]][pair[0]] = Number(pair[1]);
	            }
	        }
	        let materialMappings = {};
	        match = null;
	        addMaterialMappingRegEx.lastIndex = 0;
	        while ((match = addMaterialMappingRegEx.exec(outsideText)) !== null) {
	            materialMappings[match[1]] = match[2];
	        }
	        // Trim away the outside text
	        if (objectWriteBeginIndex !== -1 && objectWriteEndIndex !== -1) {
	            this.text = this.text.slice(objectWriteBeginIndex, objectWriteEndIndex);
	        }
	        // Remove all block and line comments to make parsing easier
	        let currentIndex = 0;
	        while (true) {
	            blockCommentRegEx.lastIndex = currentIndex;
	            lineCommentRegEx.lastIndex = currentIndex;
	            let blockMatch = blockCommentRegEx.exec(this.text);
	            let lineMatch = lineCommentRegEx.exec(this.text);
	            // The detected "comment" might be inside a string literal, in which case we ignore it 'cause it ain't no comment.
	            if (blockMatch && SharedUtil.indexIsInStringLiteral(this.text, blockMatch.index))
	                blockMatch = null;
	            if (lineMatch && SharedUtil.indexIsInStringLiteral(this.text, lineMatch.index))
	                lineMatch = null;
	            if (!blockMatch && !lineMatch)
	                break;
	            else if (!lineMatch || (blockMatch && lineMatch && blockMatch.index < lineMatch.index)) {
	                this.text = this.text.slice(0, blockMatch.index) + this.text.slice(blockMatch.index + blockMatch[0].length);
	                currentIndex = blockMatch.index;
	            }
	            else {
	                this.text = this.text.slice(0, lineMatch.index) + this.text.slice(lineMatch.index + lineMatch[0].length);
	                currentIndex = lineMatch.index;
	            }
	        }
	        let indexOfMissionGroup = this.text.indexOf('new SimGroup(MissionGroup)');
	        if (indexOfMissionGroup !== -1)
	            this.index = indexOfMissionGroup;
	        // Read out all elements (we're expecting exactly one!)
	        let elements = [];
	        while (this.hasNextElement()) {
	            let element = this.readElement();
	            if (!element)
	                continue;
	            elements.push(element);
	        }
	        if (elements.length !== 1) {
	            // We expect there to be only one outer element; the MissionGroup SimGroup.
	            console.log(elements);
	            throw new Error("Mission file doesn't have exactly 1 outer element!");
	        }
	        return {
	            root: elements[0],
	            marbleAttributes,
	            activatedPackages,
	            materialProperties,
	            materialMappings
	        };
	    }
	    readElement() {
	        // Get information about the head
	        elementHeadRegEx.lastIndex = this.index;
	        let head = elementHeadRegEx.exec(this.text);
	        this.index = head.index + head[0].length;
	        let type = head[1];
	        let name = head[2];
	        this.index = head.index + head[0].length;
	        let element = null;
	        switch (type) {
	            case "SimGroup":
	                element = this.readSimGroup(name);
	                break;
	            case "ScriptObject":
	                element = this.readScriptObject(name);
	                break;
	            case "MissionArea":
	                element = this.readMissionArea(name);
	                break;
	            case "Sky":
	                element = this.readSky(name);
	                break;
	            case "Sun":
	                element = this.readSun(name);
	                break;
	            case "InteriorInstance":
	                element = this.readInteriorInstance(name);
	                break;
	            case "StaticShape":
	                element = this.readStaticShape(name);
	                break;
	            case "Item":
	                element = this.readItem(name);
	                break;
	            case "Path":
	                element = this.readPath(name);
	                break;
	            case "Marker":
	                element = this.readMarker(name);
	                break;
	            case "PathedInterior":
	                element = this.readPathedInterior(name);
	                break;
	            case "Trigger":
	                element = this.readTrigger(name);
	                break;
	            case "AudioProfile":
	                element = this.readAudioProfile(name);
	                break;
	            case "MessageVector":
	                element = this.readMessageVector(name);
	                break;
	            case "TSStatic":
	                element = this.readTSStatic(name);
	                break;
	            case "ParticleEmitterNode":
	                element = this.readParticleEmitterNode(name);
	                break;
	            default: {
	                console.warn("Unknown element type! " + type);
	                // Still advance the index
	                let endingBraceIndex = SharedUtil.indexOfIgnoreStringLiterals(this.text, '};', this.index);
	                if (endingBraceIndex === -1)
	                    endingBraceIndex = this.text.length;
	                this.index = endingBraceIndex + 2;
	            }
	        }
	        if (element)
	            element._id = this.currentElementId++;
	        return element;
	    }
	    /** Checks if there's another element coming in the current scope. */
	    hasNextElement() {
	        elementHeadRegEx.lastIndex = this.index;
	        let head = elementHeadRegEx.exec(this.text);
	        if (!head)
	            return false;
	        if (SharedUtil.indexOfIgnoreStringLiterals(this.text.slice(this.index, head.index), '}') !== -1)
	            return false;
	        return true;
	    }
	    readSimGroup(name) {
	        let elements = [];
	        let keyValuePairs = {}; // Possible optional key-value pairs also included with the sim group
	        // Read in all elements
	        while (true) {
	            elementHeadRegEx.lastIndex = this.index;
	            keyValuePairRegEx.lastIndex = this.index;
	            let head = elementHeadRegEx.exec(this.text);
	            let keyValue = keyValuePairRegEx.exec(this.text);
	            let index = Math.min(head === null || head === void 0 ? void 0 : head.index, keyValue === null || keyValue === void 0 ? void 0 : keyValue.index);
	            if (!isFinite(index))
	                break;
	            if (SharedUtil.indexOfIgnoreStringLiterals(this.text.slice(this.index, index), '}') !== -1)
	                break;
	            if (index === (head === null || head === void 0 ? void 0 : head.index)) {
	                let element = this.readElement();
	                if (!element)
	                    continue;
	                elements.push(element);
	            }
	            else {
	                keyValuePairs[keyValue[1]] = this.resolveExpression(keyValue[2]);
	                this.index += keyValue[0].length;
	            }
	        }
	        let endingBraceIndex = SharedUtil.indexOfIgnoreStringLiterals(this.text, '};', this.index);
	        if (endingBraceIndex === -1)
	            endingBraceIndex = this.text.length;
	        this.index = endingBraceIndex + 2;
	        if (!elements)
	            return null;
	        return Object.assign(keyValuePairs, {
	            _type: MissionElementType$1.SimGroup,
	            _name: name,
	            elements: elements
	        });
	    }
	    /** Reads the key/value pairs of an element. */
	    readValues() {
	        var _a;
	        // Values are either strings or string arrays.
	        let obj = {};
	        let endingBraceIndex = SharedUtil.indexOfIgnoreStringLiterals(this.text, '};', this.index);
	        if (endingBraceIndex === -1)
	            endingBraceIndex = this.text.length;
	        let section = this.text.slice(this.index, endingBraceIndex).trim();
	        let statements = SharedUtil.splitIgnoreStringLiterals(section, ';').map(x => x.trim()); // Get a list of all statements
	        for (let statement of statements) {
	            if (!statement)
	                continue;
	            let splitIndex = statement.indexOf('=');
	            if (splitIndex === -1)
	                continue;
	            let parts = [statement.slice(0, splitIndex), statement.slice(splitIndex + 1)].map((part) => part.trim());
	            if (parts.length !== 2)
	                continue;
	            let key = parts[0];
	            key = key.toLowerCase(); // TorqueScript is case-insensitive here
	            if (key.endsWith(']')) {
	                // The key is specifying array data, so handle that case.
	                let openingIndex = key.indexOf('[');
	                let arrayName = key.slice(0, openingIndex);
	                let array = ((_a = obj[arrayName]) !== null && _a !== void 0 ? _a : (obj[arrayName] = [])); // Create a new array or use the existing one
	                let index = Number(key.slice(openingIndex + 1, -1));
	                array[index] = this.resolveExpression(parts[1]);
	            }
	            else {
	                obj[key] = this.resolveExpression(parts[1]);
	            }
	        }
	        this.index = endingBraceIndex + 2;
	        return obj;
	    }
	    /** Resolves a TorqueScript rvalue expression. Currently only supports the concatenation @ operator. */
	    resolveExpression(expr) {
	        let parts = SharedUtil.splitIgnoreStringLiterals(expr, '@').map(x => {
	            x = x.trim();
	            if (x.startsWith('$') && this.variables[x] !== undefined) {
	                // Replace the variable with its value
	                x = this.resolveExpression(this.variables[x]);
	            }
	            else if (x.startsWith('"') && x.endsWith('"')) {
	                x = SharedUtil.unescape(x.slice(1, -1)); // It's a string literal, so remove " "
	            }
	            return x;
	        });
	        return parts.join('');
	    }
	    readScriptObject(name) {
	        return Object.assign({
	            _type: MissionElementType$1.ScriptObject,
	            _name: name
	        }, this.readValues());
	    }
	    readMissionArea(name) {
	        return Object.assign({
	            _type: MissionElementType$1.MissionArea,
	            _name: name
	        }, this.readValues());
	    }
	    readSky(name) {
	        return Object.assign({
	            _type: MissionElementType$1.Sky,
	            _name: name
	        }, this.readValues());
	    }
	    readSun(name) {
	        return Object.assign({
	            _type: MissionElementType$1.Sun,
	            _name: name
	        }, this.readValues());
	    }
	    readInteriorInstance(name) {
	        return Object.assign({
	            _type: MissionElementType$1.InteriorInstance,
	            _name: name
	        }, this.readValues());
	    }
	    readStaticShape(name) {
	        return Object.assign({
	            _type: MissionElementType$1.StaticShape,
	            _name: name
	        }, this.readValues());
	    }
	    readItem(name) {
	        return Object.assign({
	            _type: MissionElementType$1.Item,
	            _name: name
	        }, this.readValues());
	    }
	    readPath(name) {
	        let simGroup = this.readSimGroup(name);
	        simGroup['markers'] = simGroup.elements.sort((a, b) => MisParser$1.parseNumber(a.seqnum) - MisParser$1.parseNumber(b.seqnum)); // Make sure they're sorted sequentially
	        delete simGroup['elements'];
	        simGroup._type = MissionElementType$1.Path;
	        return simGroup;
	    }
	    readMarker(name) {
	        return Object.assign({
	            _type: MissionElementType$1.Marker,
	            _name: name
	        }, this.readValues());
	    }
	    readPathedInterior(name) {
	        return Object.assign({
	            _type: MissionElementType$1.PathedInterior,
	            _name: name
	        }, this.readValues());
	    }
	    readTrigger(name) {
	        return Object.assign({
	            _type: MissionElementType$1.Trigger,
	            _name: name
	        }, this.readValues());
	    }
	    readAudioProfile(name) {
	        return Object.assign({
	            _type: MissionElementType$1.AudioProfile,
	            _name: name
	        }, this.readValues());
	    }
	    readMessageVector(name) {
	        return Object.assign({
	            _type: MissionElementType$1.MessageVector,
	            _name: name
	        }, this.readValues());
	    }
	    readTSStatic(name) {
	        return Object.assign({
	            _type: MissionElementType$1.TSStatic,
	            _name: name
	        }, this.readValues());
	    }
	    readParticleEmitterNode(name) {
	        return Object.assign({
	            _type: MissionElementType$1.ParticleEmitterNode,
	            _name: name
	        }, this.readValues());
	    }
	    /** Parses a numeric value. */
	    static parseNumber(string) {
	        if (!string || typeof string !== 'string')
	            return 0;
	        // Strange thing here, apparently you can supply lists of numbers. In this case tho, we just take the first value.
	        let val = Number(string.split(',')[0]);
	        if (isNaN(val))
	            return 0;
	        return val;
	    }
	    /** Parses a boolean value. */
	    static parseBoolean(string) {
	        if (!string)
	            return false;
	        if (string === "0")
	            return false;
	        return true;
	    }
	}
	/** The source string, taken from PQ, where all default frictions and materials are defined. */
	const materialPropertyDefinition = `
new MaterialProperty(GrassFrictionMaterial) {
	friction = 1.50;
	restitution = 0.35;
};

new MaterialProperty(TarmacFrictionMaterial) {
	friction = 0.35;
	restitution = 0.7;
};

new MaterialProperty(RugFrictionMaterial) {
	friction = 6;
	restitution = 0.5;
};

new MaterialProperty(IceFrictionMaterial) {
	friction = 0.03;
	restitution = 0.95;
};

new MaterialProperty(CarpetFrictionMaterial) {
	friction = 6;
	restitution = 0.5;
};

new MaterialProperty(SandFrictionMaterial) {
	friction = 4;
	restitution = 0.1;
};

new MaterialProperty(WaterFrictionMaterial) {
	friction = 6;
	restitution = 0;
};

new MaterialProperty(BouncyFrictionMaterial) {
	friction = 0.2;
	restitution = 0;
	force = 15;
};

new MaterialProperty(RandomForceMaterial) {
	friction = -1;
	restitution = 1;
};

// MBU/O values...

new MaterialProperty(HighFrictionMultiplayerMaterial) {
	friction = 6;
	restitution = 0.3;
};

// added to stop the game from popping an error in the console log that it cannot find the
// material property even though the game runs fine without that minor piece of code
// so these lines of code are an extra to shut the game up and you can remove them if you wish

new MaterialProperty(DefaultMaterial) {
	friction = 1;
	restitution = 1;
};

// these values are for a balanced game play with Mini Marble Golf (the levels)
// they might be a tad different to their MBP equivalent and are more realistic

new MaterialProperty(MMGGrassMaterial) {
	friction = 0.9;
	restitution = 0.5;
};

new MaterialProperty(MMGSandMaterial) {
	friction = 6;
	restitution = 0.1;
};

new MaterialProperty(MMGWaterMaterial) {
	friction = 6;
	restitution = 0;
};

new MaterialProperty(MMGIceMaterial) {
	friction = 0.03;
	restitution = 0.95;
};

new MaterialProperty(MMGIceShadowMaterial) {
	friction = 0.2;
	restitution = 0.95;
};

// These are some old values

new MaterialProperty(BumperMaterial) {
	friction = 0.5;
	restitution = 0;
	force = 15;
};

new MaterialProperty(ButtonMaterial) {
	friction = 1;
	restitution = 1;
};

// MBG Values for their frictions. MBP ones still rock, though.

// Space

new MaterialProperty(NoFrictionMaterial) {
	friction = 0.01;
	restitution = 0.5;
};

// Mud

new MaterialProperty(LowFrictionMaterial) {
	friction = 0.20;
	restitution = 0.5;
};

// Grass

new MaterialProperty(HighFrictionMaterial) {
	friction = 1.50;
	restitution = 0.5;
};

// Yellow ramps with arrows from Three Fold Maze and Escher's Race

new MaterialProperty(VeryHighFrictionMaterial) {
	friction = 2;
	restitution = 1;
};

// Normal floor

new MaterialProperty(RubberFloorMaterial) {
	friction = 1;
	restitution = 1;
};

// Oil Slick

new MaterialProperty(IceMaterial) {
	friction = 0.05;
	restitution = 0.5;
};

new MaterialProperty(XmasSnowMaterial) {
	friction = 3;
	restitution = 0.2;
};

// PlatinumQuest frictions

new MaterialProperty(PQSpaceMaterial) {
	friction = 0.01;
	restitution = 0.35;
};

// It's elite
new MaterialProperty(PQIceMaterial) {
	friction = 0.07331;
	restitution = 0.75;
};

new MaterialProperty(PQMudMaterial) {
	friction = 0.30;
	restitution = 0.5;
};

// Match 3FM/ER friction
new MaterialProperty(PQGrassMaterial) {
	friction = 2;
	restitution = 0.5;
};

// Tad higher on rest. now
new MaterialProperty(PQSandMaterial) {
	friction = 4;
	restitution = 0.15;
};

new MaterialProperty(PQBouncyMaterial) {
	friction = 0.2;
	restitution = 0;
	force = 15;
};

new MaterialProperty(IceShardMaterial) {
	friction = 0;
	restitution = 0;
	force = 0;
};

new MaterialProperty(MORepulsionMaterial) {
	friction = 1;
	restitution = 1;
	force = 10;
};

new MaterialProperty(MOWeakRepulsionMaterial) {
	friction = 1;
	restitution = 1;
	force = 5;
};

// Spooky!!

new MaterialProperty(SpookyWaterMaterial) {
	friction = 6;
	restitution = 0;
};

new MaterialProperty(SpookyDirtMaterial) {
	friction = 6;
	restitution = 0.3;
};

new MaterialProperty(SpookyGrassMaterial) {
	friction = 2;
	restitution = 0.75;
};`;
	//# sourceMappingURL=mis_parser.js.map

	/** An abstract class with common methods used to parse binary files. */
	class BinaryFileParser {
	    constructor(arrayBuffer) {
	        /** The current index of reading. */
	        this.index = 0;
	        this.buffer = arrayBuffer;
	        this.view = new DataView(arrayBuffer);
	    }
	    readU8() {
	        return this.view.getUint8(this.index++);
	    }
	    readU16() {
	        return this.view.getUint16((this.index = this.index + 2) - 2, true);
	    }
	    readU32() {
	        return this.view.getUint32((this.index = this.index + 4) - 4, true);
	    }
	    readS8() {
	        return this.view.getInt8(this.index++);
	    }
	    readS16() {
	        return this.view.getInt16((this.index = this.index + 2) - 2, true);
	    }
	    readS32() {
	        return this.view.getInt32((this.index = this.index + 4) - 4, true);
	    }
	    readF32() {
	        return this.view.getFloat32((this.index = this.index + 4) - 4, true);
	    }
	    readBool() {
	        return this.readU8() === 1;
	    }
	    readPoint3F() {
	        let x = this.readF32(), y = this.readF32(), z = this.readF32();
	        return { x, y, z };
	    }
	    readBox3F() {
	        let min = this.readPoint3F(), max = this.readPoint3F();
	        return { min, max };
	    }
	    readSphereF() {
	        let center = this.readPoint3F(), radius = this.readF32();
	        return { center, radius };
	    }
	    readPlaneF() {
	        let x = this.readF32(), y = this.readF32(), z = this.readF32(), d = this.readF32();
	        return { x, y, z, d };
	    }
	    readString() {
	        // The length of the string is given in the first byte
	        let length = this.readU8();
	        let result = "";
	        for (let i = 0; i < length; i++) {
	            result += String.fromCharCode(this.readU8());
	        }
	        while (result.charCodeAt(result.length - 1) === 0)
	            result = result.slice(0, -1); // Trim off NUL bytes from the end (thank you, HiGuy)
	        return result;
	    }
	}
	//# sourceMappingURL=binary_file_parser.js.map

	/* eslint-disable @typescript-eslint/no-unused-vars */
	const NUM_COORD_BINS = 16;
	/** A parser for .dif files, used for interiors. The main resources used to create this parser were http://www.rustycode.com/projects/Docs/Torque%20DIF%20File%20(Interiors)%20-%20Format%2044.14.html and the Torque 3D source code. */
	class DifParser extends BinaryFileParser {
	    parse() {
	        let version = this.readU32();
	        let previewIncluded = this.readBool();
	        let numDetailLevels = this.readU32();
	        let detailLevels = [];
	        for (let i = 0; i < numDetailLevels; i++) {
	            let interior = this.parseInterior();
	            detailLevels.push(interior);
	        }
	        let numSubObjects = this.readU32();
	        let subObjects = [];
	        for (let i = 0; i < numSubObjects; i++) {
	            let interior = this.parseInterior();
	            subObjects.push(interior);
	        }
	        return {
	            version: version,
	            previewIncluded: previewIncluded,
	            detailLevels: detailLevels,
	            subObjects: subObjects
	        };
	    }
	    parseInterior() {
	        let interiorFileVersion = this.readU32();
	        let detailLevel = this.readU32();
	        let minPixels = this.readU32();
	        let boundingBox = this.readBox3F();
	        let boundingSphere = this.readSphereF();
	        let hasAlarmState = this.readBool();
	        let numLightStateEntries = this.readU32();
	        let numNormals = this.readU32();
	        let normals = [];
	        for (let i = 0; i < numNormals; i++) {
	            normals.push(this.readPoint3F());
	        }
	        let numPlanes = this.readU32();
	        let planes = [];
	        for (let i = 0; i < numPlanes; i++) {
	            let normalIndex = this.readU16(); // Spec says this is U32, but that produces garbage. Assuming U16.
	            let planeDistance = this.readF32();
	            planes.push({ normalIndex, planeDistance });
	        }
	        let numPoints = this.readU32();
	        let points = [];
	        for (let i = 0; i < numPoints; i++) {
	            points.push(this.readPoint3F());
	        }
	        let numPointVisibilities = this.readU32();
	        let pointVisibilities = [];
	        for (let i = 0; i < numPointVisibilities; i++) {
	            // These are either 255 or 0. Spec says it's either 1 or 0, but I didn't observe that.
	            pointVisibilities.push(this.readU8());
	        }
	        let numTexGenEqs = this.readU32();
	        let texGenEqs = [];
	        for (let i = 0; i < numTexGenEqs; i++) {
	            let planeX = this.readPlaneF(), planeY = this.readPlaneF();
	            texGenEqs.push({ planeX, planeY });
	        }
	        let numBspNodes = this.readU32();
	        let bspNodes = [];
	        for (let i = 0; i < numBspNodes; i++) {
	            let planeIndex = this.readU16(), frontIndex = this.readU16(), // u32 here... sure? mhhh. replaced with u16. but then masking doesn't work...
	            backIndex = this.readU16();
	            bspNodes.push({ planeIndex, frontIndex, backIndex });
	        }
	        let numBspSolidLeaves = this.readU32();
	        let bspSolidLeaves = [];
	        for (let i = 0; i < numBspSolidLeaves; i++) {
	            let surfaceIndex = this.readU32(), surfaceCount = this.readU16();
	            bspSolidLeaves.push({ surfaceIndex, surfaceCount });
	        }
	        let materialList = {};
	        materialList.version = this.readU8();
	        let numMaterials = this.readU32();
	        let materials = [];
	        for (let i = 0; i < numMaterials; i++) {
	            materials.push(this.readString());
	        }
	        materialList.materials = materials;
	        let numWindings = this.readU32();
	        let windings = [];
	        for (let i = 0; i < numWindings; i++) {
	            let pointIndex = this.readU32();
	            windings.push(pointIndex);
	        }
	        let numWindingIndices = this.readU32();
	        let windingIndices = [];
	        for (let i = 0; i < numWindingIndices; i++) {
	            let windingStart = this.readU32(), windingCount = this.readU32();
	            windingIndices.push({ windingStart, windingCount });
	        }
	        let edges = [];
	        // This interior version skips edges anyway, so no need to run this code.
	        /*
	        let numEdges = this.readU32();
	        for (let i = 0; i < numEdges; i++) {
	            let pointIndex0 = this.readS32(), // Only GOD knows why these are signed. THESE DOCS >.<
	                pointIndex1 = this.readS32(),
	                surfaceIndex0 = this.readS32(),
	                surfaceIndex1 = this.readS32();

	            edges.push({ pointIndex0, pointIndex1, surfaceIndex0, surfaceIndex1 });
	        }
	        */
	        let numZones = this.readU32();
	        let zones = [];
	        for (let i = 0; i < numZones; i++) {
	            let portalStart = this.readU16(), portalCount = this.readU16(), surfaceStart = this.readU32(), surfaceCount = this.readU16(), staticMeshStart = 0, staticMeshCount = 0, flags = this.readU16(), zoneId = 0;
	            zones.push({ portalStart, portalCount, surfaceStart, surfaceCount, staticMeshStart, staticMeshCount, flags, zoneId });
	        }
	        let numZoneSurfaces = this.readU32();
	        let zoneSurfaces = []; // List of all surfaces to render
	        for (let i = 0; i < numZoneSurfaces; i++) {
	            zoneSurfaces.push(this.readU16());
	        }
	        // Parse zone static meshes, skipped in this version
	        let numZonePortalList = this.readU32();
	        let zonePortalList = [];
	        for (let i = 0; i < numZonePortalList; i++) {
	            zonePortalList.push(this.readU16());
	        }
	        let numPortals = this.readU32();
	        let portals = [];
	        for (let i = 0; i < numPortals; i++) {
	            let planeIndex = this.readU16(), triFanCount = this.readU16(), triFanStart = this.readU32(), zoneFront = this.readU16(), zoneBack = this.readU16();
	            portals.push({ planeIndex, triFanCount, triFanStart, zoneFront, zoneBack });
	        }
	        let numSurfaces = this.readU32();
	        let surfaces = [];
	        for (let i = 0; i < numSurfaces; i++) {
	            let windingStart = this.readU32(), windingCount = this.readU8(), planeIndex = this.readU16(), textureIndex = this.readU16(), texGenIndex = this.readU32(), surfaceFlags = this.readU8(), fanMask = this.readU32(), lightMapTexGen = this.readLightMapTexGen(), lightCount = this.readU16(), lightStateInfoStart = this.readU32(), mapOffsetX = this.readU8(), // wtf why int?
	            mapOffsetY = this.readU8(), mapSizeX = this.readU8(), mapSizeY = this.readU8();
	            //unused = this.parseBool();
	            surfaces.push({ windingStart, windingCount, planeIndex, textureIndex, texGenIndex, surfaceFlags, fanMask, lightMapTexGen, lightCount, lightStateInfoStart, mapOffsetX, mapOffsetY, mapSizeX, mapSizeY });
	        }
	        let numNormalLMapIndices = this.readU32();
	        let normalLMapIndices = [];
	        for (let i = 0; i < numNormalLMapIndices; i++) {
	            normalLMapIndices.push(this.readU8());
	        }
	        let numAlarmLMapIndices = this.readU32();
	        let alarmLMapIndices = [];
	        for (let i = 0; i < numAlarmLMapIndices; i++) {
	            alarmLMapIndices.push(this.readU8());
	        }
	        let numNullSurfaces = this.readU32();
	        let nullSurfaces = [];
	        for (let i = 0; i < numNullSurfaces; i++) {
	            let windingStart = this.readU32(), planeIndex = this.readU16(), surfaceFlags = this.readU8(), windingCount = this.readU8();
	            nullSurfaces.push({ windingStart, planeIndex, surfaceFlags, windingCount });
	        }
	        let numLightmaps = this.readU32();
	        let lightmaps = [];
	        let lightDirMaps = [];
	        let lightmapKeep = [];
	        for (let i = 0; i < numLightmaps; i++) {
	            let lightmap = this.readPNG();
	            lightmaps.push(lightmap);
	        }
	        let numSolidLeafSurfaces = this.readU32();
	        let solidLeafSurfaces = [];
	        for (let i = 0; i < numSolidLeafSurfaces; i++) {
	            solidLeafSurfaces.push(this.readU32());
	        }
	        let numAnimatedLights = this.readU32();
	        let animatedLights = [];
	        for (let i = 0; i < numAnimatedLights; i++) {
	            let nameIndex = this.readU32(), stateIndex = this.readU32(), stateCount = this.readU16(), flags = this.readU16(), duration = this.readU32();
	            animatedLights.push({ nameIndex, stateIndex, stateCount, flags, duration });
	        }
	        let numLightStates = this.readU32();
	        let lightStates = [];
	        for (let i = 0; i < numLightStates; i++) {
	            let red = this.readU8(), green = this.readU8(), blue = this.readU8(), activeTime = this.readU32(), dataIndex = this.readU32(), dataCount = this.readU16();
	            lightStates.push({ red, green, blue, activeTime, dataIndex, dataCount });
	        }
	        let numLightStateData = this.readU32();
	        let lightStateData = [];
	        for (let i = 0; i < numLightStateData; i++) {
	            let surfaceIndex = this.readU32(), mapIndex = this.readU32(), lightStateIndex = this.readU16();
	            lightStateData.push({ surfaceIndex, mapIndex, lightStateIndex });
	        }
	        let numLightStateDataBuffer = this.readU32();
	        let lightStateDataBufferFlags = this.readU32();
	        let lightStateDataBuffer = [];
	        for (let i = 0; i < numLightStateDataBuffer; i++) {
	            lightStateDataBuffer.push(this.readU8());
	        }
	        let numNameBuffer = this.readU32();
	        let nameBuffer = [];
	        for (let i = 0; i < numNameBuffer; i++) {
	            nameBuffer.push(this.readU8());
	        }
	        let numSubObjects = this.readU32();
	        let subObjects = [];
	        for (let i = 0; i < numSubObjects; i++) {
	            let soKey = this.readU32();
	            subObjects.push({ soKey });
	        }
	        let numConvexHulls = this.readU32();
	        let convexHulls = [];
	        for (let i = 0; i < numConvexHulls; i++) {
	            let hullStart = this.readU32(), hullCount = this.readU16(), minX = this.readF32(), maxX = this.readF32(), minY = this.readF32(), maxY = this.readF32(), minZ = this.readF32(), maxZ = this.readF32(), surfaceStart = this.readU32(), surfaceCount = this.readU16(), planeStart = this.readU32(), polyListPlaneStart = this.readU32(), polyListPointStart = this.readU32(), polyListStringStart = this.readU32(), staticMesh = false;
	            convexHulls.push({ hullStart, hullCount, minX, maxX, minY, maxY, minZ, maxZ, surfaceStart, surfaceCount, planeStart, polyListPlaneStart, polyListPointStart, polyListStringStart, staticMesh });
	        }
	        let numConvexHullEmitStrings = this.readU32();
	        let convexHullEmitStrings = [];
	        for (let i = 0; i < numConvexHullEmitStrings; i++) {
	            convexHullEmitStrings.push(String.fromCharCode(this.readU8()));
	        }
	        let numHullIndices = this.readU32();
	        let hullIndices = [];
	        for (let i = 0; i < numHullIndices; i++) {
	            hullIndices.push(this.readU32());
	        }
	        let numHullPlaneIndices = this.readU32();
	        let hullPlaneIndices = [];
	        for (let i = 0; i < numHullPlaneIndices; i++) {
	            hullPlaneIndices.push(this.readU16());
	        }
	        let numHullEmitStringIndices = this.readU32();
	        let hullEmitStringIndices = [];
	        for (let i = 0; i < numHullEmitStringIndices; i++) {
	            hullEmitStringIndices.push(this.readU32());
	        }
	        let numHullSurfaceIndices = this.readU32();
	        let hullSurfaceIndices = [];
	        for (let i = 0; i < numHullSurfaceIndices; i++) {
	            hullSurfaceIndices.push(this.readU32());
	        }
	        let numPolyListPlanes = this.readU32();
	        let polyListPlanes = [];
	        for (let i = 0; i < numPolyListPlanes; i++) {
	            polyListPlanes.push(this.readU16());
	        }
	        let numPolyListPoints = this.readU32();
	        let polyListPoints = [];
	        for (let i = 0; i < numPolyListPoints; i++) {
	            polyListPoints.push(this.readU32());
	        }
	        let numPolyListStrings = this.readU32();
	        let polyListStrings = [];
	        for (let i = 0; i < numPolyListStrings; i++) {
	            polyListStrings.push(String.fromCharCode(this.readU8()));
	        }
	        let coordBins = [];
	        for (let i = 0; i < NUM_COORD_BINS ** 2; i++) {
	            let binStart = this.readU32(), binCount = this.readU32();
	            coordBins.push({ binStart, binCount });
	        }
	        let numCoordBinIndices = this.readU32();
	        let coordBinIndices = [];
	        for (let i = 0; i < numCoordBinIndices; i++) {
	            coordBinIndices.push(this.readU16());
	        }
	        let coordBinMode = this.readU32();
	        let baseAmbientColor = this.readColorF(), alarmAmbientColor = this.readColorF();
	        // All the following values were 0 in the Marble Blast interiors and are therefore not used.
	        let numStaticMeshes = this.readU32();
	        numNormals = this.readU32();
	        let numTexMatrices = this.readU32();
	        let numTexMatIndices = this.readU32();
	        // It didn't work with the following:
	        /*
	        let extendedLightMapData = this.readU32();

	        if (extendedLightMapData === 1) {
	            let lightMapBorderSize = this.readU32();
	            this.readU32(); // dummy
	        }*/
	        return {
	            interiorFileVersion: interiorFileVersion,
	            detailLevel: detailLevel,
	            minPixels: minPixels,
	            boundingBox: boundingBox,
	            boundingSphere: boundingSphere,
	            hasAlarmState: hasAlarmState,
	            numLightStateEntries: numLightStateEntries,
	            normals: normals,
	            planes: planes,
	            points: points,
	            pointVisibilities: pointVisibilities,
	            texGenEqs: texGenEqs,
	            bspNodes: bspNodes,
	            bspSolidLeaves: bspSolidLeaves,
	            materialList: materialList,
	            windings: windings,
	            windingIndices: windingIndices,
	            edges: edges,
	            zones: zones,
	            zoneSurfaces: zoneSurfaces,
	            zonePortalList: zonePortalList,
	            portals: portals,
	            surfaces: surfaces,
	            normalLMapIndices: normalLMapIndices,
	            alarmLMapIndices: alarmLMapIndices,
	            nullSurfaces: nullSurfaces,
	            lightmaps,
	            lightDirMaps,
	            lightmapKeep,
	            solidLeafSurfaces,
	            animatedLights,
	            lightStates,
	            lightStateData,
	            lightStateDataBufferFlags,
	            lightStateDataBuffer,
	            nameBuffer,
	            subObjects,
	            convexHulls,
	            convexHullEmitStrings,
	            hullIndices,
	            hullPlaneIndices,
	            hullEmitStringIndices,
	            hullSurfaceIndices,
	            polyListPlanes,
	            polyListPoints,
	            polyListStrings,
	            coordBins,
	            coordBinIndices,
	            coordBinMode,
	            baseAmbientColor,
	            alarmAmbientColor
	        };
	    }
	    readLightMapTexGen() {
	        let finalWord = this.readU16(), texGenXDistance = this.readF32(), texGenYDistance = this.readF32();
	        return { finalWord, texGenXDistance, texGenYDistance };
	    }
	    readPNG() {
	        // Naive algorithm right now. Just look for the IEND.
	        let start = this.index;
	        for (this.index; this.index < this.buffer.byteLength; this.index++) {
	            // Finds the IEND
	            if (this.view.getUint8(this.index) === 0x49 && this.view.getUint8(this.index + 1) === 0x45 && this.view.getUint8(this.index + 2) === 0x4E && this.view.getUint8(this.index + 3) === 0x44) {
	                this.index += 4 + 5; // Skip an additional 5 forward
	                return this.buffer.slice(start, this.index);
	            }
	        }
	        throw new Error("PNG reading failed!");
	    }
	    readColorF() {
	        let red = this.readU8(), green = this.readU8(), blue = this.readU8(), alpha = this.readU8();
	        return { red, green, blue, alpha };
	    }
	    /** Loads and parses a .dif file. Returns a cached version if already loaded. */
	    static loadFile(path) {
	        if (this.cachedFiles.get(path))
	            return this.cachedFiles.get(path);
	        let promise = new Promise(async (resolve) => {
	            let blob = await ResourceManager$1.loadResource(path);
	            if (!blob) {
	                resolve(null);
	                return;
	            }
	            let arrayBuffer = await ResourceManager$1.readBlobAsArrayBuffer(blob);
	            let parser = new DifParser(arrayBuffer);
	            let result = parser.parse();
	            resolve(result);
	        });
	        this.cachedFiles.set(path, promise);
	        return promise;
	    }
	}
	DifParser.cachedFiles = new Map();
	//# sourceMappingURL=dif_parser.js.map

	/* eslint-disable @typescript-eslint/no-unused-vars */
	var MeshType;
	(function (MeshType) {
	    MeshType[MeshType["Standard"] = 0] = "Standard";
	    MeshType[MeshType["Skin"] = 1] = "Skin";
	    MeshType[MeshType["Decal"] = 2] = "Decal";
	    MeshType[MeshType["Sorted"] = 3] = "Sorted";
	    MeshType[MeshType["Null"] = 4] = "Null";
	})(MeshType || (MeshType = {}));
	/** A helper construct used by the DTS parser. It keeps 3 indices into one data buffer for reading a stream of 32-bit, 16-bit and 8-bit values, respectively. */
	class Alloc {
	    constructor(buf, start32, start16, start8) {
	        this.lastGuardValue = 0;
	        this.buf = buf;
	        this.view = new DataView(this.buf);
	        this.index32 = start32;
	        this.index16 = start32 + start16 * 4;
	        this.index8 = start32 + start8 * 4;
	    }
	    readU32() {
	        let val = this.view.getUint32(this.index32, true);
	        this.index32 += 4;
	        return val;
	    }
	    readS32() {
	        let val = this.view.getInt32(this.index32, true);
	        this.index32 += 4;
	        return val;
	    }
	    readF32() {
	        let val = this.view.getFloat32(this.index32, true);
	        this.index32 += 4;
	        return val;
	    }
	    readPoint2F() {
	        return {
	            x: this.readF32(),
	            y: this.readF32()
	        };
	    }
	    readPoint3F() {
	        return {
	            x: this.readF32(),
	            y: this.readF32(),
	            z: this.readF32()
	        };
	    }
	    readBoxF() {
	        return {
	            min: this.readPoint3F(),
	            max: this.readPoint3F()
	        };
	    }
	    readU16() {
	        let val = this.view.getUint16(this.index16, true);
	        this.index16 += 2;
	        return val;
	    }
	    readS16() {
	        let val = this.view.getInt16(this.index16, true);
	        this.index16 += 2;
	        return val;
	    }
	    readU8() {
	        let val = this.view.getUint8(this.index8);
	        this.index8 += 1;
	        return val;
	    }
	    readQuat16() {
	        return {
	            x: this.readS16(),
	            y: this.readS16(),
	            z: this.readS16(),
	            w: this.readS16()
	        };
	    }
	    readMatrixF() {
	        return new Array(16).fill(null).map(() => this.readF32());
	    }
	    /** Guards are sequentially increasing numbers in all three buffers which are used to check data integrity. */
	    guard() {
	        let guard32 = this.readU32();
	        let guard16 = this.readU16();
	        let guard8 = this.readU8();
	        if (!(guard32 === guard16 && guard16 === guard8 && guard8 === this.lastGuardValue)) {
	            throw new Error("Guard fail! Expected " + this.lastGuardValue + " but got " + guard32 + " for 32, " + guard16 + " for 16 and " + guard8 + " for 8.");
	        }
	        this.lastGuardValue++;
	    }
	}
	/** Class used for old DTS versions. Is used to build a new buffer in the modern DTS format which is then parsed as usual. */
	class OldAlloc {
	    constructor(sourceView, sourceIndex) {
	        this.sourceIndex = 0;
	        this.index32 = 0;
	        this.index16 = 0;
	        this.index8 = 0;
	        this.nextGuard = 0;
	        this.sourceView = sourceView;
	        this.sourceIndex = sourceIndex;
	        this.buffer32 = new DataView(new ArrayBuffer(25000));
	        this.buffer16 = new DataView(new ArrayBuffer(25000));
	        this.buffer8 = new DataView(new ArrayBuffer(25000));
	    }
	    skip(bytes) {
	        this.sourceIndex += bytes;
	    }
	    allocate32(words) {
	        this.index32 += words * 4;
	    }
	    allocate16(words) {
	        this.index16 += words * 2;
	    }
	    allocate8(words) {
	        this.index8 += words * 1;
	    }
	    copyInto32(count) {
	        for (let i = 0; i < count; i++) {
	            this.buffer32.setUint32(this.index32 + i * 4, this.sourceView.getUint32(this.sourceIndex + i * 4, true), true);
	        }
	        this.sourceIndex += count * 4;
	        this.index32 += count * 4;
	    }
	    copyInto16(count) {
	        for (let i = 0; i < count; i++) {
	            this.buffer16.setUint16(this.index16 + i * 2, this.sourceView.getUint16(this.sourceIndex + i * 2, true), true);
	        }
	        this.sourceIndex += count * 2;
	        this.index16 += count * 2;
	    }
	    copyInto8(count) {
	        for (let i = 0; i < count * 1; i++) {
	            this.buffer8.setUint8(this.index8 + i * 1, this.sourceView.getUint8(this.sourceIndex + i * 1));
	        }
	        this.sourceIndex += count * 1;
	        this.index8 += count * 1;
	    }
	    readS32(storeIndex = this.index32 / 4) {
	        let val = this.sourceView.getInt32(this.sourceIndex, true);
	        this.sourceIndex += 4;
	        if (storeIndex !== null) {
	            this.buffer32.setInt32(storeIndex * 4, val, true);
	            if (storeIndex * 4 === this.index32)
	                this.index32 += 4;
	        }
	        return val;
	    }
	    writeS32(value) {
	        this.buffer32.setInt32(this.index32, value, true);
	        this.index32 += 4;
	    }
	    writeU8(value) {
	        this.buffer8.setUint8(this.index8, value);
	        this.index8 += 1;
	    }
	    guard() {
	        this.buffer32.setUint32(this.index32, this.nextGuard, true);
	        this.buffer16.setUint16(this.index16, this.nextGuard, true);
	        this.buffer8.setUint8(this.index8, this.nextGuard);
	        this.nextGuard++;
	        this.index32 += 4;
	        this.index16 += 2;
	        this.index8 += 1;
	    }
	    createBuffer() {
	        // Make sure they're all a multiple of 4 long
	        this.index16 = Math.ceil(this.index16 / 4) * 4;
	        this.index8 = Math.ceil(this.index8 / 4) * 4;
	        let buffer = new ArrayBuffer(this.index32 + this.index16 + this.index8);
	        let typed = new Uint8Array(buffer);
	        let index = 0;
	        // Concat everything
	        for (let i = 0; i < this.index32; i++) {
	            typed[index++] = this.buffer32.getUint8(i);
	        }
	        for (let i = 0; i < this.index16; i++) {
	            typed[index++] = this.buffer16.getUint8(i);
	        }
	        for (let i = 0; i < this.index8; i++) {
	            typed[index++] = this.buffer8.getUint8(i);
	        }
	        return { buffer, start16: this.index32 / 4, start8: (this.index32 + this.index16) / 4 };
	    }
	}
	/** A parser for .dts files, used for static shapes and items. Main resources are http://docs.garagegames.com/torque-3d/official/content/documentation/Artist%20Guide/Formats/dts_format.html#:~:text=DTS%20is%20the%20native%20binary,and%20(optionally)%20sequence%20data.&text=The%20DTS%20file%20format%20stores,loading%20on%20non%2DIntel%20platforms. and the Torque 3D source. */
	class DtsParser extends BinaryFileParser {
	    parse(stopAfterMaterials = false) {
	        let version = this.readU16();
	        let exporterVersion = this.readU16();
	        let memBuffer;
	        let start32;
	        let start16;
	        let start8;
	        let sequences;
	        let materialList;
	        if (version < 19) {
	            // We're dealing with an old DTS version; create a new buffer first.
	            let result = this.readOldShape(version);
	            memBuffer = result.bufferInfo.buffer;
	            start32 = 0;
	            start16 = result.bufferInfo.start16;
	            start8 = result.bufferInfo.start8;
	            sequences = result.sequences;
	            materialList = result.materialList;
	        }
	        else {
	            let sizeMemBuffer = this.readU32();
	            memBuffer = this.buffer;
	            start16 = this.readU32();
	            start8 = this.readU32();
	            start32 = this.index;
	            this.index += sizeMemBuffer * 4;
	            let numSequences = this.readS32();
	            sequences = [];
	            for (let i = 0; i < numSequences; i++) {
	                sequences.push(this.parseSequence());
	            }
	            materialList = this.parseMaterialList(version);
	        }
	        let shape = {};
	        if (!stopAfterMaterials) {
	            let alloc = new Alloc(memBuffer, start32, start16, start8);
	            shape = this.assembleShape(alloc, version);
	        }
	        let obj = {
	            version,
	            exporterVersion,
	            sequences
	        };
	        obj = Object.assign(obj, materialList); // Merge in the material list
	        obj = Object.assign(obj, shape); // Merge the rest of the shape data
	        return obj; // The type is fucked anyway, just go with any.
	    }
	    assembleShape(alloc, version) {
	        let numNodes = alloc.readS32();
	        let numObjects = alloc.readS32();
	        let numDecals = alloc.readS32();
	        let numSubShapes = alloc.readS32();
	        let numIflMaterials = alloc.readS32();
	        let numNodeRots;
	        let numNodeTrans;
	        let numNodeUniformScales;
	        let numNodeAlignedScales;
	        let numNodeArbitraryScales;
	        if (version < 22) {
	            numNodeRots = numNodeTrans = alloc.readS32() - numNodes;
	            numNodeUniformScales = numNodeAlignedScales = numNodeArbitraryScales = 0;
	        }
	        else {
	            numNodeRots = alloc.readS32();
	            numNodeTrans = alloc.readS32();
	            numNodeUniformScales = alloc.readS32();
	            numNodeAlignedScales = alloc.readS32();
	            numNodeArbitraryScales = alloc.readS32();
	        }
	        let numGroundFrames = 0;
	        if (version > 23)
	            numGroundFrames = alloc.readS32();
	        let numObjectStates = alloc.readS32();
	        let numDecalStates = alloc.readS32();
	        let numTriggers = alloc.readS32();
	        let numDetails = alloc.readS32();
	        let numMeshes = alloc.readS32();
	        let numSkins = 0; // Skins are apparently deprecated
	        if (version < 23)
	            numSkins = alloc.readS32();
	        let numNames = alloc.readS32();
	        let smallestVisibleSize = alloc.readF32();
	        let smallestVisibleDL = alloc.readS32();
	        alloc.guard();
	        let radius = alloc.readF32();
	        let tubeRadius = alloc.readF32();
	        let center = alloc.readPoint3F();
	        let bounds = alloc.readBoxF();
	        alloc.guard();
	        let nodeIndex = 0;
	        let nodes = Array(numNodes).fill(null).map(() => {
	            return {
	                index: nodeIndex++,
	                nameIndex: alloc.readS32(),
	                parentIndex: alloc.readS32(),
	                firstObject: alloc.readS32(),
	                firstChild: alloc.readS32(),
	                nextSibling: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let objects = Array(numObjects).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                numMeshes: alloc.readS32(),
	                startMeshIndex: alloc.readS32(),
	                nodeIndex: alloc.readS32(),
	                nextSibling: alloc.readS32(),
	                firstDecal: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let decals = Array(numDecals).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                numMeshes: alloc.readS32(),
	                startMeshIndex: alloc.readS32(),
	                objectIndex: alloc.readS32(),
	                nextSibling: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let iflMaterials = Array(numIflMaterials).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                materialSlot: alloc.readS32(),
	                firstFrame: alloc.readS32(),
	                firstFrameOffTimeIndex: alloc.readS32(),
	                numFrames: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let subShapeFirstNode = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeFirstObject = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeFirstDecal = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        alloc.guard();
	        let subShapeNumNodes = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeNumObjects = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        let subShapeNumDecals = Array(numSubShapes).fill(null).map(() => alloc.readS32());
	        alloc.guard();
	        //let subShapeFirstTranslucentObject = Array(numSubShapes).fill(null).map(() => alloc.getS32());
	        // Works only without? Confus!!
	        let defaultRotations = Array(numNodes).fill(null).map(() => alloc.readQuat16());
	        let defaultTranslations = Array(numNodes).fill(null).map(() => alloc.readPoint3F());
	        let nodeRotations = Array(numNodeRots).fill(null).map(() => alloc.readQuat16());
	        let nodeTranslations = Array(numNodeTrans).fill(null).map(() => alloc.readPoint3F());
	        alloc.guard();
	        let nodeUniformScales = [];
	        let nodeAlignedScales = [];
	        let nodeArbScaleFactors = [];
	        let nodeArbScaleRots = [];
	        if (version > 21) {
	            nodeUniformScales = Array(numNodeUniformScales).fill(null).map(() => alloc.readF32());
	            nodeAlignedScales = Array(numNodeAlignedScales).fill(null).map(() => alloc.readPoint3F());
	            nodeArbScaleFactors = Array(numNodeArbitraryScales).fill(null).map(() => alloc.readPoint3F());
	            nodeArbScaleRots = Array(numNodeArbitraryScales).fill(null).map(() => alloc.readQuat16());
	            alloc.guard();
	        }
	        // Super old version stuff would go here
	        let groundTranslations = Array(numGroundFrames).fill(null).map(() => alloc.readPoint3F());
	        let groundRotations = Array(numGroundFrames).fill(null).map(() => alloc.readQuat16());
	        if (version > 23)
	            alloc.guard(); // 😂
	        let objectStates = Array(numObjectStates).fill(null).map(() => {
	            return {
	                vis: alloc.readF32(),
	                frameIndex: alloc.readS32(),
	                matFrame: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let decalStates = Array(numDecalStates).fill(null).map(() => alloc.readS32());
	        alloc.guard();
	        let triggers = Array(numTriggers).fill(null).map(() => {
	            return {
	                state: alloc.readU32(),
	                pos: alloc.readF32()
	            };
	        });
	        alloc.guard();
	        let details = Array(numDetails).fill(null).map(() => {
	            return {
	                nameIndex: alloc.readS32(),
	                subShapeNum: alloc.readS32(),
	                objectDetailNum: alloc.readS32(),
	                size: alloc.readF32(),
	                averageError: alloc.readF32(),
	                maxError: alloc.readF32(),
	                polyCount: alloc.readS32()
	            };
	        });
	        alloc.guard();
	        let meshes = [];
	        for (let i = 0; i < numMeshes; i++) {
	            let type = alloc.readU32();
	            if (type === MeshType.Null) {
	                // Null meshes are simply skipped
	                meshes.push(null);
	                continue;
	            }
	            alloc.guard();
	            let numFrames = alloc.readS32();
	            let numMatFrames = alloc.readS32();
	            let parentMesh = alloc.readS32();
	            let bounds = alloc.readBoxF();
	            let center = alloc.readPoint3F();
	            let radius = alloc.readF32();
	            let numVerts = alloc.readS32();
	            let verts = (parentMesh < 0) ? Array(numVerts).fill(null).map(() => alloc.readPoint3F()) : meshes[parentMesh].verts;
	            let numTVerts = alloc.readS32();
	            let tverts = (parentMesh < 0) ? Array(numTVerts).fill(null).map(() => alloc.readPoint2F()) : meshes[parentMesh].tverts;
	            let norms = (parentMesh < 0) ? Array(numVerts).fill(null).map(() => alloc.readPoint3F()) : meshes[parentMesh].norms;
	            let encodedNorms = [];
	            if (version > 21)
	                encodedNorms = (parentMesh < 0) ? Array(numVerts).fill(null).map(() => alloc.readU8()) : meshes[parentMesh].encodedNorms;
	            let numPrimitives = alloc.readS32();
	            let primitives = Array(numPrimitives).fill(null).map(() => {
	                return {
	                    start: alloc.readU16(),
	                    numElements: alloc.readU16(),
	                    matIndex: alloc.readU32()
	                };
	            });
	            let numIndices = alloc.readS32();
	            let indices = Array(numIndices).fill(null).map(() => alloc.readS16());
	            let numMergeIndices = alloc.readS32();
	            let mergeIndices = Array(numMergeIndices).fill(null).map(() => alloc.readS16());
	            let vertsPerFrame = alloc.readS32();
	            let flags = alloc.readS32();
	            alloc.guard();
	            let mesh = {
	                type,
	                numFrames,
	                numMatFrames,
	                parentMesh,
	                bounds,
	                center,
	                radius,
	                verts,
	                tverts,
	                norms,
	                encodedNorms,
	                primitives,
	                indices,
	                mergeIndices,
	                vertsPerFrame,
	                flags
	            };
	            if (type === MeshType.Skin) {
	                // A skinned mesh comes with additional properties describing the bones and skin of the mesh.
	                let numInitialVerts = alloc.readS32();
	                let initialVerts = Array(numInitialVerts).fill(null).map(() => alloc.readPoint3F());
	                let initialNorms = Array(numInitialVerts).fill(null).map(() => alloc.readPoint3F());
	                let encodedNorms = Array(numInitialVerts).fill(null).map(() => alloc.readU8());
	                let numInitialTransforms = alloc.readS32();
	                let initialTransforms = Array(numInitialTransforms).fill(null).map(() => alloc.readMatrixF());
	                let numVertIndices = alloc.readS32();
	                let vertIndices = Array(numVertIndices).fill(null).map(() => alloc.readS32());
	                let boneIndices = Array(numVertIndices).fill(null).map(() => alloc.readS32());
	                let weights = Array(numVertIndices).fill(null).map(() => alloc.readF32());
	                let numNodeIndices = alloc.readS32();
	                let nodeIndices = Array(numNodeIndices).fill(null).map(() => alloc.readS32());
	                mesh.verts = initialVerts;
	                mesh.norms = initialNorms;
	                mesh.encodedNorms = encodedNorms;
	                mesh.initialTransforms = initialTransforms;
	                mesh.vertIndices = vertIndices;
	                mesh.boneIndices = boneIndices;
	                mesh.weights = weights;
	                mesh.nodeIndices = nodeIndices;
	                alloc.guard();
	            }
	            meshes.push(mesh);
	        }
	        alloc.guard();
	        let names = [];
	        for (let i = 0; i < numNames; i++) {
	            let str = "";
	            while (true) {
	                let newCharCode = alloc.readU8();
	                if (newCharCode === 0)
	                    break; // Null-terminated string
	                str += String.fromCharCode(newCharCode);
	            }
	            names.push(str);
	        }
	        alloc.guard();
	        let alphaIn = new Array(numDetails).fill(null).map(() => alloc.readF32());
	        let alphaOut = new Array(numDetails).fill(null).map(() => alloc.readF32());
	        return {
	            smallestVisibleSize,
	            radius,
	            tubeRadius,
	            center,
	            bounds,
	            nodes,
	            objects,
	            decals,
	            iflMaterials,
	            subShapeFirstNode,
	            subShapeFirstObject,
	            subShapeFirstDecal,
	            subShapeNumNodes,
	            subShapeNumObjects,
	            subShapeNumDecals,
	            defaultRotations,
	            defaultTranslations,
	            nodeRotations,
	            nodeTranslations,
	            nodeUniformScales,
	            nodeAlignedScales,
	            nodeArbScaleFactors,
	            nodeArbScaleRots,
	            groundTranslations,
	            groundRotations,
	            objectStates,
	            decalStates,
	            triggers,
	            details,
	            meshes,
	            names,
	            alphaIn,
	            alphaOut
	        };
	    }
	    parseSequence() {
	        /// A Sequence holds all the information necessary to perform a particular animation (sequence).
	        ///
	        /// Sequences index a range of keyframes. Keyframes are assumed to be equally spaced in time.
	        ///
	        /// Each node and object is either a member of the sequence or not.  If not, they are set to
	        /// default values when we switch to the sequence unless they are members of some other active sequence.
	        /// Blended sequences "add" a transform to the current transform of a node.  Any object animation of
	        /// a blended sequence over-rides any existing object state.  Blended sequences are always
	        /// applied after non-blended sequences.
	        let nameIndex = this.readS32();
	        let flags = this.readU32();
	        let numKeyframes = this.readS32();
	        let duration = this.readF32();
	        let priority = this.readS32();
	        let firstGroundFrame = this.readS32();
	        let numGroundFrames = this.readS32();
	        let baseRotation = this.readS32();
	        let baseTranslation = this.readS32();
	        let baseScale = this.readS32();
	        let baseObjectState = this.readS32();
	        let baseDecalState = this.readS32();
	        let firstTrigger = this.readS32();
	        let numTriggers = this.readS32();
	        let toolBegin = this.readF32();
	        let rotationMatters = this.readBitSet();
	        let translationMatters = this.readBitSet();
	        let scaleMatters = this.readBitSet();
	        let decalMatters = this.readBitSet();
	        let iflMatters = this.readBitSet();
	        let visMatters = this.readBitSet();
	        let frameMatters = this.readBitSet();
	        let matFrameMatters = this.readBitSet();
	        return {
	            nameIndex,
	            flags,
	            numKeyframes,
	            duration,
	            priority,
	            firstGroundFrame,
	            numGroundFrames,
	            baseRotation,
	            baseTranslation,
	            baseScale,
	            baseObjectState,
	            baseDecalState,
	            firstTrigger,
	            numTriggers,
	            toolBegin,
	            rotationMatters,
	            translationMatters,
	            scaleMatters,
	            decalMatters,
	            iflMatters,
	            visMatters,
	            frameMatters,
	            matFrameMatters
	        };
	    }
	    /** Parses a Torque MaterialList. */
	    parseMaterialList(version) {
	        let matStreamType = this.readS8(); // Should be 1 always
	        let numMaterials = this.readS32();
	        let matNames = Array(numMaterials).fill(null).map(x => this.readString());
	        let matFlags = Array(numMaterials).fill(null).map(x => this.readU32());
	        let matReflectanceMaps = Array(numMaterials).fill(null).map(x => this.readS32());
	        let matBumpMaps = Array(numMaterials).fill(null).map(x => this.readS32());
	        let matDetailMaps = Array(numMaterials).fill(null).map(x => this.readS32());
	        if (version === 25)
	            Array(numMaterials).fill(null).map(x => this.readS32()); // dummy
	        let matDetailScales = Array(numMaterials).fill(null).map(x => this.readF32());
	        let matReflectance = Array(numMaterials).fill(null).map(x => this.readF32());
	        return {
	            matNames,
	            matFlags,
	            matReflectanceMaps,
	            matBumpMaps,
	            matDetailMaps,
	            matDetailScales,
	            matReflectance
	        };
	    }
	    readBitSet() {
	        this.index += 4; // dummy
	        let numWords = this.readS32();
	        let words = [];
	        for (let i = 0; i < numWords; i++) {
	            words.push(this.readU32());
	        }
	        return words;
	    }
	    /** Reads an old shape. Creates a new buffer in the new DTS format that is then fed into the regular parser. Refer to the TGE source for more detail. */
	    readOldShape(version) {
	        let oldAlloc = new OldAlloc(this.view, this.index);
	        oldAlloc.allocate32(15);
	        oldAlloc.guard();
	        oldAlloc.copyInto32(1); // Radius
	        oldAlloc.copyInto32(1); // Tube radius
	        oldAlloc.copyInto32(3); // Center
	        oldAlloc.copyInto32(6); // Bounds
	        oldAlloc.guard();
	        let numNodes = oldAlloc.readS32(0);
	        for (let i = 0; i < numNodes; i++) {
	            oldAlloc.copyInto32(2);
	            oldAlloc.allocate32(3);
	        }
	        oldAlloc.guard();
	        let numObjects = oldAlloc.readS32(1);
	        for (let i = 0; i < numObjects; i++) {
	            oldAlloc.copyInto32(4);
	            oldAlloc.allocate32(2);
	        }
	        oldAlloc.guard();
	        let numDecals = oldAlloc.readS32(2);
	        for (let i = 0; i < numDecals; i++) {
	            oldAlloc.copyInto32(4);
	            oldAlloc.allocate32(1);
	        }
	        oldAlloc.guard();
	        let numIflMaterials = oldAlloc.readS32(4);
	        for (let i = 0; i < numIflMaterials; i++) {
	            oldAlloc.copyInto32(2);
	            oldAlloc.allocate32(3);
	        }
	        oldAlloc.guard();
	        let numSubShapes = oldAlloc.readS32(3);
	        let subShapeFirstStart = oldAlloc.index32;
	        oldAlloc.copyInto32(numSubShapes); // subShapeFirstNode
	        oldAlloc.skip(4); // toss
	        oldAlloc.copyInto32(numSubShapes); // subShapeFirstObject
	        oldAlloc.skip(4); // toss
	        oldAlloc.copyInto32(numSubShapes); // subShapeFirstDecal
	        oldAlloc.guard();
	        let subShapeNumStart = oldAlloc.index32;
	        oldAlloc.allocate32(3 * numSubShapes);
	        oldAlloc.guard();
	        // compute subShapeNum* vectors
	        let prev, first;
	        for (let i = 0; i < 3; i++) {
	            prev = ((i === 0) ? numNodes : (i === 1 ? numObjects : numDecals));
	            for (let j = numSubShapes - 1; j >= 0; j--) {
	                first = oldAlloc.buffer32.getInt32(subShapeFirstStart + j * 4, true);
	                oldAlloc.buffer32.setInt32(subShapeNumStart + j * 4, prev - first, true);
	                prev = first;
	            }
	            subShapeFirstStart += numSubShapes;
	            subShapeNumStart += numSubShapes;
	        }
	        let numNodeStates = oldAlloc.readS32(5);
	        for (let i = 0; i < numNodeStates; i++) {
	            oldAlloc.copyInto16(4); // read Quat16....rotation
	            oldAlloc.copyInto32(3); // read Point3F...translation
	        }
	        oldAlloc.guard();
	        let numObjectStates = oldAlloc.readS32(6);
	        oldAlloc.copyInto32(numObjectStates * 3);
	        oldAlloc.guard();
	        let numDecalStates = oldAlloc.readS32(7);
	        oldAlloc.copyInto32(numDecalStates);
	        oldAlloc.guard();
	        let numTriggers = oldAlloc.readS32(8);
	        oldAlloc.copyInto32(numTriggers * 2);
	        oldAlloc.guard();
	        let numDetails = oldAlloc.readS32(9);
	        for (let i = 0; i < numDetails; i++) {
	            oldAlloc.copyInto32(4);
	            oldAlloc.allocate32(3);
	        }
	        // There's some added detail filling-up code here, but we don't use these anyways. Screw it.
	        oldAlloc.guard();
	        this.index = oldAlloc.sourceIndex;
	        let numSequences = this.readS32();
	        let sequences = [];
	        for (let i = 0; i < numSequences; i++) {
	            let sequence = this.parseSequence();
	            sequences.push(sequence);
	        }
	        oldAlloc.sourceIndex = this.index;
	        let numMeshes = oldAlloc.readS32(10);
	        for (let i = 0; i < numMeshes; i++) {
	            let meshType = oldAlloc.readS32();
	            this.readAllocMesh(oldAlloc, meshType);
	        }
	        oldAlloc.guard();
	        let numNames = oldAlloc.readS32(12);
	        for (let i = 0; i < numNames; i++) {
	            let length = oldAlloc.readS32(null);
	            oldAlloc.copyInto8(length);
	            oldAlloc.writeU8(0); // end the string
	        }
	        oldAlloc.guard();
	        let materialList = null;
	        this.index = oldAlloc.sourceIndex;
	        let gotList = this.readS32();
	        if (gotList) {
	            materialList = this.parseMaterialList(version);
	        }
	        oldAlloc.sourceIndex = this.index;
	        // Note: There would still be some skinned mesh or whatever code following this, but really, that's totally unnecessary. To prevent stupid "read out of range" errors when reading this buffer, we just add some extra bit to the end. Done.
	        oldAlloc.allocate32(16);
	        return {
	            bufferInfo: oldAlloc.createBuffer(),
	            sequences: sequences,
	            materialList: materialList
	        };
	    }
	    readAllocMesh(oldAlloc, meshType) {
	        if (meshType === MeshType.Null)
	            return;
	        oldAlloc.guard();
	        // numFrames, numMatFrames
	        oldAlloc.copyInto32(2);
	        // parentMesh
	        oldAlloc.writeS32(-1);
	        // allocate memory for mBounds,mCenter, and mRadius...just filler, will be computed later
	        oldAlloc.allocate32(10);
	        // read in verts
	        let numVerts = oldAlloc.readS32();
	        oldAlloc.copyInto32(numVerts * 3);
	        // read in tverts
	        let numTverts = oldAlloc.readS32();
	        oldAlloc.copyInto32(numTverts * 2);
	        // read in normals
	        let numNormals = oldAlloc.readS32(null); // we could assume same as verts, but apparently in file.
	        oldAlloc.copyInto32(numNormals * 3);
	        // read in primitives
	        let numPrimitives = oldAlloc.readS32();
	        for (let i = 0; i < numPrimitives; i++) {
	            oldAlloc.copyInto16(2);
	            oldAlloc.copyInto32(1);
	        }
	        // read in indices
	        let numIndices = oldAlloc.readS32();
	        oldAlloc.copyInto16(numIndices);
	        // mergeIndices...none
	        oldAlloc.writeS32(0);
	        // vertsPerFrame, flags
	        oldAlloc.copyInto32(2);
	        oldAlloc.guard();
	        if (meshType === MeshType.Skin) {
	            let numInitialVerts = oldAlloc.readS32();
	            oldAlloc.copyInto32(numInitialVerts * 3);
	            let numInitialNorms = oldAlloc.readS32(null); // we assume same as verts
	            oldAlloc.copyInto32(numInitialNorms * 3);
	            let numInitialTransforms = oldAlloc.readS32();
	            oldAlloc.copyInto32(numInitialTransforms * 16);
	            let numVertIndices = oldAlloc.readS32();
	            oldAlloc.copyInto32(numVertIndices);
	            let numBoneIndices = oldAlloc.readS32(null);
	            oldAlloc.copyInto32(numBoneIndices);
	            let weightStart = oldAlloc.index32;
	            oldAlloc.allocate32(numBoneIndices); // this is memory for the weights
	            let numNodeIndices = oldAlloc.readS32();
	            oldAlloc.copyInto32(numNodeIndices);
	            let returnToIndex = oldAlloc.index32;
	            let numWeights = oldAlloc.readS32(null);
	            oldAlloc.index32 = weightStart;
	            oldAlloc.copyInto32(numWeights);
	            oldAlloc.index32 = returnToIndex;
	            oldAlloc.guard();
	        }
	    }
	    /** Loads and parses a .dts file. Returns a cached version if already loaded. */
	    static loadFile(path) {
	        if (this.cachedFiles.get(path))
	            return this.cachedFiles.get(path);
	        let promise = new Promise(async (resolve, reject) => {
	            let blob = await ResourceManager$1.loadResource(path);
	            if (!blob) {
	                reject("Missing resource: " + path);
	                return;
	            }
	            let arrayBuffer = await ResourceManager$1.readBlobAsArrayBuffer(blob);
	            let parser = new DtsParser(arrayBuffer);
	            let result = parser.parse();
	            resolve(result);
	        });
	        this.cachedFiles.set(path, promise);
	        return promise;
	    }
	}
	DtsParser.cachedFiles = new Map();
	//# sourceMappingURL=dts_parser.js.map

	/** Represents a playable mission. Contains all the necessary metadata, as well as methods for loading the mission and gettings its resources. */
	class Mission {
	    constructor(path, misFile) {
	        this.qualifyTime = Infinity;
	        this.goldTime = -Infinity; // Doubles as platinum time
	        this.ultimateTime = -Infinity;
	        this.type = 'custom';
	        this.zipDirectory = null;
	        this.fileToBlobPromises = new Map();
	        this.difCache = new Map();
	        this.isNew = false;
	        this.hasEasterEgg = false;
	        this.hasBlast = false;
	        this.hasUltraMarble = false;
	        this.path = path;
	        this.misFile = misFile;
	        if (misFile) {
	            this.root = misFile.root;
	            this.initAllElements();
	        }
	    }
	    /** Creates a new Mission from a .mis file. */
	    static fromMisFile(path, misFile) {
	        var _a, _b;
	        let mission = new Mission(path, misFile);
	        let missionInfo = mission.allElements.find(element => element._type === MissionElementType$1.ScriptObject && element._name === 'MissionInfo');
	        mission.missionInfo = missionInfo;
	        mission.title = missionInfo.name;
	        mission.artist = (_a = missionInfo.artist) !== null && _a !== void 0 ? _a : '';
	        mission.description = (_b = missionInfo.desc) !== null && _b !== void 0 ? _b : '';
	        if (missionInfo.time && missionInfo.time !== "0")
	            mission.qualifyTime = MisParser$1.parseNumber(missionInfo.time);
	        if (missionInfo.goldtime)
	            mission.goldTime = MisParser$1.parseNumber(missionInfo.goldtime);
	        if (missionInfo.platinumtime)
	            mission.goldTime = MisParser$1.parseNumber(missionInfo.platinumtime);
	        if (missionInfo.ultimatetime)
	            mission.ultimateTime = MisParser$1.parseNumber(missionInfo.ultimatetime);
	        mission.type = missionInfo.type.toLowerCase();
	        mission.modification = path.startsWith('mbp/') ? 'platinum' : path.startsWith('mbu/') ? 'ultra' : 'gold';
	        mission.hasEasterEgg = mission.allElements.some(element => { var _a; return element._type === MissionElementType$1.Item && ((_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'easteregg'; });
	        mission.setUltraFlags();
	        return mission;
	    }
	    static fromOfficialMissionDescription(description) {
	        var _a, _b;
	        let mission = new Mission(description.path);
	        mission.misPath = description.misPath;
	        mission.title = description.name;
	        mission.artist = (_a = description.artist) !== null && _a !== void 0 ? _a : '';
	        mission.description = (_b = description.desc) !== null && _b !== void 0 ? _b : '';
	        if (description.qualifyingTime)
	            mission.qualifyTime = description.qualifyingTime;
	        if (description.goldTime !== undefined)
	            mission.goldTime = description.goldTime;
	        if (description.platinumTime !== undefined)
	            mission.goldTime = description.platinumTime;
	        if (description.ultimateTime !== undefined)
	            mission.ultimateTime = description.ultimateTime;
	        mission.type = description.type.toLowerCase();
	        mission.modification = description.path.startsWith('mbp/') ? 'platinum' : description.path.startsWith('mbu/') ? 'ultra' : 'gold';
	        mission.hasEasterEgg = description.hasEasterEgg;
	        return mission;
	    }
	    /** Creates a new mission from a CLA entry. */
	    static fromCLAEntry(entry, isNew) {
	        var _a, _b;
	        let path = 'custom/' + entry.id;
	        if (entry.modification === 'platinum')
	            path = 'mbp/' + path;
	        if (entry.modification === 'ultra')
	            path = 'mbu/' + path;
	        let mission = new Mission(path);
	        mission.title = entry.name.trim();
	        mission.artist = (_a = entry.artist) !== null && _a !== void 0 ? _a : '';
	        mission.description = (_b = entry.desc) !== null && _b !== void 0 ? _b : '';
	        if (entry.qualifyingTime)
	            mission.qualifyTime = entry.qualifyingTime;
	        if (entry.goldTime)
	            mission.goldTime = entry.goldTime;
	        if (entry.platinumTime)
	            mission.goldTime = entry.platinumTime;
	        if (entry.ultimateTime)
	            mission.ultimateTime = entry.ultimateTime;
	        mission.id = entry.id;
	        mission.isNew = isNew;
	        mission.modification = entry.modification;
	        mission.hasEasterEgg = entry.hasEasterEgg;
	        return mission;
	    }
	    initAllElements() {
	        this.allElements = [];
	        const traverse = (simGroup) => {
	            for (let element of simGroup.elements) {
	                this.allElements.push(element);
	                if (element._type === MissionElementType$1.SimGroup)
	                    traverse(element);
	            }
	        };
	        traverse(this.root);
	    }
	    initSearchString(index) {
	        // Just the title and artist for now
	        this.searchString = Util$1.removeSpecialCharacters(Util$1.normalizeString(this.title + ' ' + this.artist + ' ' + (index + 1))).toLowerCase().trim();
	    }
	    /** Loads this mission for gameplay. */
	    async load() {
	        if (this.misFile)
	            return; // We already have the .mis file, we don't need to do anything
	        if (this.type === 'custom') {
	            // Get the zip archive
	            let blob = await ResourceManager$1.loadResource(`./api/custom/${this.id}.zip`);
	            let arrayBuffer = await ResourceManager$1.readBlobAsArrayBuffer(blob);
	            let zip = await JSZip.loadAsync(arrayBuffer); // Unzip the thing
	            this.zipDirectory = zip;
	            // Normalize filenames within the zip
	            for (let filename in zip.files) {
	                let val = zip.files[filename];
	                delete zip.files[filename];
	                zip.files[filename.toLowerCase()] = val;
	                zip.files[filename.toLowerCase().replace('data/', 'data_mbp/')] = val; // Alias every data/ with a data_mbp/ entry
	                if (this.modification === 'gold' && filename.includes('interiors_mbg/')) {
	                    // Create an alias in interiors
	                    zip.files[filename.replace('interiors_mbg/', 'interiors/')] = val;
	                }
	            }
	            // Read the .mis file
	            let missionFileName = Object.keys(zip.files).find(x => x.endsWith('.mis'));
	            let text = await ResourceManager$1.readBlobAsText(await zip.files[missionFileName].async('blob'), 'ISO-8859-1');
	            let parser = new MisParser$1(text);
	            this.misFile = parser.parse();
	        }
	        else {
	            let text = await ResourceManager$1.readBlobAsText(await ResourceManager$1.loadResource('./assets/' + this.misPath), 'ISO-8859-1');
	            let parser = new MisParser$1(text);
	            this.misFile = parser.parse();
	        }
	        this.root = this.misFile.root;
	        this.initAllElements();
	        // Set up some metadata
	        let missionInfo = this.allElements.find(x => x._type === MissionElementType$1.ScriptObject && x._name === "MissionInfo");
	        if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.time) {
	            this.qualifyTime = MisParser$1.parseNumber(missionInfo.time);
	            if (!this.qualifyTime)
	                this.qualifyTime = Infinity; // Catches both 0 and NaN cases
	        }
	        if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.goldtime) {
	            this.goldTime = MisParser$1.parseNumber(missionInfo.goldtime);
	            if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.platinumtime)
	                this.goldTime = MisParser$1.parseNumber(missionInfo.platinumtime);
	            if (!this.goldTime) { // Again, catches both 0 and NaN cases
	                this.goldTime = -Infinity;
	            }
	        }
	        if (missionInfo === null || missionInfo === void 0 ? void 0 : missionInfo.ultimatetime) {
	            this.ultimateTime = MisParser$1.parseNumber(missionInfo.ultimatetime);
	            if (!this.ultimateTime) { // Again again, catches both 0 and NaN cases
	                this.ultimateTime = -Infinity;
	            }
	        }
	        this.missionInfo = missionInfo;
	        this.setUltraFlags();
	    }
	    setUltraFlags() {
	        var _a, _b;
	        if (!MisParser$1.parseBoolean(this.missionInfo.noblast) && (MisParser$1.parseBoolean(this.missionInfo.blast) || ((_a = this.missionInfo.game) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'ultra'))
	            this.hasBlast = true;
	        if (((_b = this.missionInfo.game) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'ultra' || MisParser$1.parseBoolean(this.missionInfo.useultramarble))
	            this.hasUltraMarble = true;
	    }
	    getDirectoryMissionPath() {
	        if (this.modification === 'gold')
	            return 'missions/' + this.path;
	        if (this.modification === 'ultra')
	            return 'missions_mbu/' + this.path.slice(4);
	        if (this.modification === 'platinum')
	            return 'missions_mbp/' + this.path.slice(4);
	    }
	    /** Gets the path of the image of a mission. */
	    getImagePath() {
	        if (this.type !== 'custom') {
	            let directoryMissionPath = this.getDirectoryMissionPath();
	            if (G$1.modification !== 'gold')
	                directoryMissionPath = directoryMissionPath.replace('missions/', 'missions_mbg/');
	            let withoutExtension = directoryMissionPath.slice(0, -4);
	            let imagePaths = ResourceManager$1.getFullNamesOf(withoutExtension, G$1.modification !== 'gold');
	            let imagePath;
	            for (let path of imagePaths) {
	                if (!path.endsWith('.mis')) {
	                    imagePath = path;
	                    break;
	                }
	            }
	            let res = directoryMissionPath.slice(0, directoryMissionPath.lastIndexOf('/') + 1) + imagePath;
	            if (G$1.modification === 'gold')
	                return "./assets/data/" + res;
	            return "./assets/data_mbp/" + res;
	        }
	        else {
	            // Request the bitmap
	            return `./api/custom/${this.id}.jpg`;
	        }
	    }
	    /** Gets a DIF file from the mission resources.
	     * @param rawElementPath The raw path specified within the .mis file
	     */
	    async getDif(rawElementPath) {
	        rawElementPath = rawElementPath.toLowerCase();
	        let path = rawElementPath.slice(rawElementPath.indexOf('data/'));
	        if (this.modification === 'gold' && path.includes('interiors_mbg/'))
	            path = path.replace('interiors_mbg/', 'interiors/');
	        if (this.modification !== 'gold')
	            path = path.replace('data/', 'data_mbp/');
	        let dif = null;
	        if (this.difCache.get(path))
	            dif = await this.difCache.get(path); // We've already parsed the dif before
	        else {
	            let promise = new Promise(async (resolve) => {
	                let dif;
	                if (this.zipDirectory && this.zipDirectory.files[path]) {
	                    // Get it from the zip
	                    let arrayBuffer = await this.zipDirectory.files[path].async('arraybuffer');
	                    let parser = new DifParser(arrayBuffer);
	                    let result = parser.parse();
	                    dif = result;
	                }
	                else {
	                    dif = await DifParser.loadFile('./assets/' + path);
	                }
	                resolve(dif);
	            });
	            this.difCache.set(path, promise);
	            dif = await promise;
	        }
	        return { dif, path };
	    }
	    /** Gets a DTS file from the mission resources. */
	    async getDts(path) {
	        let dts = null;
	        let base = (G$1.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files['data/' + path]) {
	            // Get it from the zip
	            let arrayBuffer = await this.zipDirectory.files['data/' + path].async('arraybuffer');
	            let parser = new DtsParser(arrayBuffer);
	            let result = parser.parse();
	            dts = result;
	        }
	        else {
	            dts = await DtsParser.loadFile('./assets/' + base + path);
	        }
	        return dts;
	    }
	    /** Same as `ResourceManager.getFullNamesOf`, but including custom mission resources. */
	    getFullNamesOf(path) {
	        path = path.toLowerCase();
	        let result = [];
	        let prepended = 'data/' + path;
	        if (this.zipDirectory) {
	            for (let filePath in this.zipDirectory.files) {
	                if (filePath.startsWith(prepended)) {
	                    if (filePath.length !== prepended.length && prepended.length !== filePath.lastIndexOf('.'))
	                        continue;
	                    result.push(filePath.slice(filePath.lastIndexOf('/') + 1));
	                }
	            }
	        }
	        result.push(...ResourceManager$1.getFullNamesOf(path, this.modification !== 'gold'));
	        return result;
	    }
	    /** Gets a blob for a file in the zip directory. */
	    getBlobForFile(path) {
	        let file = this.zipDirectory.files[path];
	        if (this.fileToBlobPromises.get(file))
	            return this.fileToBlobPromises.get(file);
	        let promise = new Promise(async (resolve) => {
	            let blob = await file.async('blob');
	            resolve(blob);
	        });
	        this.fileToBlobPromises.set(file, promise);
	        return promise;
	    }
	    /** Gets a texture from the mission resources. */
	    async getTexture(path) {
	        path = path.toLowerCase();
	        let base = (this.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files[base + path]) {
	            let blob = await this.getBlobForFile(base + path);
	            let url = ResourceManager$1.getUrlToBlob(blob);
	            let texture = await ResourceManager$1.getTexture(url, '');
	            return texture;
	        }
	        else {
	            let texture = await ResourceManager$1.getTexture(path, 'assets/' + base);
	            return texture;
	        }
	    }
	    /** Gets a general resource from the mission resources. */
	    async getResource(path) {
	        path = path.toLowerCase();
	        let base = (this.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files[base + path]) {
	            let blob = await this.getBlobForFile(base + path);
	            return blob;
	        }
	        else {
	            return await ResourceManager$1.loadResource('./assets/' + base + path);
	        }
	    }
	    /** Gets an image from the mission resources. */
	    async getImage(path) {
	        path = path.toLowerCase();
	        let base = (this.modification === 'gold') ? 'data/' : 'data_mbp/';
	        if (this.zipDirectory && this.zipDirectory.files[base + path]) {
	            let blob = await this.getBlobForFile(base + path);
	            let url = ResourceManager$1.getUrlToBlob(blob);
	            return await ResourceManager$1.loadImage(url);
	        }
	        else {
	            return await ResourceManager$1.loadImage('./assets/' + base + path);
	        }
	    }
	    /** Returns true iff the mission matches the given query. */
	    matchesSearch(queryWords, query) {
	        if (Util$1.isSubsequenceOf(query, this.searchString))
	            return true;
	        for (let i = 0; i < queryWords.length; i++) {
	            if (!this.searchString.includes(queryWords[i]))
	                return false;
	        }
	        return true;
	    }
	    /** Computes the clock time in MBP when the user should be warned that they're about to exceed the par time. */
	    computeAlarmStartTime() {
	        let alarmStart = this.qualifyTime;
	        if (this.missionInfo.alarmstarttime)
	            alarmStart -= MisParser$1.parseNumber(this.missionInfo.alarmstarttime) * 1000;
	        else
	            alarmStart -= 15 * 1000;
	        alarmStart = Math.max(0, alarmStart);
	        return alarmStart;
	    }
	    getDefaultGravity() {
	        if (this.misFile.marbleAttributes["gravity"] !== undefined) {
	            return MisParser$1.parseNumber(this.misFile.marbleAttributes["gravity"]);
	        }
	        return 20;
	    }
	}
	//# sourceMappingURL=mission.js.map

	class MissionLibrary {
	    /** Loads all missions. */
	    static async init() {
	        // Do a single request to get a list of all missions
	        let missions = await ResourceManager$1.readBlobAsJson(await ResourceManager$1.loadResource('/api/missions'));
	        missions.officialMissions.sort((a, b) => a.index - b.index);
	        for (let description of missions.officialMissions) {
	            let mission = Mission.fromOfficialMissionDescription(description);
	            if (mission.modification === 'gold' && mission.type === 'beginner')
	                this.goldBeginner.push(mission);
	            else if (mission.modification === 'gold' && mission.type === 'intermediate')
	                this.goldIntermediate.push(mission);
	            else if (mission.modification === 'gold' && mission.type === 'advanced')
	                this.goldAdvanced.push(mission);
	            else if (mission.modification === 'gold')
	                this.goldCustom.push(mission);
	            else if (mission.modification === 'platinum' && mission.type === 'beginner')
	                this.platinumBeginner.push(mission);
	            else if (mission.modification === 'platinum' && mission.type === 'intermediate')
	                this.platinumIntermediate.push(mission);
	            else if (mission.modification === 'platinum' && mission.type === 'advanced')
	                this.platinumAdvanced.push(mission);
	            else if (mission.modification === 'platinum' && mission.type === 'expert')
	                this.platinumExpert.push(mission);
	            else if (mission.modification === 'platinum')
	                this.platinumCustom.push(mission);
	            else if (mission.modification === 'ultra' && mission.type === 'beginner')
	                this.ultraBeginner.push(mission);
	            else if (mission.modification === 'ultra' && mission.type === 'intermediate')
	                this.ultraIntermediate.push(mission);
	            else if (mission.modification === 'ultra' && mission.type === 'advanced')
	                this.ultraAdvanced.push(mission);
	            else if (mission.modification === 'ultra')
	                this.ultraCustom.push(mission);
	            this.allMissions.push(mission);
	        }
	        // Filter the custom levels some:
	        Util$1.filterInPlace(missions.goldCustoms, x => x.modification === 'gold'); // Apparently some platinum levels snuck in
	        Util$1.filterInPlace(missions.platinumCustoms, x => x.gameType === 'single' && (!x.gameMode || x.gameMode === 'null')); // Whoops, forgot to filter the JSON
	        Util$1.filterInPlace(missions.ultraCustoms, x => x.gameType === 'single');
	        // Remove duplicate Platinum levels
	        let platCustomNames = new Set();
	        for (let i = 0; i < missions.platinumCustoms.length; i++) {
	            let mission = missions.platinumCustoms[i];
	            let identifier = mission.name + mission.desc; // Assume this makes a mission unique
	            if (platCustomNames.has(identifier)) {
	                missions.platinumCustoms.splice(i--, 1);
	            }
	            else {
	                platCustomNames.add(identifier);
	            }
	        }
	        // Create all custom missions
	        for (let custom of [...missions.goldCustoms, ...missions.platinumCustoms, ...missions.ultraCustoms]) {
	            let mission = Mission.fromCLAEntry(custom, false);
	            if (mission.modification === 'gold')
	                this.goldCustom.push(mission);
	            else if (mission.modification === 'ultra')
	                this.ultraCustom.push(mission);
	            else
	                this.platinumCustom.push(mission);
	        }
	        // Strange case, but these two levels are in opposite order in the original game.
	        Util$1.swapInArray(this.goldIntermediate, 11, 12);
	        // Sort all custom levels alphabetically
	        const sortFn2 = (a, b) => Util$1.normalizeString(a.title).localeCompare(Util$1.normalizeString(b.title), undefined, { numeric: true, sensitivity: 'base' });
	        this.goldCustom.sort(sortFn2);
	        this.platinumCustom.sort(sortFn2);
	        this.ultraCustom.sort(sortFn2);
	        // Apparently, these two levels are swapped
	        Util$1.swapInArray(this.goldIntermediate, 11, 12);
	        for (let i = 0; i < this.goldBeginner.length; i++)
	            this.goldBeginner[i].initSearchString(i);
	        for (let i = 0; i < this.goldIntermediate.length; i++)
	            this.goldIntermediate[i].initSearchString(i);
	        for (let i = 0; i < this.goldAdvanced.length; i++)
	            this.goldAdvanced[i].initSearchString(i);
	        for (let i = 0; i < this.goldCustom.length; i++)
	            this.goldCustom[i].initSearchString(i);
	        for (let i = 0; i < this.platinumBeginner.length; i++)
	            this.platinumBeginner[i].initSearchString(i);
	        for (let i = 0; i < this.platinumIntermediate.length; i++)
	            this.platinumIntermediate[i].initSearchString(i);
	        for (let i = 0; i < this.platinumAdvanced.length; i++)
	            this.platinumAdvanced[i].initSearchString(i);
	        for (let i = 0; i < this.platinumExpert.length; i++)
	            this.platinumExpert[i].initSearchString(i);
	        for (let i = 0; i < this.platinumCustom.length; i++)
	            this.platinumCustom[i].initSearchString(i);
	        for (let i = 0; i < this.ultraBeginner.length; i++)
	            this.ultraBeginner[i].initSearchString(i);
	        for (let i = 0; i < this.ultraIntermediate.length; i++)
	            this.ultraIntermediate[i].initSearchString(i);
	        for (let i = 0; i < this.ultraAdvanced.length; i++)
	            this.ultraAdvanced[i].initSearchString(i);
	        for (let i = 0; i < this.ultraCustom.length; i++)
	            this.ultraCustom[i].initSearchString(i);
	        this.allMissionArrays.push(this.goldBeginner, this.goldIntermediate, this.goldAdvanced, this.goldCustom, this.platinumBeginner, this.platinumIntermediate, this.platinumAdvanced, this.platinumExpert, this.platinumCustom, this.ultraBeginner, this.ultraIntermediate, this.ultraAdvanced, this.ultraCustom);
	    }
	    static getModification(arr) {
	        var _a, _b;
	        return (_b = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.modification) !== null && _b !== void 0 ? _b : null;
	    }
	    static getDifficulty(arr) {
	        var _a, _b;
	        return (_b = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : null;
	    }
	}
	MissionLibrary.allMissions = [];
	MissionLibrary.goldBeginner = [];
	MissionLibrary.goldIntermediate = [];
	MissionLibrary.goldAdvanced = [];
	MissionLibrary.goldCustom = [];
	MissionLibrary.platinumBeginner = [];
	MissionLibrary.platinumIntermediate = [];
	MissionLibrary.platinumAdvanced = [];
	MissionLibrary.platinumExpert = [];
	MissionLibrary.platinumCustom = [];
	MissionLibrary.ultraBeginner = [];
	MissionLibrary.ultraIntermediate = [];
	MissionLibrary.ultraAdvanced = [];
	MissionLibrary.ultraCustom = [];
	MissionLibrary.allMissionArrays = [];
	//# sourceMappingURL=mission_library.js.map

	/*import { Level, TimeState, PHYSICS_TICK_RATE } from "./level";
	import { PowerUp } from "./shapes/power_up";
	import { Shape } from "./shape";
	import { Trigger } from "./triggers/trigger";
	import { Util } from "./util";
	import { TrapDoor } from "./shapes/trap_door";
	import { LandMine } from "./shapes/land_mine";
	import { executeOnWorker } from "./worker";
	import { PushButton } from "./shapes/push_button";
	import { Mission } from "./mission";
	import { Interior } from "./interior";
	import { Nuke } from "./shapes/nuke";
	import { Vector3 } from "./math/vector3";
	import { Quaternion } from "./math/quaternion";*/
	/** Stores everything necessary for a correct replay of a playthrough. Instead of relying on replaying player inputs, the replay simply stores all necessary state. */
	class Replay$1 {
	    constructor(level) {
	        this.version = 5;
	        this.mode = 'record';
	        /** If writing to the replay is still permitted. */
	        this.canStore = true;
	        /** Replays get invalidated if they don't end in a successful finish. */
	        this.isInvalid = false;
	        /** The position of the marble at each physics tick. */
	        this.marblePositions = [];
	        /** The orientation of the marble at each physics tick. */
	        this.marbleOrientations = [];
	        /** The linear velocity of the marble at each physics tick. */
	        this.marbleLinearVelocities = [];
	        /** The angular velocity of the marble at each physics tick. */
	        this.marbleAngularVelocities = [];
	        /** Stores the times the marble was inside a shape/trigger. */
	        this.marbleInside = [];
	        /** Stores the times the marble entered a shape/trigger. */
	        this.marbleEnter = [];
	        /** Stores the times the marble left a shape/trigger. */
	        this.marbleLeave = [];
	        /** Stores the times the marble collided with a shape. */
	        this.marbleContact = [];
	        /** Stores power-up usage. */
	        this.uses = [];
	        /** Stores blast usage. */
	        this.blasts = [];
	        /** Camera orientation for each physics tick. */
	        this.cameraOrientations = [];
	        /** How much to revert time for each time travel. */
	        this.timeTravelTimeToRevert = new Map();
	        /** When the finish area was hit. */
	        this.touchFinishTickIndices = [];
	        this.finishTime = null;
	        /** In order to replay trapdoors correctly, their completion state upon attempt start must be reconstructed properly. */
	        this.trapdoorStartValues = [];
	        /** In order to replay mines correctly, their visibility state upon attempt start must be reconstructed properly. */
	        this.landmineStartValues = [];
	        /** In order to replay push buttons correctly, their completion state upon attempt start must be reconstructed properly. */
	        this.pushButtonStartValues = [];
	        /** In order to replay nukes correctly, their visibility state upon attempt start must be reconstructed properly. */
	        this.nukeStartValues = [];
	        /** The gain of the rolling sound for each physics tick. */
	        this.rollingSoundGain = [];
	        /** The playback rate of the rolling sound for each physics tick. */
	        this.rollingSoundPlaybackRate = [];
	        /** The gain of the sliding sound for each physics tick. */
	        this.slidingSoundGain = [];
	        /** When the jump sound played. */
	        this.jumpSoundTimes = [];
	        /** When bounces happened. */
	        this.bounceTimes = [];
	        /** Which powerups were selected at random. */
	        this.randomPowerUpChoices = new Map();
	        this.checkpointRespawns = [];
	        this.currentJumpSoundTime = 0;
	        this.currentBounceTime = 0;
	        if (level) {
	            this.level = level;
	            this.missionPath = level.mission.path;
	        }
	    }
	    /** The current tick index to write to / read from. */
	    get currentTickIndex() {
	        return Math.max(this.level.timeState.tickIndex, 0);
	    }
	    /** Inits the replay's values. */
	    init() {
	        if (this.mode === 'record') {
	            // Reset all values
	            this.canStore = true;
	            this.isInvalid = false;
	            this.marblePositions.length = 0;
	            this.marbleOrientations.length = 0;
	            this.marbleLinearVelocities.length = 0;
	            this.marbleAngularVelocities.length = 0;
	            this.marbleInside.length = 0;
	            this.marbleEnter.length = 0;
	            this.marbleLeave.length = 0;
	            this.marbleContact.length = 0;
	            this.uses.length = 0;
	            this.blasts.length = 0;
	            this.cameraOrientations.length = 0;
	            this.timeTravelTimeToRevert.clear();
	            this.touchFinishTickIndices.length = 0;
	            this.finishTime = null;
	            this.trapdoorStartValues.length = 0;
	            this.landmineStartValues.length = 0;
	            this.pushButtonStartValues.length = 0;
	            this.nukeStartValues.length = 0;
	            this.rollingSoundGain.length = 0;
	            this.rollingSoundPlaybackRate.length = 0;
	            this.slidingSoundGain.length = 0;
	            this.jumpSoundTimes.length = 0;
	            this.bounceTimes.length = 0;
	            this.randomPowerUpChoices.clear();
	            this.checkpointRespawns.length = 0;
	            // Remember trapdoor, mine and push button states
	            for (let shape of this.level.shapes) {
	                if (shape instanceof TrapDoor) {
	                    this.trapdoorStartValues.push({
	                        id: shape.id,
	                        lastContactTime: shape.lastContactTime,
	                        lastDirection: shape.lastDirection,
	                        lastCompletion: shape.lastCompletion
	                    });
	                }
	                else if (shape instanceof LandMine) {
	                    this.landmineStartValues.push({
	                        id: shape.id,
	                        disappearTime: shape.disappearTime
	                    });
	                }
	                else if (shape instanceof PushButton) {
	                    this.pushButtonStartValues.push({
	                        id: shape.id,
	                        lastContactTime: shape.lastContactTime
	                    });
	                }
	                else if (shape instanceof Nuke) {
	                    this.nukeStartValues.push({
	                        id: shape.id,
	                        disappearTime: shape.disappearTime
	                    });
	                }
	            }
	            this.timeSinceLoad = this.level.timeState.timeSinceLoad;
	        }
	        else {
	            // Reconstruct trapdoor, mine and push button states
	            for (let shape of this.level.shapes) {
	                if (shape instanceof TrapDoor) {
	                    let startValues = this.trapdoorStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    // This is quite stupid. lastContactTime, of course, is never null, but it might be -Infinity, in which case JSON.stringify turns it to null. We're catching that here.
	                    if (startValues.lastContactTime === null)
	                        startValues.lastContactTime = -Infinity;
	                    shape.lastContactTime = startValues.lastContactTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                    shape.lastDirection = startValues.lastDirection;
	                    shape.lastCompletion = startValues.lastCompletion;
	                }
	                else if (shape instanceof LandMine) {
	                    let startValues = this.landmineStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    if (startValues.disappearTime === null)
	                        startValues.disappearTime = -Infinity;
	                    shape.disappearTime = startValues.disappearTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                }
	                else if (shape instanceof PushButton) {
	                    let startValues = this.pushButtonStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    if (startValues.lastContactTime === null)
	                        startValues.lastContactTime = -Infinity;
	                    shape.lastContactTime = startValues.lastContactTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                }
	                else if (shape instanceof Nuke) {
	                    let startValues = this.nukeStartValues.find(x => x.id === shape.id);
	                    if (!startValues)
	                        continue;
	                    if (startValues.disappearTime === null)
	                        startValues.disappearTime = -Infinity;
	                    shape.disappearTime = startValues.disappearTime - this.timeSinceLoad + this.level.timeState.timeSinceLoad;
	                }
	            }
	        }
	    }
	    /** Writes current data to the replay. */
	    record() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        let marble = this.level.marble;
	        this.marblePositions.push(marble.body.position.clone());
	        this.marbleOrientations.push(marble.body.orientation.clone());
	        this.marbleLinearVelocities.push(marble.body.linearVelocity.clone());
	        this.marbleAngularVelocities.push(marble.body.angularVelocity.clone());
	        this.cameraOrientations.push({ yaw: this.level.yaw, pitch: this.level.pitch });
	        // Store sound state in the replay too
	        this.rollingSoundGain.push(marble.rollingSound.gain.gain.value);
	        this.rollingSoundPlaybackRate.push(marble.rollingSound.node.playbackRate.value);
	        this.slidingSoundGain.push(marble.slidingSound.gain.gain.value);
	        if (this.level.finishTime && this.finishTime === null)
	            this.finishTime = Util.jsonClone(this.level.finishTime);
	        // Check if the replay is excessively long. If it is, stop it to prevent a memory error.
	        if (this.marblePositions.length >= PHYSICS_TICK_RATE * 60 * 60) {
	            this.canStore = false;
	            this.isInvalid = this.level.finishTime === null; // If the playthrough was finished, we don't consider the replay invalid.
	        }
	    }
	    recordMarbleInside(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleInside.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordMarbleEnter(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleEnter.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordMarbleLeave(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleLeave.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordMarbleContact(object) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.marbleContact.push({
	            tickIndex: this.currentTickIndex,
	            id: object.id
	        });
	    }
	    recordUsePowerUp(powerUp) {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.uses.push({
	            tickIndex: this.currentTickIndex,
	            id: powerUp.id
	        });
	    }
	    recordUseBlast() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.blasts.push({
	            tickIndex: this.currentTickIndex
	        });
	    }
	    recordTouchFinish() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.touchFinishTickIndices.push(this.currentTickIndex);
	    }
	    recordCheckpointRespawn() {
	        if (this.mode === 'playback' || !this.canStore)
	            return;
	        this.checkpointRespawns.push(this.currentTickIndex);
	    }
	    /** Apply the replay's stored state to the world. */
	    playBack() {
	        var _a, _b, _c, _d;
	        let i = this.currentTickIndex;
	        if (i >= this.marblePositions.length)
	            return; // Safety measure
	        for (let obj of this.marbleInside) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_a = this.level.shapes.find(x => x.id === obj.id)) !== null && _a !== void 0 ? _a : this.level.triggers.find(x => x.id === obj.id);
	            object.onMarbleInside(1);
	        }
	        for (let obj of this.marbleEnter) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_b = this.level.shapes.find(x => x.id === obj.id)) !== null && _b !== void 0 ? _b : this.level.triggers.find(x => x.id === obj.id);
	            object.onMarbleEnter(1);
	        }
	        for (let obj of this.marbleLeave) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_c = this.level.shapes.find(x => x.id === obj.id)) !== null && _c !== void 0 ? _c : this.level.triggers.find(x => x.id === obj.id);
	            object.onMarbleLeave();
	        }
	        for (let obj of this.marbleContact) {
	            if (obj.tickIndex !== i)
	                continue;
	            let object = (_d = this.level.shapes.find(x => x.id === obj.id)) !== null && _d !== void 0 ? _d : this.level.interiors.find(x => x.id === obj.id);
	            object.onMarbleContact(null, 1000 / PHYSICS_TICK_RATE);
	        }
	        for (let use of this.uses) {
	            if (use.tickIndex !== i)
	                continue;
	            let powerUp = this.level.shapes.find(x => x.id === use.id);
	            powerUp.use(0);
	        }
	        for (let blast of this.blasts) {
	            if (blast.tickIndex !== i)
	                continue;
	            this.level.marble.useBlast();
	        }
	        for (let tickIndex of this.touchFinishTickIndices)
	            if (tickIndex === i)
	                this.level.touchFinish();
	        for (let tickIndex of this.checkpointRespawns)
	            if (tickIndex === i)
	                this.level.loadCheckpointState();
	        this.level.marble.body.position.copy(this.marblePositions[i]);
	        this.level.marble.body.orientation.copy(this.marbleOrientations[i]);
	        this.level.marble.body.linearVelocity.copy(this.marbleLinearVelocities[i]);
	        this.level.marble.body.angularVelocity.copy(this.marbleAngularVelocities[i]);
	        this.level.yaw = this.cameraOrientations[i].yaw;
	        this.level.pitch = this.cameraOrientations[i].pitch;
	        for (let j = this.currentJumpSoundTime; j < this.jumpSoundTimes.length; j++) {
	            if (this.jumpSoundTimes[j] > i)
	                break;
	            if (this.jumpSoundTimes[j] === i)
	                this.level.marble.playJumpSound();
	        }
	        for (let j = this.currentBounceTime; j < this.bounceTimes.length; j++) {
	            if (this.bounceTimes[j].tickIndex > i)
	                break;
	            if (this.bounceTimes[j].tickIndex === i) {
	                this.level.marble.playBounceSound(this.bounceTimes[j].volume);
	                if (this.bounceTimes[j].showParticles)
	                    this.level.marble.showBounceParticles();
	            }
	        }
	        this.level.marble.rollingSound.gain.gain.value = this.rollingSoundGain[i];
	        this.level.marble.rollingSound.setPlaybackRate(this.rollingSoundPlaybackRate[i]);
	        this.level.marble.slidingSound.gain.gain.value = this.slidingSoundGain[i];
	    }
	    isPlaybackComplete() {
	        return this.currentTickIndex === this.marblePositions.length - 1;
	    }
	    /** Converts the replay's data into a compressed array buffer. */
	    async serialize() {
	        let cameraOrientations = new Float32Array(this.cameraOrientations.length * 2);
	        for (let i = 0; i < this.cameraOrientations.length; i++) {
	            cameraOrientations[i * 2 + 0] = this.cameraOrientations[i].yaw;
	            cameraOrientations[i * 2 + 1] = this.cameraOrientations[i].pitch;
	        }
	        // First, create a more compact object by utilizing typed arrays.
	        let serialized = {
	            version: this.version,
	            timestamp: Date.now(),
	            missionPath: this.missionPath,
	            marblePositions: Util.arrayBufferToString(Replay$1.vec3sToBuffer(this.marblePositions).buffer),
	            marbleOrientations: Util.arrayBufferToString(Replay$1.quatsToBuffer(this.marbleOrientations).buffer),
	            marbleLinearVelocities: Util.arrayBufferToString(Replay$1.vec3sToBuffer(this.marbleLinearVelocities).buffer),
	            marbleAngularVelocities: Util.arrayBufferToString(Replay$1.vec3sToBuffer(this.marbleAngularVelocities).buffer),
	            marbleInside: this.marbleInside,
	            marbleEnter: this.marbleEnter,
	            marbleLeave: this.marbleLeave,
	            marbleContact: this.marbleContact,
	            uses: this.uses,
	            blasts: this.blasts,
	            cameraOrientations: Util.arrayBufferToString(cameraOrientations.buffer),
	            timeTravelTimeToRevert: [...this.timeTravelTimeToRevert.entries()],
	            touchFinishTickIndices: this.touchFinishTickIndices,
	            finishTime: this.finishTime,
	            trapdoorStartValues: this.trapdoorStartValues,
	            landmineStartValues: this.landmineStartValues,
	            pushButtonStartValues: this.pushButtonStartValues,
	            nukeStartValues: this.nukeStartValues,
	            timeSinceLoad: this.timeSinceLoad,
	            rollingSoundGain: Util.arrayBufferToString(new Float32Array(this.rollingSoundGain).buffer),
	            rollingSoundPlaybackRate: Util.arrayBufferToString(new Float32Array(this.rollingSoundPlaybackRate).buffer),
	            slidingSoundGain: Util.arrayBufferToString(new Float32Array(this.slidingSoundGain).buffer),
	            jumpSoundTimes: this.jumpSoundTimes,
	            bounceTimes: this.bounceTimes,
	            randomPowerUpChoices: [...this.randomPowerUpChoices.entries()],
	            checkpointRespawns: this.checkpointRespawns
	        };
	        // Then compress the whole th ing. As this step is the most expensive, run it in another thread.
	        let compressed = await executeOnWorker('compress', JSON.stringify(serialized));
	        return compressed;
	    }
	    /** Reconstructs a replay from its compressed array buffer representation. */
	    static fromSerialized(buf) {
	        var _a, _b, _c, _d, _e, _f, _g;
	        let replay = new Replay$1();
	        let string = pako.inflate(new Uint8Array(buf), { to: 'string' });
	        let serialized = JSON.parse(string);
	        let version = (_a = serialized.version) !== null && _a !== void 0 ? _a : 0;
	        replay.version = version;
	        replay.missionPath = (version >= 1) ? serialized.missionPath : null;
	        replay.timestamp = (version >= 1) ? serialized.timestamp : 0;
	        replay.marblePositions = Replay$1.bufferToVec3s(new Float32Array(Util.stringToArrayBuffer(serialized.marblePositions)));
	        replay.marbleOrientations = Replay$1.bufferToQuats(new Float32Array(Util.stringToArrayBuffer(serialized.marbleOrientations)));
	        replay.marbleLinearVelocities = Replay$1.bufferToVec3s(new Float32Array(Util.stringToArrayBuffer(serialized.marbleLinearVelocities)));
	        replay.marbleAngularVelocities = Replay$1.bufferToVec3s(new Float32Array(Util.stringToArrayBuffer(serialized.marbleAngularVelocities)));
	        replay.marbleInside = serialized.marbleInside;
	        replay.marbleEnter = serialized.marbleEnter;
	        replay.marbleLeave = (_b = serialized.marbleLeave) !== null && _b !== void 0 ? _b : []; // Might not be there in older versions
	        replay.marbleContact = serialized.marbleContact;
	        replay.uses = serialized.uses;
	        replay.blasts = (_c = serialized.blasts) !== null && _c !== void 0 ? _c : [];
	        let cameraOrientations = [];
	        let cameraOrientationsBuffer = new Float32Array(Util.stringToArrayBuffer(serialized.cameraOrientations));
	        for (let i = 0; i < cameraOrientationsBuffer.length / 2; i++) {
	            cameraOrientations.push({
	                yaw: cameraOrientationsBuffer[i * 2 + 0],
	                pitch: cameraOrientationsBuffer[i * 2 + 1]
	            });
	        }
	        replay.cameraOrientations = cameraOrientations;
	        replay.timeTravelTimeToRevert = serialized.timeTravelTimeToRevert.reduce((prev, next) => (prev.set(next[0], next[1]), prev), new Map());
	        replay.touchFinishTickIndices = serialized.touchFinishTickIndices;
	        replay.finishTime = serialized.finishTime;
	        replay.trapdoorStartValues = serialized.trapdoorStartValues;
	        replay.landmineStartValues = serialized.landmineStartValues;
	        replay.pushButtonStartValues = (_d = serialized.pushButtonStartValues) !== null && _d !== void 0 ? _d : []; // Might not be there in older versions
	        replay.nukeStartValues = (_e = serialized.nukeStartValues) !== null && _e !== void 0 ? _e : [];
	        replay.timeSinceLoad = serialized.timeSinceLoad;
	        replay.rollingSoundGain = [...new Float32Array(Util.stringToArrayBuffer(serialized.rollingSoundGain))];
	        replay.rollingSoundPlaybackRate = [...new Float32Array(Util.stringToArrayBuffer(serialized.rollingSoundPlaybackRate))];
	        replay.slidingSoundGain = [...new Float32Array(Util.stringToArrayBuffer(serialized.slidingSoundGain))];
	        replay.jumpSoundTimes = serialized.jumpSoundTimes;
	        replay.bounceTimes = serialized.bounceTimes;
	        replay.randomPowerUpChoices = ((_f = serialized.randomPowerUpChoices) !== null && _f !== void 0 ? _f : []).reduce((prev, next) => (prev.set(next[0], next[1]), prev), new Map());
	        replay.checkpointRespawns = (_g = serialized.checkpointRespawns) !== null && _g !== void 0 ? _g : [];
	        return replay;
	    }
	    static vec3sToBuffer(arr) {
	        let buffer = new Float32Array(arr.length * 3);
	        for (let i = 0; i < arr.length; i++) {
	            buffer[i * 3 + 0] = arr[i].x;
	            buffer[i * 3 + 1] = arr[i].y;
	            buffer[i * 3 + 2] = arr[i].z;
	        }
	        return buffer;
	    }
	    static quatsToBuffer(arr) {
	        let buffer = new Float32Array(arr.length * 4);
	        for (let i = 0; i < arr.length; i++) {
	            buffer[i * 4 + 0] = arr[i].x;
	            buffer[i * 4 + 1] = arr[i].y;
	            buffer[i * 4 + 2] = arr[i].z;
	            buffer[i * 4 + 3] = arr[i].w;
	        }
	        return buffer;
	    }
	    static bufferToVec3s(buf) {
	        let vecs = [];
	        for (let i = 0; i < buf.length / 3; i++) {
	            let vec = new Vector3(buf[i * 3 + 0], buf[i * 3 + 1], buf[i * 3 + 2]);
	            vecs.push(vec);
	        }
	        return vecs;
	    }
	    static bufferToQuats(buf) {
	        let quats = [];
	        for (let i = 0; i < buf.length / 4; i++) {
	            let quat = new Quaternion(buf[i * 4 + 0], buf[i * 4 + 1], buf[i * 4 + 2], buf[i * 4 + 3]);
	            quats.push(quat);
	        }
	        return quats;
	    }
	    /** Downloads a replay as a .wrec file. */
	    static async download(replayData, mission, normalize = true, unfinished = false) {
	        if (normalize)
	            replayData = await this.maybeUpdateReplay(replayData, mission.path); // Normalize the replay first
	        // Create the blob and download it
	        let blob = new Blob([replayData], {
	            type: 'application/octet-stream'
	        });
	        let url = URL.createObjectURL(blob);
	        let filename = Util.removeSpecialChars(mission.title.toLowerCase().split(' ').map(x => Util.uppercaseFirstLetter(x)).join(''));
	        for (let i = 0; i < 6; i++)
	            filename += Math.floor(Math.random() * 10); // Add a random string of numbers to the end
	        if (unfinished)
	            filename += 'u'; // Clearly mark the replay as being unfinished
	        filename += '.wrec';
	        Util.download(url, filename);
	        URL.revokeObjectURL(url);
	    }
	    /** Makes sure a replay fits some requirements. */
	    static async maybeUpdateReplay(replayData, missionPath) {
	        let uncompressed = pako.inflate(new Uint8Array(replayData), { to: 'string' });
	        // This is a bit unfortunate, but we'd like to bundle the mission path with the replay, but the first replay version didn't include it. So we need to check if the replay actually includes the mission path, which we can check by checking if it includes the "version" field. We then upgrade the replay to verion 1.
	        if (!uncompressed.includes('"version"')) {
	            let json = JSON.parse(uncompressed);
	            // Upgrade to version 1
	            json.missionPath = missionPath;
	            json.timestamp = 0;
	            json.version = 1;
	            let compressed = await executeOnWorker('compress', JSON.stringify(json));
	            replayData = compressed;
	        }
	        return replayData;
	    }
	}
	//# sourceMappingURL=replay.js.map

	class LevelSelect {
	    constructor(menu) {
	        this.setImagesTimeout = null;
	        this.clearImageTimeout = null;
	        this.currentQuery = '';
	        /** The current words in the search query. Used for matching. */
	        this.currentQueryWords = [];
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.homeButton, this.homeButtonSrc, () => {
	            this.hide();
	            menu.home.show();
	        }, undefined, undefined, G$1.modification === 'gold');
	        menu.setupButton(this.prevButton, 'play/prev', () => this.cycleMission(-1), true, true, G$1.modification === 'gold', true);
	        menu.setupButton(this.playButton, 'play/play', () => this.playCurrentMission(), true, undefined, G$1.modification === 'gold');
	        menu.setupButton(this.nextButton, 'play/next', () => this.cycleMission(1), true, true, G$1.modification === 'gold', true);
	    }
	    get currentMission() { var _a; return (_a = this.currentMissionArray) === null || _a === void 0 ? void 0 : _a[this.currentMissionIndex]; }
	    async init() {
	        // Create the elements for the local best times
	        for (let i = 0; i < this.localScoresCount; i++) {
	            let element = this.createScoreElement(true);
	            this.localBestTimesContainer.appendChild(element);
	        }
	        // Create the elements for the online leaderboard (will be reused)
	        for (let i = 0; i < 18; i++) {
	            let element = this.createScoreElement(false);
	            this.leaderboardScores.appendChild(element);
	        }
	        this.scrollWindow.addEventListener('scroll', () => this.updateOnlineLeaderboard());
	        window.addEventListener('keydown', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'ArrowLeft' && (!this.searchInput.value || document.activeElement === document.body)) {
	                this.cycleMission(-1);
	                if (!this.prevButton.style.pointerEvents)
	                    this.prevButton.src = this.menu.uiAssetPath + 'play/prev_d.png';
	            }
	            else if (e.code === 'ArrowRight' && (!this.searchInput.value || document.activeElement === document.body)) {
	                this.cycleMission(1);
	                if (!this.nextButton.style.pointerEvents)
	                    this.nextButton.src = this.menu.uiAssetPath + 'play/next_d.png';
	            }
	            else if (e.code === 'Escape') {
	                this.homeButton.src = this.menu.uiAssetPath + this.homeButtonSrc + '_d.png';
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'ArrowLeft') {
	                if (!this.prevButton.style.pointerEvents)
	                    this.prevButton.src = this.prevButton.hasAttribute('data-hovered') ? this.menu.uiAssetPath + 'play/prev_h.png' : this.menu.uiAssetPath + 'play/prev_n.png';
	            }
	            else if (e.code === 'ArrowRight') {
	                if (!this.nextButton.style.pointerEvents)
	                    this.nextButton.src = this.nextButton.hasAttribute('data-hovered') ? this.menu.uiAssetPath + 'play/next_h.png' : this.menu.uiAssetPath + 'play/next_n.png';
	            }
	            else if (e.code === 'Escape') {
	                this.homeButton.click();
	            }
	        });
	        this.searchInput.addEventListener('input', () => {
	            this.onSearchInputChange();
	        });
	        this.searchInput.addEventListener('focus', () => {
	            // Clear the search when focused
	            this.searchInput.value = '';
	            this.onSearchInputChange();
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        this.displayMission();
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    setMissionArray(arr, doImageTimeout = true) {
	        this.currentMissionArray = arr;
	        this.currentMissionIndex = this.getDefaultMissionIndex();
	        this.selectBasedOnSearchQuery(false);
	        this.displayMission(doImageTimeout);
	    }
	    getDefaultMissionIndex() {
	        return 0; // fixme
	    }
	    displayMission(doImageTimeout = true) {
	        let mission = this.currentMission;
	        if (!mission) {
	            // There is no mission, so hide most information. In reality, this case should never ever happen.
	            this.levelImage.style.display = 'none';
	            this.playButton.src = this.menu.uiAssetPath + 'play/play_i.png';
	            this.playButton.style.pointerEvents = 'none';
	            this.displayEmptyMetadata();
	            this.displayBestTimes();
	        }
	        else {
	            // Reenable the play button if it was disabled
	            if (this.playButton.style.pointerEvents === 'none') {
	                this.playButton.src = this.menu.uiAssetPath + 'play/play_n.png';
	                this.playButton.style.pointerEvents = '';
	            }
	            this.levelImage.style.display = '';
	            this.displayMetadata();
	            this.displayBestTimes();
	            if (!this.clearImageTimeout)
	                this.clearImageTimeout = setTimeout(() => this.levelImage.src = '', 16); // Clear the image after a very short time (if no image is loaded 'til then)
	        }
	        this.setImages(false, doImageTimeout);
	        this.updateNextPrevButtons();
	        Leaderboard.loadLocal();
	    }
	    playCurrentMission(replayData) {
	        let currentMission = this.currentMission;
	        if (!currentMission)
	            return;
	        this.hide();
	        this.menu.loadingScreen.loadMissionSingleplayer(currentMission /*, replayData? () => Replay.fromSerialized(replayData) : undefined*/); // Initiate level loading
	    }
	    /** Advance the current mission index by the specified count while respecting the search query. That count can be negative. */
	    cycleMission(direction) {
	        let index = this.getCycleMissionIndex(direction);
	        if (index === null || index === this.currentMissionIndex)
	            return;
	        this.currentMissionIndex = index;
	        this.displayMission();
	    }
	    /** Gets the mission index you would get by skipping a certain amount forwards/backwards while respecting the search query. Returns null if the index would peek outside of the current mission array. */
	    getCycleMissionIndex(direction) {
	        if (direction === 0)
	            return this.currentMissionIndex;
	        for (let i = this.currentMissionIndex + Math.sign(direction); i >= 0 && i < this.currentMissionArray.length; i += Math.sign(direction)) {
	            if (this.currentMissionArray[i].matchesSearch(this.currentQueryWords, this.currentQuery))
	                direction = Math.sign(direction) * (Math.abs(direction) - 1);
	            if (direction === 0)
	                return i;
	        }
	        return null;
	    }
	    /** Returns true if there is a next mission to go to. */
	    canGoNext() {
	        let canGoNext = false;
	        for (let i = this.currentMissionIndex + 1; i < this.currentMissionArray.length; i++) {
	            if (this.currentMissionArray[i].matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                canGoNext = true;
	                break;
	            }
	        }
	        return canGoNext;
	    }
	    /** Returns true if there is a previous mission to go back to. */
	    canGoPrev() {
	        let canGoPrev = false;
	        for (let i = this.currentMissionIndex - 1; i >= 0; i--) {
	            if (this.currentMissionArray[i].matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                canGoPrev = true;
	                break;
	            }
	        }
	        return canGoPrev;
	    }
	    updateNextPrevButtons() {
	        // Enable or disable the next button based on if there are still missions to come
	        if (!this.canGoNext()) {
	            this.nextButton.src = this.menu.uiAssetPath + 'play/next_i.png';
	            this.nextButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.nextButton.src.endsWith('i.png'))
	                this.nextButton.src = this.menu.uiAssetPath + 'play/next_n.png';
	            this.nextButton.style.pointerEvents = '';
	        }
	        // Enable or disable the prev button based on if there are still missions to come
	        if (!this.canGoPrev()) {
	            this.prevButton.src = this.menu.uiAssetPath + 'play/prev_i.png';
	            this.prevButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.prevButton.src.endsWith('i.png'))
	                this.prevButton.src = this.menu.uiAssetPath + 'play/prev_n.png';
	            this.prevButton.style.pointerEvents = '';
	        }
	    }
	    /** Sets and preloads images around the current level. */
	    setImages(fromTimeout = false, doTimeout = true) {
	        if (fromTimeout) {
	            // We come from a timeout, so clear it
	            clearTimeout(this.setImagesTimeout);
	            this.setImagesTimeout = null;
	        }
	        if (this.setImagesTimeout !== null && doTimeout) {
	            // There is currently a timeout ongoing; reset the timer and return.
	            clearTimeout(this.setImagesTimeout);
	            this.setImagesTimeout = setTimeout(() => this.setImages(true), 75);
	            return;
	        }
	        // List of missions whose image should be loaded
	        let toLoad = new Set();
	        // Preload the neighboring-mission images for faster flicking between missions without having to wait for images to load.
	        for (let i = 0; i <= 10; i++) {
	            let index = this.getCycleMissionIndex(Math.ceil(i / 2) * ((i % 2) ? 1 : -1)); // Go in an outward spiral pattern, but only visit the missions that match the current search
	            let mission = this.currentMissionArray[index];
	            if (!mission)
	                continue;
	            toLoad.add(mission);
	        }
	        // Preload the next shuffled missions
	        for (let mission of this.getNextShuffledMissions())
	            toLoad.add(mission);
	        for (let mission of toLoad) {
	            let imagePath = mission.getImagePath();
	            let start = performance.now();
	            ResourceManager$1.loadResource(imagePath).then(async (blob) => {
	                if (!blob)
	                    return;
	                if (mission === this.currentMission) {
	                    // Show the thumbnail if the mission is the same
	                    let dataUrl = await ResourceManager$1.readBlobAsDataUrl(blob);
	                    if (mission === this.currentMission) {
	                        clearTimeout(this.clearImageTimeout);
	                        this.clearImageTimeout = null;
	                        this.levelImage.src = dataUrl;
	                    }
	                }
	                let elapsed = performance.now() - start;
	                if (elapsed > 75 && !this.setImagesTimeout && doTimeout) {
	                    // If the image took too long to load, set a timeout to prevent spamming requests.
	                    this.setImagesTimeout = setTimeout(() => this.setImages(true), 75);
	                }
	            });
	        }
	    }
	    shuffle() {
	        if (this.currentMissionArray.length <= 1)
	            return;
	        // Find a random mission that isn't the current one
	        let nextIndex = this.currentMissionIndex;
	        while (nextIndex === this.currentMissionIndex) {
	            nextIndex = Math.floor(Util$1.popRandomNumber() * this.currentMissionArray.length);
	        }
	        this.currentMissionIndex = nextIndex;
	        this.displayMission();
	    }
	    /** Returns the next few missions that would be selected by repeating pressing of the shuffle button. */
	    getNextShuffledMissions() {
	        let missions = [];
	        if (this.currentMissionArray.length > 1) {
	            let lastIndex = this.currentMissionIndex;
	            let i = 0;
	            let count = 0;
	            while (count < 5) {
	                let randomNumber = Util$1.peekRandomNumber(i++);
	                let nextIndex = Math.floor(randomNumber * this.currentMissionArray.length);
	                if (lastIndex !== nextIndex) {
	                    let mission = this.currentMissionArray[nextIndex];
	                    missions.push(mission);
	                    count++;
	                }
	                lastIndex = nextIndex;
	            }
	        }
	        return missions;
	    }
	    displayBestTimes() {
	        var _a;
	        let randomId = Util$1.uuid();
	        this.lastDisplayBestTimesId = randomId;
	        let bestTimes = StorageManager$1.getBestTimesForMission((_a = this.currentMission) === null || _a === void 0 ? void 0 : _a.path, this.localScoresCount, this.scorePlaceholderName);
	        for (let i = 0; i < this.localScoresCount; i++) {
	            this.updateScoreElement(this.localBestTimesContainer.children[i], bestTimes[i], i + 1);
	        }
	        if (!this.currentMission) {
	            this.leaderboardLoading.style.display = 'none';
	            this.leaderboardScores.style.paddingTop = '0px';
	            this.leaderboardScores.style.paddingBottom = '0px';
	            for (let element of this.leaderboardScores.children)
	                element.style.display = 'none';
	        }
	        else {
	            this.leaderboardLoading.style.display = Leaderboard.isLoading(this.currentMission.path) ? 'block' : 'none';
	            this.updateOnlineLeaderboard();
	            setTimeout(() => this.updateOnlineLeaderboard()); // Sometimes, scrollTop isn't set properly, so do it again after a very short time
	        }
	    }
	    /** Creates a replay button for use in score elements. */
	    createReplayButton() {
	        let icon = document.createElement('img');
	        icon.src = "./assets/img/round_videocam_black_18dp.png";
	        icon.title = "Alt-Click to download";
	        const handler = async (download) => {
	            let mission = this.currentMission;
	            if (!mission)
	                return;
	            let attr = icon.getAttribute('data-score-id');
	            if (!attr)
	                return;
	            let replayData = await StorageManager$1.databaseGet('replays', attr);
	            if (!replayData)
	                return;
	            if (!download) {
	                this.playCurrentMission(replayData);
	            }
	            else {
	                Replay$1.download(replayData, mission);
	                if (Util$1.isTouchDevice && Util$1.isInFullscreen())
	                    this.menu.showAlertPopup('Downloaded', 'The .wrec has been downloaded.');
	            }
	        };
	        icon.addEventListener('click', async (e) => {
	            if (e.button !== 0)
	                return;
	            handler(e.altKey);
	        });
	        Util$1.onLongTouch(icon, () => {
	            handler(true);
	        });
	        icon.addEventListener('mouseenter', () => {
	            AudioManager$1.play('buttonover.wav');
	        });
	        icon.addEventListener('mousedown', (e) => {
	            if (e.button === 0)
	                AudioManager$1.play('buttonpress.wav');
	        });
	        return icon;
	    }
	    async updateReplayButton(element, score) {
	        element.style.display = 'none';
	        element.removeAttribute('data-score-id');
	        if (!score[2])
	            return;
	        let randomId = this.lastDisplayBestTimesId;
	        let count = await StorageManager$1.databaseCount('replays', score[2]);
	        if (randomId === this.lastDisplayBestTimesId && count > 0) {
	            element.style.display = 'block';
	            element.setAttribute('data-score-id', score[2]);
	        }
	    }
	    /** Updates the elements in the online leaderboard. Updates only the visible elements and adds padding to increase performance. */
	    updateOnlineLeaderboard() {
	        var _a;
	        let mission = this.currentMission;
	        if (!mission)
	            return;
	        let onlineScores = (_a = Leaderboard.scores.get(mission.path)) !== null && _a !== void 0 ? _a : [];
	        let elements = this.leaderboardScores.children;
	        let index = 0;
	        // Reset styling
	        this.leaderboardScores.style.paddingTop = '0px';
	        this.leaderboardScores.style.paddingBottom = '0px';
	        elements[index].style.display = 'block';
	        // Get the y of the top element
	        let currentY = elements[0].offsetTop - this.scrollWindow.scrollTop;
	        this.leaderboardScores.style.height = onlineScores.length * this.scoreElementHeight + 'px';
	        // As long as the top element is out of view, move to the next one. By doing this, we find the first element that's in view (from the top)
	        while (currentY < -this.scoreElementHeight && index < onlineScores.length) {
	            index++;
	            currentY += this.scoreElementHeight;
	        }
	        // Add padding to the top according to how many elements we've already passed at the top
	        this.leaderboardScores.style.paddingTop = index * this.scoreElementHeight + 'px';
	        for (let i = 0; i < elements.length; i++) {
	            let element = elements[i];
	            if (index < onlineScores.length) {
	                // If there's a score, apply it to the current element
	                let score = onlineScores[index];
	                element.style.display = 'block';
	                this.updateScoreElement(element, score, index + 1);
	            }
	            else {
	                // Hide the element otherwise
	                element.style.display = 'none';
	            }
	            index++;
	        }
	        // Add padding to the bottom according to how many scores there are still left
	        this.leaderboardScores.style.paddingBottom = Math.max(onlineScores.length - index, 0) * this.scoreElementHeight + 'px';
	    }
	    onSearchInputChange() {
	        // Normalize the search string and split it into words
	        let str = Util$1.removeSpecialCharacters(Util$1.normalizeString(this.searchInput.value.trim())).toLowerCase();
	        this.currentQuery = str;
	        this.currentQueryWords = str.split(' ');
	        if (!str)
	            this.currentQueryWords.length = 0;
	        this.selectBasedOnSearchQuery();
	        this.updateNextPrevButtons();
	    }
	    /** Selects a valid mission based on the current search query. */
	    selectBasedOnSearchQuery(display = true) {
	        var _a;
	        // Check if the current mission already matches the search. In that case, don't do anything.
	        if ((_a = this.currentMission) === null || _a === void 0 ? void 0 : _a.matchesSearch(this.currentQueryWords, this.currentQuery))
	            return;
	        // Find the first matching mission
	        for (let i = 0; i < this.currentMissionArray.length; i++) {
	            let mis = this.currentMissionArray[i];
	            if (mis.matchesSearch(this.currentQueryWords, this.currentQuery)) {
	                this.currentMissionIndex = i;
	                if (display)
	                    this.displayMission();
	                break;
	            }
	        }
	    }
	    showLoadReplayPrompt() {
	        // Show a file picker
	        let fileInput = document.createElement('input');
	        fileInput.setAttribute('type', 'file');
	        fileInput.setAttribute('accept', ".wrec");
	        fileInput.onchange = async () => {
	            try {
	                let file = fileInput.files[0];
	                let arrayBuffer = await ResourceManager$1.readBlobAsArrayBuffer(file);
	                let replay = Replay$1.fromSerialized(arrayBuffer);
	                let mission = MissionLibrary.allMissions.find(x => x.path === replay.missionPath);
	                if (!mission)
	                    throw new Error("Mission not found.");
	                if (G$1.modification === 'gold' && mission.path.startsWith('mbp')) {
	                    // We don't allow this
	                    G$1.menu.showAlertPopup('Warning', "You can't watch replays of Platinum level inside Marble Blast Gold.");
	                    return;
	                }
	                this.div.classList.add('hidden');
	                this.menu.loadingScreen.loadMission(mission, () => replay);
	            }
	            catch (e) {
	                G$1.menu.showAlertPopup('Error', "There was an error loading the replay.");
	                console.error(e);
	            }
	        };
	        fileInput.click();
	    }
	    handleControllerInput(gamepad) {
	        // A button to play
	        if (gamepad.buttons[0].value > 0.5 && !previousButtonState[0]) {
	            this.playCurrentMission();
	            AudioManager$1.play('buttonpress.wav');
	        }
	        // LT, RT to change category
	        if (gamepad.buttons[6].value > 0.5 && !previousButtonState[6]) {
	            // Should probably have a function for this tbh
	            if (this.currentMissionArray === MissionLibrary.goldIntermediate)
	                this.setMissionArray(MissionLibrary.goldBeginner);
	            else if (this.currentMissionArray === MissionLibrary.goldAdvanced)
	                this.setMissionArray(MissionLibrary.goldIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.goldCustom)
	                this.setMissionArray(MissionLibrary.goldAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.platinumBeginner)
	                this.setMissionArray(MissionLibrary.goldCustom);
	            else if (this.currentMissionArray === MissionLibrary.platinumIntermediate)
	                this.setMissionArray(MissionLibrary.platinumBeginner);
	            else if (this.currentMissionArray === MissionLibrary.platinumAdvanced)
	                this.setMissionArray(MissionLibrary.platinumIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.platinumExpert)
	                this.setMissionArray(MissionLibrary.platinumAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.platinumCustom)
	                this.setMissionArray(MissionLibrary.platinumExpert);
	            else if (this.currentMissionArray === MissionLibrary.ultraBeginner)
	                this.setMissionArray(MissionLibrary.platinumCustom);
	            else if (this.currentMissionArray === MissionLibrary.ultraIntermediate)
	                this.setMissionArray(MissionLibrary.ultraBeginner);
	            else if (this.currentMissionArray === MissionLibrary.ultraAdvanced)
	                this.setMissionArray(MissionLibrary.ultraIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.ultraCustom)
	                this.setMissionArray(MissionLibrary.ultraAdvanced);
	            AudioManager$1.play('buttonpress.wav');
	        }
	        if (gamepad.buttons[7].value > 0.5 && !previousButtonState[7]) {
	            // Should probably have a function for this tbh
	            if (this.currentMissionArray === MissionLibrary.goldBeginner)
	                this.setMissionArray(MissionLibrary.goldIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.goldIntermediate)
	                this.setMissionArray(MissionLibrary.goldAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.goldAdvanced)
	                this.setMissionArray(MissionLibrary.goldCustom);
	            else if (this.currentMissionArray === MissionLibrary.goldCustom)
	                this.setMissionArray(MissionLibrary.platinumBeginner);
	            else if (this.currentMissionArray === MissionLibrary.platinumBeginner)
	                this.setMissionArray(MissionLibrary.platinumIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.platinumIntermediate)
	                this.setMissionArray(MissionLibrary.platinumAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.platinumAdvanced)
	                this.setMissionArray(MissionLibrary.platinumExpert);
	            else if (this.currentMissionArray === MissionLibrary.platinumExpert)
	                this.setMissionArray(MissionLibrary.platinumCustom);
	            else if (this.currentMissionArray === MissionLibrary.platinumCustom)
	                this.setMissionArray(MissionLibrary.ultraBeginner);
	            else if (this.currentMissionArray === MissionLibrary.ultraBeginner)
	                this.setMissionArray(MissionLibrary.ultraIntermediate);
	            else if (this.currentMissionArray === MissionLibrary.ultraIntermediate)
	                this.setMissionArray(MissionLibrary.ultraAdvanced);
	            else if (this.currentMissionArray === MissionLibrary.ultraAdvanced)
	                this.setMissionArray(MissionLibrary.ultraCustom);
	            AudioManager$1.play('buttonpress.wav');
	        }
	        // D-pad left+right to change missions
	        if (gamepad.buttons[14].value > 0.5 && !previousButtonState[14]) {
	            this.cycleMission(-1);
	            AudioManager$1.play('buttonpress.wav');
	        }
	        if (gamepad.buttons[15].value > 0.5 && !previousButtonState[15]) {
	            this.cycleMission(1);
	            AudioManager$1.play('buttonpress.wav');
	        }
	    }
	}
	//# sourceMappingURL=level_select.js.map

	class MbgLevelSelect extends LevelSelect {
	    constructor() {
	        super(...arguments);
	        this.localScoresCount = 3;
	        this.scorePlaceholderName = "Nardo Polo";
	        this.scoreElementHeight = 14;
	    }
	    initProperties() {
	        this.div = document.querySelector('#level-select');
	        this.homeButton = document.querySelector('#level-select-home-button');
	        this.homeButtonSrc = 'play/back';
	        this.tabBeginner = document.querySelector('#tab-beginner');
	        this.tabIntermediate = document.querySelector('#tab-intermediate');
	        this.tabAdvanced = document.querySelector('#tab-advanced');
	        this.tabCustom = document.querySelector('#tab-custom');
	        this.scrollWindow = document.querySelector('#level-select-text-window-scrollable');
	        this.levelTitle = document.querySelector('#level-title');
	        this.levelArtist = document.querySelector('#level-artist');
	        this.levelDescription = document.querySelector('#level-description');
	        this.levelQualifyTime = document.querySelector('#level-qualify-time');
	        this.localBestTimesContainer = document.querySelector('#level-select-local-best-times');
	        this.leaderboardLoading = document.querySelector('#online-leaderboard-loading');
	        this.leaderboardScores = document.querySelector('#leaderboard-scores');
	        this.levelImage = document.querySelector('#level-image');
	        this.levelNumberElement = document.querySelector('#level-number');
	        this.prevButton = document.querySelector('#level-select-prev');
	        this.playButton = document.querySelector('#level-select-play');
	        this.nextButton = document.querySelector('#level-select-next');
	        this.searchInput = document.querySelector('#search-input');
	        this.loadReplayButton = document.querySelector('#load-replay-button');
	        this.shuffleButton = document.querySelector('#shuffle-button');
	    }
	    async init() {
	        await super.init();
	        const setupTab = (element, levels) => {
	            element.addEventListener('mousedown', (e) => {
	                if (e.button !== 0)
	                    return;
	                AudioManager$1.play('buttonpress.wav');
	            });
	            element.addEventListener('click', (e) => e.button === 0 && this.setMissionArray(levels));
	        };
	        setupTab(this.tabBeginner, MissionLibrary.goldBeginner);
	        setupTab(this.tabIntermediate, MissionLibrary.goldIntermediate);
	        setupTab(this.tabAdvanced, MissionLibrary.goldAdvanced);
	        setupTab(this.tabCustom, MissionLibrary.goldCustom);
	        this.loadReplayButton.addEventListener('click', async () => {
	            this.showLoadReplayPrompt();
	        });
	        this.loadReplayButton.addEventListener('mouseenter', () => {
	            AudioManager$1.play('buttonover.wav');
	        });
	        this.loadReplayButton.addEventListener('mousedown', (e) => {
	            if (e.button === 0)
	                AudioManager$1.play('buttonpress.wav');
	        });
	        this.shuffleButton.addEventListener('click', () => {
	            this.shuffle();
	        });
	        this.shuffleButton.addEventListener('mouseenter', () => {
	            AudioManager$1.play('buttonover.wav');
	        });
	        this.shuffleButton.addEventListener('mousedown', (e) => {
	            if (e.button === 0)
	                AudioManager$1.play('buttonpress.wav');
	        });
	        // Preload images and leaderboards
	        this.setMissionArray(MissionLibrary.goldCustom, false); // Make sure to disable the image timeouts so that no funky stuff happens
	        this.setMissionArray(MissionLibrary.goldAdvanced, false);
	        this.setMissionArray(MissionLibrary.goldIntermediate, false);
	        this.setMissionArray(MissionLibrary.goldBeginner, false);
	    }
	    setMissionArray(arr, doImageTimeout) {
	        super.setMissionArray(arr, doImageTimeout);
	        for (let elem of [this.tabBeginner, this.tabIntermediate, this.tabAdvanced, this.tabCustom]) {
	            elem.style.zIndex = "-1";
	        }
	        let index = [MissionLibrary.goldBeginner, MissionLibrary.goldIntermediate, MissionLibrary.goldAdvanced, MissionLibrary.goldCustom].indexOf(this.currentMissionArray);
	        let elem = [this.tabBeginner, this.tabIntermediate, this.tabAdvanced, this.tabCustom][index];
	        elem.style.zIndex = "0"; // Bring the tab to the front
	    }
	    displayMetadata() {
	        let mission = this.currentMission;
	        this.levelTitle.textContent = mission.title;
	        this.levelArtist.textContent = 'by ' + mission.artist.trim();
	        this.levelArtist.style.display = (mission.type === 'custom') ? 'block' : 'none'; // Only show the artist for custom levels
	        this.levelDescription.textContent = mission.description;
	        let qualifyTime = (mission.qualifyTime !== 0) ? mission.qualifyTime : Infinity;
	        this.levelQualifyTime.textContent = isFinite(qualifyTime) ? "Time to Qualify: " + Util$1.secondsToTimeString(qualifyTime / 1000) : '';
	        this.levelNumberElement.textContent = `${Util$1.uppercaseFirstLetter(mission.type)} Level ${this.currentMissionIndex + 1}`;
	    }
	    displayEmptyMetadata() {
	        this.levelTitle.innerHTML = '<br>';
	        this.levelArtist.style.display = 'none';
	        this.levelDescription.innerHTML = '<br>';
	        this.levelQualifyTime.innerHTML = '';
	        this.levelNumberElement.textContent = `Level ${this.currentMissionIndex + 1}`;
	    }
	    createScoreElement(includeReplayButton) {
	        let element = document.createElement('div');
	        element.classList.add('level-select-best-time');
	        let name = document.createElement('div');
	        element.appendChild(name);
	        let img = document.createElement('img');
	        img.src = "./assets/ui/play/goldscore.png";
	        element.appendChild(img);
	        let time = document.createElement('div');
	        element.appendChild(time);
	        if (includeReplayButton) {
	            element.appendChild(this.createReplayButton());
	        }
	        return element;
	    }
	    updateScoreElement(element, score, rank) {
	        let goldTime = 0;
	        let mission = this.currentMission;
	        if (mission)
	            goldTime = mission.goldTime;
	        element.children[0].textContent = rank + '. ' + score[0];
	        element.children[1].style.opacity = (score[1] <= goldTime) ? '' : '0';
	        element.children[2].textContent = Util$1.secondsToTimeString(score[1] / 1000);
	        if (element.children[3])
	            this.updateReplayButton(element.children[3], score);
	    }
	}
	//# sourceMappingURL=level_select_mbg.js.map

	class HomeScreen {
	    constructor(menu) {
	        this.initProperties();
	        menu.setupButton(this.playButton, this.playSrc, () => {
	            // Show the level select
	            this.hide();
	            menu.levelSelect.show();
	            Leaderboard.syncLeaderboard();
	        });
	        menu.setupButton(this.helpButton, this.helpSrc, () => {
	            // Show the help screen
	            this.hide();
	            menu.helpScreen.show();
	        }, undefined, undefined, G$1.modification === 'gold');
	        menu.setupButton(this.optionsButton, this.optionsSrc, () => {
	            // Show the options screen
	            this.hide();
	            menu.optionsScreen.show();
	        });
	        menu.setupButton(this.exitButton, this.exitSrc, () => {
	            window.close(); // Won't work unless PWA
	            if (!location.search.includes('app'))
	                location.href = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'; // Internet veterans will recognize this link
	        });
	        menu.setupButton(this.showChangelogButton, this.showChangelogSrc, () => {
	            this.changelogContainer.classList.remove('hidden');
	        }, undefined, undefined, G$1.modification === 'gold');
	        menu.setupButton(this.changelogBackButton, this.changelogBackSrc, () => {
	            this.changelogContainer.classList.add('hidden');
	        });
	        this.div.querySelector('.modification-switcher').addEventListener('click', () => {
	            setMenu((G$1.modification === 'gold') ? 'platinum' : 'gold');
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    async init() {
	        // Fetch and display the version history
	        let blob = await ResourceManager$1.loadResource('/api/version_history');
	        let text = await ResourceManager$1.readBlobAsText(blob);
	        let latestVersion = /(^|\n)## (\d+\.\d+\.\d+)/.exec(text)[2];
	        this.version.textContent = `MBW v${latestVersion}`;
	        if (Util$1.isTouchDevice) {
	            // Make sure it's not occluded by rounded corners
	            this.version.style.left = '15px';
	            this.version.style.bottom = '15px';
	        }
	        let classPrefix = (G$1.modification === 'gold') ? 'changelog' : 'mbp-changelog';
	        // Cheap conversion from markdown to HTML here
	        text = text.replace(/(^|\n)# (.*)/g, `$1<span class="${classPrefix}-h1">$2</span>`);
	        text = text.replace(/(^|\n)## (.*)/g, `$1<span class="${classPrefix}-h2">$2</span>`);
	        text = text.replace(/(^|\n)### (.*)/g, `$1<span class="${classPrefix}-h3">$2</span>`);
	        text = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
	        this.changelogContent.innerHTML = text;
	        // Decide if we should show the changelog on startup
	        if (StorageManager$1.data.lastSeenVersion) {
	            //let bigger = Util.compareVersions(latestVersion, StorageManager.data.lastSeenVersion) > 0;
	            let different = latestVersion !== StorageManager$1.data.lastSeenVersion;
	            if (different) {
	                // There's a newer version, go show the changes!
	                this.changelogContainer.classList.remove('hidden');
	                await StorageManager$1.onVersionUpgrade(StorageManager$1.data.lastSeenVersion);
	            }
	        }
	        else if (Object.keys(StorageManager$1.data.bestTimes).length > 0) {
	            // We assume that if there's at least one local score, the user has interacted with the website to an extent where we can show the changelog.
	            this.changelogContainer.classList.remove('hidden');
	        }
	        StorageManager$1.data.lastSeenVersion = latestVersion;
	        StorageManager$1.store();
	    }
	}
	//# sourceMappingURL=home.js.map

	class MbgHomeScreen extends HomeScreen {
	    initProperties() {
	        this.div = document.querySelector('#home-screen');
	        this.playButton = document.querySelector('#home-play');
	        this.optionsButton = document.querySelector('#home-options');
	        this.helpButton = document.querySelector('#home-help');
	        this.exitButton = document.querySelector('#home-exit');
	        this.showChangelogButton = document.querySelector('#show-changelog');
	        this.showChangelogText = document.querySelector('#show-changelog-text');
	        this.changelogContainer = document.querySelector('#changelog');
	        this.changelogBackButton = document.querySelector('#changelog-back');
	        this.changelogContent = document.querySelector('#changelog-content');
	        this.version = document.querySelector('#version');
	        this.playSrc = 'home/play';
	        this.optionsSrc = 'home/options';
	        this.helpSrc = 'home/help';
	        this.exitSrc = 'home/exit';
	        this.showChangelogSrc = 'motd/motd_buttn_textless';
	        this.changelogBackSrc = 'play/back';
	    }
	}
	//# sourceMappingURL=home_mbg.js.map

	class Menu {
	    constructor() {
	        this.gameUiDiv = document.querySelector('#game-ui');
	        this.popupContainer = document.querySelector('#popup-container');
	        this.popupCloseProcedures = new WeakMap();
	        this.activeButtonVariant = new Map();
	        this.variantChangeListeners = new Map();
	        this.menuDiv = this.getMenuDiv();
	        this.backgroundImage = this.getBackgroundImage();
	        this.home = this.createHome();
	        this.levelSelect = this.createLevelSelect();
	        this.loadingScreen = this.createLoadingScreen();
	        this.optionsScreen = this.createOptionsScreen();
	        this.helpScreen = this.createHelpScreen();
	        this.hud = this.createHud();
	        this.pauseScreen = this.createPauseScreen();
	        this.finishScreen = this.createFinishScreen();
	    }
	    /** Sets up a Torque GUI button element which can take on different variants and switch between them quickly. */
	    setupVaryingButton(element, paths, onclick, loadDisabledImage = false, triggerOnMouseDown = false, playHoverSound = true, rapidFireOnHold = false) {
	        let ogPaths = paths.slice();
	        paths = paths.map(x => this.uiAssetPath + x);
	        let held = false;
	        let hovered = false;
	        let rapidFireId;
	        const normal = () => paths[this.activeButtonVariant.get(element)] + '_n.png';
	        const hover = () => paths[this.activeButtonVariant.get(element)] + '_h.png';
	        const down = () => paths[this.activeButtonVariant.get(element)] + '_d.png';
	        const disabled = () => paths[this.activeButtonVariant.get(element)] + '_i.png';
	        /** Returns true iff the mouse is currently in the bounding box of this button. */
	        const touchInAabb = () => {
	            let radius = 10; // Reasonable guesstimate
	            let x = currentMousePosition.x / SCALING_RATIO$1;
	            let y = currentMousePosition.y / SCALING_RATIO$1;
	            let rect = element.getBoundingClientRect();
	            return x >= rect.x - radius && x < rect.x + rect.width + radius && y >= rect.y - radius && y < rect.y + rect.height + radius;
	        };
	        element.addEventListener('mouseenter', () => {
	            if (Util$1.isTouchDevice)
	                return;
	            hovered = true;
	            element.setAttribute('data-hovered', '');
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = held ? down() : hover();
	            if (!held && playHoverSound)
	                AudioManager$1.play('buttonover.wav');
	        });
	        element.addEventListener('mouseleave', () => {
	            if (Util$1.isTouchDevice)
	                return;
	            hovered = false;
	            element.removeAttribute('data-hovered');
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = normal();
	        });
	        element.addEventListener('touchmove', () => {
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = touchInAabb() ? down() : normal();
	        });
	        const onMouseDown = (e) => {
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (e.button !== 0)
	                return;
	            held = true;
	            if (!element.hasAttribute('data-locked'))
	                element.src = down();
	            AudioManager$1.play('buttonpress.wav');
	            if (triggerOnMouseDown) {
	                onclick(e);
	                if (rapidFireOnHold)
	                    rapidFireId = setTimeout(() => rapidFireId = setInterval(() => onclick(e), 30), 500);
	            }
	            window.addEventListener('mouseup', onMouseUp);
	            window.addEventListener('touchend', onTouchEnd);
	        };
	        element.addEventListener('mousedown', (e) => {
	            if (!Util$1.isTouchDevice)
	                onMouseDown(e);
	        });
	        element.addEventListener('touchstart', () => {
	            onMouseDown({ button: 0 });
	        });
	        const onMouseUp = () => {
	            held = false;
	            clearTimeout(rapidFireId);
	            clearInterval(rapidFireId);
	            // Remove the listeners to increase performance
	            window.removeEventListener('mouseup', onMouseUp);
	            window.removeEventListener('touchend', onTouchEnd);
	            if (element.style.pointerEvents === 'none')
	                return;
	            if (!element.hasAttribute('data-locked'))
	                element.src = hovered ? hover() : normal();
	        };
	        const onTouchEnd = (e) => {
	            if (held && !triggerOnMouseDown && touchInAabb()) {
	                onclick(e);
	            }
	            onMouseUp();
	        };
	        if (!triggerOnMouseDown)
	            element.addEventListener('click', (e) => {
	                if (e.isTrusted && (Util$1.isTouchDevice && 'ontouchstart' in window))
	                    return; // Do the extra check here to make sure people don't nuke themselves with options
	                if (e.button === 0)
	                    onclick(e);
	            });
	        for (let ogPath of ogPaths) {
	            if (!ogPath)
	                continue;
	            // Preload the images
	            this.activeButtonVariant.set(element, ogPaths.indexOf(ogPath));
	            ResourceManager$1.loadImage(normal());
	            ResourceManager$1.loadImage(hover());
	            ResourceManager$1.loadImage(down());
	            if (loadDisabledImage)
	                ResourceManager$1.loadImage(disabled());
	        }
	        const onVariantChange = () => {
	            if (held)
	                element.src = down();
	            else if (hovered)
	                element.src = hover();
	            else
	                element.src = normal();
	        };
	        this.variantChangeListeners.set(element, onVariantChange);
	        this.setButtonVariant(element, 0); // This will also set the button's default image
	    }
	    /** Sets up a Torque GUI button element. Adds listeners to show the correct _n, _d and _h variants and plays sounds. */
	    setupButton(element, path, onclick, loadDisabledImage, triggerOnMouseDown, playHoverSound, radidFireOnHold) {
	        this.setupVaryingButton(element, [path], onclick, loadDisabledImage, triggerOnMouseDown, playHoverSound, radidFireOnHold);
	    }
	    /** Sets the active button variant for a given button. */
	    setButtonVariant(element, index) {
	        this.activeButtonVariant.set(element, index);
	        this.variantChangeListeners.get(element)();
	    }
	    show() {
	        AudioManager$1.setAssetPath(this.audioAssetPath);
	        this.menuDiv.classList.remove('hidden');
	        setEnterFullscreenButtonVisibility(true);
	        if (Util$1.isWeeb) {
	            let before = AudioManager$1.assetPath;
	            AudioManager$1.assetPath = ''; // Quick hack
	            this.music = AudioManager$1.createAudioSource('./assets/music/renai.ogg', AudioManager$1.musicGain);
	            AudioManager$1.assetPath = before;
	        }
	        else {
	            this.music = AudioManager$1.createAudioSource(this.menuMusicSrc, AudioManager$1.musicGain);
	        }
	        this.music.setLoop(true);
	        this.music.play();
	        // These lines will just make the container visible forever after the page loading screen is passed
	        this.popupContainer.style.visibility = 'visible';
	        this.popupContainer.style.pointerEvents = 'auto';
	    }
	    hide() {
	        var _a;
	        this.menuDiv.classList.add('hidden');
	        (_a = this.music) === null || _a === void 0 ? void 0 : _a.stop();
	        setEnterFullscreenButtonVisibility(false);
	    }
	    showGameUi() {
	        this.gameUiDiv.classList.remove('hidden');
	    }
	    hideGameUi() {
	        this.gameUiDiv.classList.add('hidden');
	    }
	    createAlertBase(heading, body, custom) {
	        let div = document.createElement('div');
	        div.classList.add('hidden');
	        div.classList.add('popup');
	        div.classList.add((G$1.modification === 'gold') ? 'mbg' : 'mbp');
	        let clickPreventer = document.createElement('div');
	        let img = document.createElement('img');
	        img.onload = () => {
	            div.style.width = ((G$1.modification === 'gold') ? 400 : img.width) + 'px';
	            div.style.height = ((G$1.modification === 'gold') ? 250 : img.height) + 'px';
	            img.style.width = div.style.width;
	            img.style.height = div.style.height;
	            div.classList.remove('hidden');
	        };
	        img.src = this.popupBackgroundSrc;
	        let headingElem = document.createElement('p');
	        headingElem.classList.add('_heading');
	        headingElem.innerHTML = heading;
	        let bodyElem = document.createElement('p');
	        bodyElem.classList.add('_body');
	        bodyElem.innerHTML = body;
	        div.append(clickPreventer, img, headingElem, bodyElem);
	        if (custom) {
	            custom.classList.add('_custom');
	            // Timeout to let text get layouted (couldn't get it to work otherwise)
	            setTimeout(() => {
	                custom.style.top = 44 + bodyElem.clientHeight + 'px';
	                div.append(custom);
	            });
	        }
	        return div;
	    }
	    /** Shows a customizable alert pop-up on screen that the user can dismiss. */
	    showAlertPopup(heading, body, custom) {
	        return new Promise(resolve => {
	            let div = this.createAlertBase(heading, body, custom);
	            const close = () => {
	                this.popupContainer.removeChild(div);
	                if (this.popupContainer.children.length === 0)
	                    this.popupContainer.style.display = 'none';
	                window.removeEventListener('keydown', handler1);
	                window.removeEventListener('keyup', handler2);
	            };
	            this.popupCloseProcedures.set(div, close);
	            let okayButton = document.createElement('img');
	            okayButton.classList.add('_okay');
	            this.setupButton(okayButton, this.popupOkaySrc, () => {
	                close();
	                resolve();
	            });
	            let handler1 = (e) => {
	                if (e.key === 'Escape')
	                    okayButton.src = this.uiAssetPath + this.popupOkaySrc + '_d.png';
	            };
	            let handler2 = (e) => {
	                if (e.key === 'Escape')
	                    okayButton.click();
	            };
	            window.addEventListener('keydown', handler1);
	            window.addEventListener('keyup', handler2);
	            div.append(okayButton);
	            this.popupContainer.append(div);
	            this.popupContainer.style.display = '';
	        });
	    }
	    /** Shows a customizable confirm (yes/no) pop-up on screen. */
	    showConfirmPopup(heading, body, custom) {
	        return new Promise(resolve => {
	            let div = this.createAlertBase(heading, body, custom);
	            const close = () => {
	                this.popupContainer.removeChild(div);
	                if (this.popupContainer.children.length === 0)
	                    this.popupContainer.style.display = 'none';
	                window.removeEventListener('keydown', handler1);
	                window.removeEventListener('keyup', handler2);
	            };
	            this.popupCloseProcedures.set(div, close);
	            let noButton = document.createElement('img');
	            noButton.classList.add('_no');
	            this.setupButton(noButton, this.popupNoSrc, () => {
	                close();
	                resolve(false);
	            });
	            let yesButton = document.createElement('img');
	            yesButton.classList.add('_yes');
	            this.setupButton(yesButton, this.popupYesSrc, () => {
	                close();
	                resolve(true);
	            });
	            let handler1 = (e) => {
	                if (e.key === 'Escape')
	                    noButton.src = this.uiAssetPath + this.popupNoSrc + '_d.png';
	            };
	            let handler2 = (e) => {
	                if (e.key === 'Escape')
	                    noButton.click();
	            };
	            window.addEventListener('keydown', handler1);
	            window.addEventListener('keyup', handler2);
	            div.append(noButton, yesButton);
	            this.popupContainer.append(div);
	            this.popupContainer.style.display = '';
	        });
	    }
	    /** Closes all currently shown popups without resolving any of their promises. */
	    closeAllPopups() {
	        var _a;
	        for (let child of this.popupContainer.children) {
	            (_a = this.popupCloseProcedures.get(child)) === null || _a === void 0 ? void 0 : _a();
	        }
	    }
	    async init() {
	        AudioManager$1.setAssetPath(this.audioAssetPath);
	        await AudioManager$1.loadBuffers([this.menuMusicSrc, 'buttonover.wav', 'buttonpress.wav']);
	        await Promise.all([this.home.init(), this.levelSelect.init(), this.finishScreen.init(), this.optionsScreen.init(), this.helpScreen.init()]);
	        // Load pop-up stuff:
	        await ResourceManager$1.loadImages([this.popupBackgroundSrc]);
	        let dummy = document.createElement('img');
	        this.setupButton(dummy, this.popupOkaySrc, null);
	        this.setupButton(dummy, this.popupNoSrc, null);
	        this.setupButton(dummy, this.popupYesSrc, null);
	        this.home.show();
	    }
	}
	//# sourceMappingURL=menu.js.map

	const GAME_UPDATE_RATE = 120;
	//# sourceMappingURL=constants.js.map

	/** A parser for .ifl files, used to describe an animated sequence of materials. */
	class IflParser {
	    constructor(text) {
	        this.text = text;
	    }
	    parse() {
	        let lines = this.text.split('\n');
	        let keyframes = [];
	        for (let line of lines) {
	            line = line.trim();
	            if (line.startsWith('//'))
	                continue;
	            if (!line)
	                continue;
	            let parts = line.split(' ');
	            let count = parts[1] ? Number(parts[1]) : 1; // If no count is listed, is appears for exactly one keyframe.
	            for (let i = 0; i < count; i++) {
	                keyframes.push(parts[0]);
	            }
	        }
	        return keyframes;
	    }
	    /** Loads and parses an .ifl file. Returns a cached version if already loaded. */
	    static async loadFile(path) {
	        if (this.cachedFiles.get(path))
	            return this.cachedFiles.get(path);
	        let blob = await ResourceManager$1.loadResource(path);
	        let text = await ResourceManager$1.readBlobAsText(blob);
	        let parser = new IflParser(text);
	        let result = parser.parse();
	        this.cachedFiles.set(path, result);
	        return result;
	    }
	}
	IflParser.cachedFiles = new Map();
	//# sourceMappingURL=ifl_parser.js.map

	/** Defines the geometry for a 3D mesh. */
	class Geometry$1 {
	    constructor() {
	        /** A list of numbers describing the 3D coordinates of the vertices. */
	        this.positions = [];
	        /** A list of numbers describing the normals of the vertices. */
	        this.normals = [];
	        /** A list of numbers describing the UV texture coordinates of the vertices. */
	        this.uvs = [];
	        /** The list of vertex indices that should be drawn. */
	        this.indices = [];
	        /** For each vertex index, this array defines the material that vertex uses. Only really makes sense if all vertices that make up a triangle have the same material. */
	        this.materials = [];
	        this.validated = false;
	    }
	    /** Fills the normal and uv arrays so their lengths match with the vertex positions. */
	    fillRest() {
	        while (this.normals.length / 3 < this.positions.length / 3)
	            this.normals.push(0, 0, 0);
	        while (this.uvs.length / 2 < this.positions.length / 3)
	            this.uvs.push(0, 0);
	    }
	    /** Makes sure the geometry isn't ill-defined. */
	    validate() {
	        if (this.validated)
	            return;
	        // Check if all arrays actually describe the same amount of vertices
	        if (new Set([this.positions.length / 3, this.normals.length / 3, this.uvs.length / 2]).size !== 1) {
	            console.error(this);
	            throw new Error(`Geometry is invalid (vertex counts don't match):
Positions: ${this.positions.length / 3}
Normals: ${this.normals.length / 3}
Uvs: ${this.uvs.length / 2},
Material Indices: ${this.materials.length / 1}
			`);
	        }
	        // Check that all indices are in bounds
	        for (let i = 0; i < this.indices.length; i++) {
	            let index = this.indices[i];
	            if (index >= this.positions.length / 3) {
	                console.error(this);
	                throw new Error("Geometry is invalid (index points out of bounds)");
	            }
	        }
	        let tris = this.indices.length;
	        if (tris % 3)
	            throw new Error("Geometry is invalid (triangle count isn't a whole number): " + tris / 3);
	        this.validated = true;
	    }
	    /** Creates a UV sphere geometry. Largely taken from three.js source. */
	    static createSphereGeometry(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
	        let geometry = new Geometry$1();
	        widthSegments = Math.max(3, Math.floor(widthSegments));
	        heightSegments = Math.max(2, Math.floor(heightSegments));
	        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
	        let index = 0;
	        const grid = [];
	        const vertex = new Vector3$1();
	        const normal = new Vector3$1();
	        // buffers
	        const vertices = [];
	        const normals = [];
	        const uvs = [];
	        // generate vertices, normals and uvs
	        for (let iy = 0; iy <= heightSegments; iy++) {
	            const verticesRow = [];
	            const v = iy / heightSegments;
	            // special case for the poles
	            let uOffset = 0;
	            if (iy === 0 && thetaStart === 0) {
	                uOffset = 0.5 / widthSegments;
	            }
	            else if (iy === heightSegments && thetaEnd === Math.PI) {
	                uOffset = -0.5 / widthSegments;
	            }
	            for (let ix = 0; ix <= widthSegments; ix++) {
	                const u = ix / widthSegments;
	                // vertex
	                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
	                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	                vertices.push(vertex.x, vertex.y, vertex.z);
	                // normal
	                normal.copy(vertex).normalize();
	                normals.push(normal.x, normal.y, normal.z);
	                // uv
	                uvs.push(u + uOffset, 1 - v);
	                verticesRow.push(index++);
	            }
	            grid.push(verticesRow);
	        }
	        Util$1.pushArray(geometry.positions, vertices);
	        Util$1.pushArray(geometry.normals, normals);
	        Util$1.pushArray(geometry.uvs, uvs);
	        // indices
	        for (let iy = 0; iy < heightSegments; iy++) {
	            for (let ix = 0; ix < widthSegments; ix++) {
	                const a = grid[iy][ix + 1];
	                const b = grid[iy][ix];
	                const c = grid[iy + 1][ix];
	                const d = grid[iy + 1][ix + 1];
	                if (iy !== 0 || thetaStart > 0)
	                    geometry.indices.push(a, b, d);
	                if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
	                    geometry.indices.push(b, c, d);
	            }
	        }
	        Util$1.pushArray(geometry.materials, Array(geometry.indices.length).fill(0));
	        return geometry;
	    }
	}
	//# sourceMappingURL=geometry.js.map

	const IDENTITY_MATRIX = new Matrix4();
	/** Represents an object in 3D space. */
	class Object3D {
	    constructor(dynamic = false) {
	        this.parent = null;
	        /** The object's local transform. */
	        this.transform = new Matrix4();
	        this.position = new Vector3$1();
	        this.orientation = new Quaternion$1();
	        this.scale = new Vector3$1(1, 1, 1);
	        /** The object's global transform in world space. */
	        this.worldTransform = new Matrix4();
	        this.needsWorldTransformUpdate = true;
	        this.selfDynamic = dynamic;
	    }
	    /** Is true if the object itself or any of its ancestors are *dynamic*, i.e. have the ability to be added to and removed from scenes after scene compilation. Non-dynamic (static) objects have to be added before compilation. */
	    get dynamic() {
	        let node = this;
	        while (node) {
	            if (node.selfDynamic)
	                return true;
	            node = node.parent;
	        }
	        return false;
	    }
	    /** Updates this object's global transformation matrix. */
	    updateWorldTransform() {
	        var _a, _b;
	        // Multiply our parent's transform by our own local transform
	        this.worldTransform.copy((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.worldTransform) !== null && _b !== void 0 ? _b : IDENTITY_MATRIX).multiply(this.transform);
	        this.needsWorldTransformUpdate = false;
	        this.transform.decompose(this.position, this.orientation, this.scale); // Keep these values synced with the matrix
	    }
	    /** Marks the object as having received a change to its transform and needing to be updated. */
	    changedTransform() {
	        this.needsWorldTransformUpdate = true;
	        // Also signal it to all ancestors
	        let parent = this.parent;
	        while (parent && !parent.needsWorldTransformUpdate) {
	            parent.needsWorldTransformUpdate = true;
	            parent = parent.parent;
	        }
	    }
	    /** Updates the transformation matrix from position, orienation and scale values. */
	    recomputeTransform() {
	        this.transform.compose(this.position, this.orientation, this.scale);
	        this.changedTransform();
	    }
	    /** Traverses this Object3D and all its descendants and calls the callback on each Object3D. */
	    traverse(fn) {
	        fn(this);
	    }
	}
	//# sourceMappingURL=object_3d.js.map

	/** A mesh, defined by geometry and materials, can be added to a scene graph and rendered. */
	class Mesh$1 extends Object3D {
	    constructor(geometry, materials, dynamic) {
	        super(dynamic);
	        /** Whether or not the mesh info buffer needs to be updated because this mesh's info changed. */
	        this.needsMeshInfoBufferUpdate = true;
	        /** Whether or not the vertex buffers need to be updated because this mesh's geometry changed. */
	        this.needsVertexBufferUpdate = false;
	        this._opacity = 1.0;
	        this.castShadows = false;
	        /** Stores the vertex indices for each separate material of this mesh. */
	        this.materialIndices = [];
	        this.hasTransparentMaterials = false;
	        this.geometry = geometry;
	        this.materials = materials;
	    }
	    changedTransform() {
	        if (this.needsWorldTransformUpdate)
	            return;
	        super.changedTransform();
	        this.needsMeshInfoBufferUpdate = true;
	    }
	    get opacity() {
	        return this._opacity;
	    }
	    set opacity(value) {
	        if (value === this._opacity)
	            return;
	        this._opacity = value;
	        this.needsMeshInfoBufferUpdate = true;
	    }
	    updateMeshInfoBuffer(buffer, index) {
	        // The mesh info consists of the mesh's transform and other things. Since the last row of a transformation matrix is constant, that row is used to encode the other data.
	        buffer.set(this.worldTransform.elements, index);
	        buffer[index + 3] = this._opacity;
	        let flags = 0; // Unused right now
	        buffer[index + 7] = flags;
	        this.needsMeshInfoBufferUpdate = false;
	    }
	    compileMaterialIndices() {
	        if (this.materialIndices.length > 0)
	            return; // Mesh has already been compiled
	        let map = new Map();
	        for (let i = 0; i < this.geometry.indices.length; i++) {
	            let materialIndex = this.geometry.materials[i];
	            let material = this.materials[materialIndex];
	            let data = map.get(material);
	            if (!data) {
	                data = { material, indices: [] };
	                map.set(material, data);
	                this.materialIndices.push(data);
	            }
	            let index = this.geometry.indices[i];
	            data.indices.push(this.vboOffset + index); // Note we offset the index by our VBO offset so that the index actually makes sense within the whole VBO
	        }
	        for (let group of this.materialIndices) {
	            group.indexBuffer = new Uint32Array(group.indices); // We create a typed array here because we'll need for speedy copying later on
	        }
	    }
	}
	//# sourceMappingURL=mesh.js.map

	/** A material defines the visual appearance of a mesh and controls the vertex/fragment shaders that are needed to render it. */
	class Material$1 {
	    constructor() {
	        /** Identical materials will get merged into one. To keep materials separate, this differentiator value can be set to something that makes this material unique. */
	        this.differentiator = '';
	        this.diffuseMap = null;
	        this.envMap = null;
	        this.normalMap = null;
	        this.specularMap = null;
	        this.noiseMap = null;
	        this.emissive = false;
	        this.transparent = false;
	        /** When false, the depth buffer will not be written to. */
	        this.depthWrite = true;
	        this.opacity = 1;
	        this.blending = BlendingType.Normal;
	        /** When set to true, normals will be normalized in the shader before they are used. */
	        this.normalizeNormals = false;
	        /** Flips the V texture coordinate. */
	        this.flipY = false;
	        this.isSky = false;
	        /** Shadow materials show nothing but the shadow cast on them. */
	        this.isShadow = false;
	        this.receiveShadows = false;
	        this.reflectivity = 0;
	        /** Defines if the environment map is defined within a "Z-up" space. OpenGL normally uses a Y-up coordinate system, which is why this setting is necessary. */
	        this.envMapZUp = true;
	        /** Creates a more realistic reflection by making the object more reflective at its edges. */
	        this.useFresnel = false;
	        /** When set, the reflection ray is computed per-fragment and not per-vertex. */
	        this.useAccurateReflectionRay = false;
	        this.specularIntensity = 0;
	        this.shininess = 30;
	        /** If set, all incoming light will be saturated to at most 1.0 in each color channel. */
	        this.saturateIncomingLight = true;
	        this.visible = true;
	        /** Materials with a lower render order will be rendered first. */
	        this.renderOrder = 0;
	        /** The factor by which to scale all secondary map (normal & specular) UV coordinates by. */
	        this.secondaryMapUvFactor = 1;
	        this.hashCache = null;
	        this.defineChunkCache = null;
	    }
	    /** Gets the hash of the material. Two materials with the same configuration will have an identical hash. */
	    getHash() {
	        var _a, _b, _c, _d, _e;
	        if (this.hashCache)
	            return this.hashCache;
	        let components = [
	            this.differentiator,
	            (_a = this.diffuseMap) === null || _a === void 0 ? void 0 : _a.id,
	            (_b = this.envMap) === null || _b === void 0 ? void 0 : _b.id,
	            (_c = this.normalMap) === null || _c === void 0 ? void 0 : _c.id,
	            (_d = this.specularMap) === null || _d === void 0 ? void 0 : _d.id,
	            (_e = this.noiseMap) === null || _e === void 0 ? void 0 : _e.id,
	            this.emissive,
	            this.transparent,
	            this.depthWrite,
	            this.opacity,
	            this.blending,
	            this.normalizeNormals,
	            this.flipY,
	            this.isSky,
	            this.isShadow,
	            this.receiveShadows,
	            this.reflectivity,
	            this.envMapZUp,
	            this.useFresnel,
	            this.specularIntensity,
	            this.shininess,
	            this.saturateIncomingLight,
	            this.renderOrder,
	            this.secondaryMapUvFactor
	        ];
	        return this.hashCache = components.map(x => '' + x).join(' ');
	    }
	    /** Gets the #define chunk that needs to be prepended to both the vertex and fragment shaders to make the material work. */
	    getDefineChunk() {
	        if (this.defineChunkCache)
	            return this.defineChunkCache;
	        let defines = [];
	        if (this.diffuseMap)
	            defines.push('USE_DIFFUSE_MAP');
	        if (this.envMap)
	            defines.push('USE_ENV_MAP');
	        if (this.normalMap)
	            defines.push('USE_NORMAL_MAP');
	        if (this.specularMap)
	            defines.push('USE_SPECULAR_MAP');
	        if (this.noiseMap)
	            defines.push('USE_NOISE_MAP');
	        if (this.emissive)
	            defines.push('EMISSIVE');
	        if (this.transparent)
	            defines.push('TRANSPARENT');
	        if (this.normalizeNormals)
	            defines.push('NORMALIZE_NORMALS');
	        if (this.flipY)
	            defines.push('FLIP_Y');
	        if (this.isSky)
	            defines.push('IS_SKY');
	        if (this.isShadow)
	            defines.push('IS_SHADOW');
	        if (this.receiveShadows)
	            defines.push('RECEIVE_SHADOWS');
	        if (this.envMapZUp)
	            defines.push('ENV_MAP_Z_UP');
	        if (this.useFresnel)
	            defines.push('USE_FRESNEL');
	        if (this.useAccurateReflectionRay)
	            defines.push('USE_ACCURATE_REFLECTION_RAY');
	        if (this.specularIntensity)
	            defines.push('USE_SPECULAR');
	        if (this.saturateIncomingLight)
	            defines.push('SATURATE_INCOMING_LIGHT');
	        if (this.blending === BlendingType.Normal)
	            defines.push('USE_PREMULTIPLIED_ALPHA');
	        return this.defineChunkCache = defines.map(x => `#define ${x}\n`).join('');
	    }
	}
	//# sourceMappingURL=material.js.map

	var RigidBodyType;
	(function (RigidBodyType) {
	    RigidBodyType[RigidBodyType["Dynamic"] = 0] = "Dynamic";
	    RigidBodyType[RigidBodyType["Static"] = 1] = "Static"; // Has infinite mass and doesn't get affected by external forces such as gravity
	})(RigidBodyType || (RigidBodyType = {}));
	let v1$2 = new Vector3$1();
	let q1$2 = new Quaternion$1();
	class RigidBody {
	    constructor() {
	        this.world = null;
	        this.type = RigidBodyType.Dynamic;
	        /** Disabled bodies will be skipped in the simulation loop. */
	        this.enabled = true;
	        this.position = new Vector3$1();
	        this.orientation = new Quaternion$1();
	        this.linearVelocity = new Vector3$1();
	        this.angularVelocity = new Vector3$1();
	        this.gravity = new Vector3$1();
	        this.prevPosition = new Vector3$1();
	        this.prevOrientation = new Quaternion$1();
	        /** Indicates whether the previous values are valid, i.e. have been set. */
	        this.prevValid = false;
	        /** The shapes that make up this rigid body. */
	        this.shapes = [];
	        /** The list of collisions this body was a part of in the last simulation step. */
	        this.collisions = [];
	        this.inContactCcd = new Set();
	        this.newInContactCcd = new Set();
	    }
	    transformPoint(p) {
	        return p.applyQuaternion(this.orientation).add(this.position);
	    }
	    transformPointInv(p) {
	        q1$2.copy(this.orientation).conjugate();
	        return p.sub(this.position).applyQuaternion(q1$2);
	    }
	    /** Updates this body's position and orientation based on its linear and angular velocities. */
	    integrate(dt) {
	        if (this.type !== RigidBodyType.Dynamic)
	            return;
	        let translation = this.linearVelocity.clone().multiplyScalar(dt);
	        let rotation = this.angularVelocity.clone().multiplyScalar(dt);
	        if (translation.lengthSq() === 0 && rotation.lengthSq() === 0) {
	            return; // No need to integrate
	        }
	        this.applyTranslation(translation);
	        this.applyRotation(rotation);
	        this.syncShapes();
	    }
	    applyTranslation(translation) {
	        this.position.add(translation);
	    }
	    applyRotation(rotation) {
	        q1$2.setFromAxisAngle(v1$2.copy(rotation).normalize(), rotation.length());
	        this.orientation.multiplyQuaternions(q1$2, this.orientation).normalize();
	    }
	    storePrevious() {
	        this.prevPosition.copy(this.position);
	        this.prevOrientation.copy(this.orientation);
	        this.prevValid = true;
	    }
	    /** Reverts this body's state to a linearly interpolated state between the current and last states. */
	    revert(t) {
	        let posEq = this.position.equals(this.prevPosition);
	        let oriEq = this.orientation.equals(this.prevOrientation);
	        if (!posEq || !oriEq) {
	            this.position.lerpVectors(this.prevPosition, this.position, t);
	            q1$2.copy(this.orientation);
	            this.orientation.copy(this.prevOrientation).slerp(q1$2, t);
	        }
	        // Don't revert the velocities
	    }
	    addCollisionShape(shape) {
	        if (shape.body) {
	            throw new Error("Shape has already been added to a RigidBody.");
	        }
	        this.shapes.push(shape);
	        shape.body = this;
	        shape.updateBoundingBox();
	        if (this.type === RigidBodyType.Static) {
	            shape.mass = Infinity;
	            shape.invInertia.multiplyScalar(0);
	        }
	    }
	    removeCollisionShape(shape) {
	        if (!this.shapes.includes(shape))
	            return;
	        Util$1.removeFromArray(this.shapes, shape);
	        shape.body = null;
	    }
	    /** Updates this body's collision shapes' bounding boxes and positions in the octree. */
	    syncShapes() {
	        for (let i = 0; i < this.shapes.length; i++) {
	            let shape = this.shapes[i];
	            shape.updateBoundingBox();
	        }
	    }
	    /** Gets the relative motion vector of this body and `b2`. */
	    getRelativeMotionVector(dst, b2) {
	        return dst.copy(this.position).sub(this.prevPosition).sub(b2.position).add(b2.prevPosition);
	    }
	    updateCollisions(to) {
	        if (!this.enabled)
	            return;
	        if (this.type !== RigidBodyType.Dynamic) {
	            throw new Error("Can only manually recompute collisions for dynamic rigid bodies.");
	        }
	        // Remove our collisions for the other bodies and for ourselves
	        for (let collision of this.collisions) {
	            let otherBody = (collision.s1.body === this) ? collision.s2.body : collision.s1.body;
	            otherBody.collisions.splice(otherBody.collisions.indexOf(collision), 1);
	        }
	        this.collisions.length = 0;
	        if (to) {
	            this.collisions.push(...to);
	            for (let collision of this.collisions) {
	                let otherBody = (collision.s1.body === this) ? collision.s2.body : collision.s1.body;
	                otherBody.collisions.push(collision);
	            }
	        }
	        else {
	            this.world.cachedBroadphaseResults.clear();
	            this.world.computeCollisions(this.shapes, false);
	        }
	    }
	    /* eslint-disable  @typescript-eslint/no-unused-vars */
	    onBeforeIntegrate(dt) { }
	    onAfterIntegrate(dt) { }
	    onBeforeCollisionResponse(t, dt) { }
	    onAfterCollisionResponse(t, dt) { }
	}
	//# sourceMappingURL=rigid_body.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	const _vector1 = new Vector3$1();
	const _vector2 = new Vector3$1();
	const _normalMatrix = new Matrix3();
	/** A two dimensional surface that extends infinitely in 3d space, represented in Hessian normal form by a unit length normal vector and a constant. */
	class Plane$1 {
	    constructor(normal = new Vector3$1(1, 0, 0), constant = 0) {
	        // normal is assumed to be normalized
	        this.normal = normal;
	        this.constant = constant;
	    }
	    /** Sets this plane's normal and constant properties by copying the values from the given normal. */
	    set(normal, constant) {
	        this.normal.copy(normal);
	        this.constant = constant;
	        return this;
	    }
	    /** Set the individual components that define the plane. */
	    setComponents(x, y, z, w) {
	        this.normal.set(x, y, z);
	        this.constant = w;
	        return this;
	    }
	    /** Sets the plane's properties as defined by a normal and an arbitrary coplanar point. */
	    setFromNormalAndCoplanarPoint(normal, point) {
	        this.normal.copy(normal);
	        this.constant = -point.dot(this.normal);
	        return this;
	    }
	    /** Defines the plane based on the 3 provided points. The winding order is assumed to be counter-clockwise, and determines the direction of the normal. */
	    setFromCoplanarPoints(a, b, c) {
	        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
	        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	        this.setFromNormalAndCoplanarPoint(normal, a);
	        return this;
	    }
	    /** Copies the values of the passed plane's normal and constant properties to this plane. */
	    copy(plane) {
	        this.normal.copy(plane.normal);
	        this.constant = plane.constant;
	        return this;
	    }
	    /** Normalizes the normal vector, and adjusts the constant value accordingly. */
	    normalize() {
	        // Note: will lead to a divide by zero if the plane is invalid.
	        const inverseNormalLength = 1.0 / this.normal.length();
	        this.normal.multiplyScalar(inverseNormalLength);
	        this.constant *= inverseNormalLength;
	        return this;
	    }
	    /** Negates both the normal vector and the constant. */
	    negate() {
	        this.constant *= -1;
	        this.normal.negate();
	        return this;
	    }
	    /** Returns the signed distance from the point to the plane. */
	    distanceToPoint(point) {
	        return this.normal.dot(point) + this.constant;
	    }
	    /** Projects a point onto the plane. */
	    projectPoint(point, target) {
	        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
	    }
	    /** Returns a Vector3 coplanar to the plane, by calculating the projection of the normal vector at the origin onto the plane. */
	    coplanarPoint(target) {
	        return target.copy(this.normal).multiplyScalar(-this.constant);
	    }
	    /** Apply a Matrix4 to the plane. The matrix must be an affine, homogeneous transform. */
	    applyMatrix4(matrix, optionalNormalMatrix) {
	        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
	        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
	        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
	        this.constant = -referencePoint.dot(normal);
	        return this;
	    }
	    /** Translates the plane by the distance defined by the offset vector. Note that this only affects the plane constant and will not affect the normal vector. */
	    translate(offset) {
	        this.constant -= offset.dot(this.normal);
	        return this;
	    }
	    /** Checks to see if two planes are equal (their normal and constant properties match). */
	    equals(plane) {
	        return plane.normal.equals(this.normal) && plane.constant === this.constant;
	    }
	    /** Returns a new plane with the same normal and constant as this one. */
	    clone() {
	        return new Plane$1().copy(this);
	    }
	}
	//# sourceMappingURL=plane.js.map

	class Entity {
	    constructor(game) {
	        /** Entities with lower update order will be updated first. */
	        this.updateOrder = 0;
	        this.affectedBy = new Set();
	        this.restartable = false;
	        this.stateNeedsStore = false;
	        this.internalStateNeedsStore = true; // Start out true so we store it once in the beninging... in the... in the beni... in the beninging (listen properly)
	        this.applyUpdatesBeforeAdvance = false;
	        this.sendAllUpdates = false;
	        this.requireServerConfirmation = false;
	        this.game = game;
	    }
	    stop() { }
	    postUpdate() { }
	    beforeReconciliation() { }
	    afterReconciliation() { }
	    affect(otherObject) {
	        this.game.state.recordEntityInteraction(this, otherObject);
	    }
	    clearInteractions() {
	        this.affectedBy.clear();
	        Util$1.filterInPlace(this.game.state.affectionGraph, x => x.from !== this && x.to !== this);
	    }
	    getState() { return null; }
	    getInitialState() { return null; }
	    loadState(state, meta) { } // Todo: Define / write down somewhere that "remote" means that its a new update that came from the outside. If the same update is applied again later in a rewinding step, remote becomes false.
	    restart(frame) {
	        this.loadState(this.getInitialState(), { frame, remote: false });
	    }
	    getInternalState() { return null; }
	    loadInternalState(state, frame) { }
	}
	//# sourceMappingURL=entity.js.map

	const INTERIOR_DEFAULT_FRICTION = 1;
	const INTERIOR_DEFAULT_RESTITUTION = 1;
	const SMOOTH_SHADING_ANGLE_THRESHOLD = Math.cos(Util$1.degToRad(15));
	const specialFrictionFactor = {
	    "friction_high": 1.5,
	    "friction_low": 0.2,
	    "friction_none": 0.01,
	    "friction_ramp_yellow": 2.0,
	    "grass": 1.5,
	    "mmg_grass": 0.9,
	    "tarmac": 0.35,
	    "sand": 4.0,
	    "mmg_sand": 6.0,
	    "carpet": 6.0,
	    "rug": 6.0,
	    "water": 6.0,
	    "mmg_water": 6.0,
	    "ice1": 0.03,
	    "mmg_ice": 0.03,
	    "floor_bounce": 0.2,
	    "mbp_chevron_friction": 0.0,
	    "mbp_chevron_friction2": 0.0,
	    "mbp_chevron_friction3": 0.0
	};
	const specialResistutionFactor = {
	    "friction_high": 0.5,
	    "friction_low": 0.5,
	    "friction_none": 0.5,
	    "grass": 0.35,
	    "mmg_grass": 0.5,
	    "tarmac": 0.7,
	    "sand": 0.1,
	    "mmg_sand": 0.1,
	    "carpet": 0.5,
	    "rug": 0.5,
	    "water": 0.0,
	    "mmg_water": 0.0,
	    "ice1": 0.95,
	    "mmg_ice": 0.95,
	    //"floor_bounce": 0.0
	};
	const specialForces = {
	    "floor_bounce": 15
	};
	const specialMaterials = new Set([...Object.keys(specialFrictionFactor), ...Object.keys(specialResistutionFactor), ...Object.keys(specialForces)]);
	/** Creates a material with an additional normal map. */
	const createNormalMapMaterial = async (interior, baseTexture, normalTexture) => {
	    let diffuseMap = await interior.game.mission.getTexture(`interiors_mbu/${baseTexture}`);
	    let normalMap = await interior.game.mission.getTexture(`shaders/tex/${normalTexture}`);
	    let mat = new Material$1();
	    mat.normalMap = normalMap;
	    mat.diffuseMap = diffuseMap;
	    mat.saturateIncomingLight = false;
	    mat.receiveShadows = true;
	    return mat;
	};
	/** Creates a material with an additional normal and specularity map. */
	const createPhongMaterial = async (interior, baseTexture, specTexture, normalTexture, shininess, specularIntensity, secondaryMapUvFactor = 1) => {
	    let specularMap = specTexture && await interior.game.mission.getTexture(`shaders/tex/${specTexture}`);
	    let normalMap = normalTexture && await interior.game.mission.getTexture(`shaders/tex/${normalTexture}`);
	    let texture = await interior.game.mission.getTexture(`interiors_mbu/${baseTexture}`);
	    let mat = new Material$1();
	    mat.diffuseMap = texture;
	    mat.specularMap = specularMap;
	    mat.normalMap = normalMap;
	    mat.shininess = shininess;
	    mat.specularIntensity = specularIntensity;
	    mat.secondaryMapUvFactor = secondaryMapUvFactor;
	    mat.saturateIncomingLight = false;
	    mat.receiveShadows = true;
	    return mat;
	};
	/** Creates a material for a tile texture using an overlaid noise pattern. */
	const createNoiseTileMaterial = async (interior, baseTexture, noiseSuffix) => {
	    let diffuseMap = await interior.game.mission.getTexture(`interiors_mbu/${baseTexture}`);
	    let specularMap = await interior.game.mission.getTexture('shaders/tex/tile_mbu.spec.jpg');
	    let noiseMap = await interior.game.mission.getTexture(`shaders/tex/noise${noiseSuffix}.jpg`);
	    let normalMap = await interior.game.mission.getTexture('shaders/tex/tile_mbu.normal.png');
	    let mat = new Material$1();
	    mat.diffuseMap = diffuseMap;
	    mat.specularMap = specularMap;
	    mat.normalMap = normalMap;
	    mat.noiseMap = noiseMap;
	    mat.shininess = 40;
	    mat.specularIntensity = 0.7;
	    mat.saturateIncomingLight = false;
	    mat.receiveShadows = true;
	    return mat;
	};
	/** A list of custom materials for MBU. */
	const customMaterialFactories = {
	    'plate_1': (interior) => createPhongMaterial(interior, 'plate_1.jpg', 'plate_mbu.spec.jpg', 'plate_mbu.normal.png', 30, 0.5),
	    'tile_beginner': (interior) => createNoiseTileMaterial(interior, 'tile_beginner.png', ''),
	    'tile_beginner_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_shadow.png', ''),
	    'tile_beginner_red': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_red.jpg', ''),
	    'tile_beginner_red_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_red_shadow.png', ''),
	    'tile_beginner_blue': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_blue.jpg', ''),
	    'tile_beginner_blue_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_beginner_blue_shadow.png', ''),
	    'tile_intermediate': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate.png', ''),
	    'tile_intermediate_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_shadow.png', ''),
	    'tile_intermediate_red': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_red.jpg', ''),
	    'tile_intermediate_red_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_red_shadow.png', ''),
	    'tile_intermediate_green': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_green.jpg', ''),
	    'tile_intermediate_green_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_intermediate_green_shadow.png', ''),
	    'tile_advanced': (interior) => createNoiseTileMaterial(interior, 'tile_advanced.png', ''),
	    'tile_advanced_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_shadow.png', ''),
	    'tile_advanced_blue': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_blue.jpg', ''),
	    'tile_advanced_blue_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_blue_shadow.png', ''),
	    'tile_advanced_green': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_green.jpg', ''),
	    'tile_advanced_green_shadow': (interior) => createNoiseTileMaterial(interior, 'tile_advanced_green_shadow.png', ''),
	    'tile_underside': (interior) => createNoiseTileMaterial(interior, 'tile_underside.jpg', ''),
	    'wall_beginner': (interior) => createPhongMaterial(interior, 'wall_beginner.png', 'wall_mbu.spec.png', 'wall_mbu.normal.png', 30, 0.5),
	    'edge_white': (interior) => createPhongMaterial(interior, 'edge_white.jpg', 'edge_white_mbu.spec.jpg', 'edge_white_mbu.normal.jpg', 50, 4),
	    'edge_white_shadow': (interior) => createPhongMaterial(interior, 'edge_white_shadow.png', 'edge_white_mbu.spec.jpg', 'edge_white_mbu.normal.jpg', 50, 4),
	    'beam': (interior) => createNormalMapMaterial(interior, 'beam.png', 'beam_side_mbu.normal.png'),
	    'beam_side': (interior) => createNormalMapMaterial(interior, 'beam_side.png', 'beam_side_mbu.normal.png'),
	    'friction_low': (interior) => createPhongMaterial(interior, 'friction_low.jpg', null /*'friction_low_mbu.spec.png'*/, 'friction_low_mbu.normal.png', 100, 3),
	    'friction_low_shadow': (interior) => createPhongMaterial(interior, 'friction_low_shadow.png', null /*'friction_low_mbu.spec.png'*/, 'friction_low_mbu.normal.png', 100, 3),
	    'friction_high': (interior) => createPhongMaterial(interior, 'friction_high.png', 'friction_high_mbu.spec.png', 'friction_high_mbu.normal.png', 30, 0.8, 2),
	    'friction_high_shadow': (interior) => createPhongMaterial(interior, 'friction_high_shadow.png', 'friction_high_mbu.spec.png', 'friction_high_mbu.normal.png', 30, 0.8, 2),
	};
	/** Represents a Torque 3D Interior, used for the main surfaces and geometry of levels. */
	class Interior$1 extends Entity {
	    constructor(file, path, game, subObjectIndex) {
	        super(game);
	        this.worldMatrix = new Matrix4();
	        /** Simply contains the file names of the materials without the path to them. */
	        this.materialNames = [];
	        /** Whether or not frictions and bouncy floors work on this interior. */
	        this.allowSpecialMaterials = true;
	        this.dif = file;
	        this.difPath = path;
	        this.game = game;
	        this.detailLevel = (subObjectIndex === undefined) ? file.detailLevels[0] : file.subObjects[subObjectIndex];
	        this.materialNames = this.detailLevel.materialList.materials.map(x => x.split('/').pop().toLowerCase());
	        this.body = new RigidBody();
	        this.body.type = RigidBodyType.Static;
	        this.body.onAfterCollisionResponse = (t, dt) => {
	            for (let collision of this.body.collisions) {
	                let marble = collision.s1.body.userData;
	                this.onMarbleContact(collision, dt, marble);
	            }
	        };
	        // Combine the default special materials with the special ones specified in the .mis file
	        this.specialMaterials = new Set([...specialMaterials, ...Object.keys(this.game.mission.misFile.materialMappings)]);
	    }
	    async init(id) {
	        this.id = id;
	        this.body.evaluationOrder = id;
	        let cached = await Interior$1.initCache.get(this.detailLevel);
	        if (cached && cached.fancyShaders !== StorageManager$1.data.settings.fancyShaders) {
	            // The cached interior was created with a different shader setting, so assume it's invalid
	            Interior$1.initCache.delete(this.detailLevel);
	            cached = null;
	        }
	        if (!cached) {
	            // There is no cached init data for this detail level yet, so go and create it, girl
	            let resolveFunc;
	            let promise = new Promise(resolve => resolveFunc = resolve);
	            Interior$1.initCache.set(this.detailLevel, promise);
	            let materials = [];
	            for (let i = 0; i < this.detailLevel.materialList.materials.length; i++) {
	                let texName = this.detailLevel.materialList.materials[i].toLowerCase();
	                let fileName = texName.split('/').pop();
	                if (StorageManager$1.data.settings.fancyShaders && this.game.mission.modification === 'ultra' && customMaterialFactories[fileName]) {
	                    // There's a special way to create this material, prefer this instead of the normal way
	                    materials.push(await customMaterialFactories[fileName](this));
	                    continue;
	                }
	                let mat = new Material$1();
	                mat.receiveShadows = true;
	                materials.push(mat);
	                // Check for this special material which just makes the surface invisible (like a colmesh)
	                if (this.game.mission.modification === 'ultra' && fileName === 'tools_invisible') {
	                    mat.opacity = 0;
	                    continue;
	                }
	                let fullPath = this.difPath.includes('data/') ?
	                    this.difPath.slice(this.difPath.indexOf('data/') + 'data/'.length)
	                    : this.difPath.slice(this.difPath.indexOf('data_mbp/') + 'data_mbp/'.length);
	                const lookForTexture = async () => {
	                    let currentPath = fullPath;
	                    while (true) {
	                        // Search for the texture file inside-out, first looking in the closest directory and then searching in parent directories until it is found.
	                        currentPath = currentPath.slice(0, Math.max(0, currentPath.lastIndexOf('/')));
	                        if (!currentPath)
	                            break; // Nothing found
	                        let fullNames = this.game.mission.getFullNamesOf(currentPath + '/' + fileName);
	                        if (fullNames.length > 0) {
	                            let name = fullNames.find(x => !x.endsWith('.dif'));
	                            if (!name)
	                                break;
	                            // We found the texture file; create the texture.
	                            let texture = await this.game.mission.getTexture(currentPath + '/' + name);
	                            mat.diffuseMap = texture;
	                            break;
	                        }
	                    }
	                };
	                await lookForTexture(); // First look for the texture regularly
	                if (!mat.diffuseMap && fullPath.includes('interiors/')) {
	                    // If we didn't find the texture, try looking for it in the MBP folder.
	                    fullPath = fullPath.replace('interiors/', 'interiors_mbp/');
	                    await lookForTexture();
	                }
	            }
	            let geometry = new Geometry$1();
	            let vertexBuckets = new Map(); // Used for computing vertex normals by averaging face normals
	            // Add every surface
	            for (let surface of this.detailLevel.surfaces)
	                this.addSurface(geometry, surface, vertexBuckets);
	            // In order to achieve smooth shading, compute vertex normals by average face normals of faces with similar angles
	            for (let [, buckets] of vertexBuckets) {
	                for (let i = 0; i < buckets.length; i++) {
	                    let bucket = buckets[i];
	                    let avgNormal = new Vector3$1();
	                    // Average all vertex normals of this bucket
	                    for (let j = 0; j < bucket.normals.length; j++)
	                        avgNormal.add(bucket.normals[j]);
	                    avgNormal.multiplyScalar(1 / bucket.normals.length);
	                    // Write the normal vector into the buffers
	                    for (let j = 0; j < bucket.normalIndices.length; j++) {
	                        let arr = geometry.normals;
	                        let start = bucket.normalIndices[j];
	                        arr[start + 0] = avgNormal.x;
	                        arr[start + 1] = avgNormal.y;
	                        arr[start + 2] = avgNormal.z;
	                    }
	                }
	            }
	            cached = {
	                geometry,
	                materials,
	                fancyShaders: StorageManager$1.data.settings.fancyShaders
	            };
	            resolveFunc(cached);
	        }
	        // Create the mesh, add it to the scene, and done
	        let mesh = new Mesh$1(cached.geometry, cached.materials);
	        this.mesh = mesh;
	        this.game.initter.loadingState.loaded++;
	    }
	    /** Adds one surface worth of geometry. */
	    addSurface(geometry, surface, vertexBuckets) {
	        let detailLevel = this.detailLevel;
	        let texGenEqs = detailLevel.texGenEqs[surface.texGenIndex];
	        // These are needed for UVs
	        let texPlaneX = new Plane$1(new Vector3$1(texGenEqs.planeX.x, texGenEqs.planeX.y, texGenEqs.planeX.z), texGenEqs.planeX.d);
	        let texPlaneY = new Plane$1(new Vector3$1(texGenEqs.planeY.x, texGenEqs.planeY.y, texGenEqs.planeY.z), texGenEqs.planeY.d);
	        let planeData = detailLevel.planes[surface.planeIndex & ~0x8000]; // Mask it here because the bit at 0x8000 specifies whether or not to invert the plane's normal.
	        let planeNormal = detailLevel.normals[planeData.normalIndex];
	        //let geometryData = this.materialGeometry[surface.textureIndex];
	        let material = this.materialNames[surface.textureIndex];
	        let k = 0; // Keep track of the face's index for corrent vertex winding order.
	        for (let i = surface.windingStart; i < surface.windingStart + surface.windingCount - 2; i++) {
	            let i1 = this.detailLevel.windings[i];
	            let i2 = this.detailLevel.windings[i + 1];
	            let i3 = this.detailLevel.windings[i + 2];
	            if (k % 2 === 0) {
	                // Swap the first and last index to maintain correct winding order
	                let temp = i1;
	                i1 = i3;
	                i3 = temp;
	            }
	            let faceNormal = new Vector3$1(planeNormal.x, planeNormal.y, planeNormal.z);
	            if (surface.planeIndex & 0x8000)
	                faceNormal.negate(); // Invert the plane if so specified
	            for (let index of [i1, i2, i3]) {
	                let position = this.detailLevel.points[index];
	                // Figure out UV coordinates by getting the distances of the corresponding vertices to the plane.
	                let u = texPlaneX.distanceToPoint(new Vector3$1(position.x, position.y, position.z));
	                let v = texPlaneY.distanceToPoint(new Vector3$1(position.x, position.y, position.z));
	                if (this.game.mission.modification === 'ultra' && material === 'plate_1')
	                    u /= 2, v /= 2; // This one texture gets scaled up by 2x probably in the shader, but to avoid writing a separate shader we do it here.
	                geometry.positions.push(position.x, position.y, position.z);
	                geometry.normals.push(0, 0, 0); // Push a placeholder, we'll compute a proper normal later
	                geometry.uvs.push(u, v);
	                geometry.materials.push(surface.textureIndex);
	                geometry.indices.push(geometry.indices.length);
	                // Find the buckets for this vertex
	                let buckets = vertexBuckets.get(position);
	                if (!buckets) {
	                    // Create a new list of buckets if necessary
	                    buckets = [];
	                    vertexBuckets.set(position, buckets);
	                }
	                // Find the bucket for this vertex
	                let bucket;
	                for (let j = 0; j < buckets.length; j++) {
	                    bucket = buckets[j];
	                    // Check if the reference normal and current face normal point in roughly the same direction; in that case, use that bucket.
	                    if (faceNormal.dot(bucket.referenceNormal) > SMOOTH_SHADING_ANGLE_THRESHOLD)
	                        break;
	                    bucket = null;
	                }
	                if (!bucket) {
	                    // Create a new bucket if necessary
	                    bucket = {
	                        referenceNormal: faceNormal,
	                        normalIndices: [],
	                        normals: []
	                    };
	                    buckets.push(bucket);
	                }
	                // Add data
	                bucket.normalIndices.push(geometry.normals.length - 3);
	                bucket.normals.push(faceNormal);
	            }
	            k++;
	        }
	    }
	    addConvexHull(hullIndex, scale) {
	        let hull = this.detailLevel.convexHulls[hullIndex];
	        let materials = new Set();
	        // Add all materials
	        for (let j = hull.surfaceStart; j < hull.surfaceStart + hull.surfaceCount; j++) {
	            let surface = this.detailLevel.surfaces[this.detailLevel.hullSurfaceIndices[j]];
	            if (!surface)
	                continue;
	            let material = this.materialNames[surface.textureIndex];
	            if (!material)
	                continue;
	            if (!this.specialMaterials.has(material))
	                material = ''; // Not a special material, we can group them as one
	            materials.add(material);
	        }
	        if (materials.size === 0)
	            return;
	        let vertices = [];
	        // Get the vertices
	        for (let j = hull.hullStart; j < hull.hullStart + hull.hullCount; j++) {
	            let point = this.detailLevel.points[this.detailLevel.hullIndices[j]];
	            vertices.push(new Vector3$1(point.x * scale.x, point.y * scale.y, point.z * scale.z));
	        }
	        let shape = new ConvexHullCollisionShape(vertices);
	        if (materials.size === 1) {
	            let material = materials.values().next().value;
	            let properties = this.getCollisionMaterialProperties(material);
	            shape.friction = properties.friction;
	            shape.restitution = properties.restitution;
	            shape.userData = properties;
	        }
	        else {
	            for (let j = hull.surfaceStart; j < hull.surfaceStart + hull.surfaceCount; j++) {
	                let surface = this.detailLevel.surfaces[this.detailLevel.hullSurfaceIndices[j]];
	                if (!surface)
	                    continue;
	                let material = this.materialNames[surface.textureIndex];
	                if (!material)
	                    continue;
	                let planeData = this.detailLevel.planes[surface.planeIndex & ~0x8000];
	                let planeNormal = this.detailLevel.normals[planeData.normalIndex];
	                let faceNormal = new Vector3$1(planeNormal.x, planeNormal.y, planeNormal.z);
	                if (surface.planeIndex & 0x8000)
	                    faceNormal.negate();
	                let properties = this.getCollisionMaterialProperties(material);
	                shape.materialOverrides.set(faceNormal, properties);
	            }
	        }
	        this.body.addCollisionShape(shape);
	    }
	    getCollisionMaterialProperties(material) {
	        var _a, _b, _c, _d, _e;
	        let friction = INTERIOR_DEFAULT_RESTITUTION;
	        let restitution = INTERIOR_DEFAULT_RESTITUTION;
	        let force;
	        let isRandom = false;
	        if (this.allowSpecialMaterials) {
	            // Check for a custom material property override in the mission file
	            let specialMatProperties = this.game.mission.misFile.materialProperties[this.game.mission.misFile.materialMappings[material]];
	            let frictionFac = (_b = (_a = specialMatProperties === null || specialMatProperties === void 0 ? void 0 : specialMatProperties['friction']) !== null && _a !== void 0 ? _a : specialFrictionFactor[material]) !== null && _b !== void 0 ? _b : 1;
	            let restitutionFac = (_d = (_c = specialMatProperties === null || specialMatProperties === void 0 ? void 0 : specialMatProperties['restitution']) !== null && _c !== void 0 ? _c : specialResistutionFactor[material]) !== null && _d !== void 0 ? _d : 1;
	            force = (_e = specialMatProperties === null || specialMatProperties === void 0 ? void 0 : specialMatProperties['force']) !== null && _e !== void 0 ? _e : specialForces[material];
	            if (force !== undefined)
	                restitutionFac = 1; // Because we don't want anything to act weird
	            restitution *= restitutionFac;
	            friction *= frictionFac;
	        }
	        if (this.allowSpecialMaterials && (material === null || material === void 0 ? void 0 : material.startsWith('mbp_chevron_friction')))
	            isRandom = true;
	        return { friction, restitution, force, isRandom };
	    }
	    setTransform(position, orientation, scale) {
	        this.worldMatrix.compose(position, orientation, scale);
	        this.scale = scale;
	        this.mesh.transform.copy(this.worldMatrix);
	        this.body.position.copy(position);
	        this.body.orientation.copy(orientation);
	        for (let i = 0; i < this.detailLevel.convexHulls.length; i++)
	            this.addConvexHull(i, this.scale);
	    }
	    onMarbleContact(collision, dt, marble) {
	        let contactShape = collision.s2;
	        let materialProperties = (contactShape.userData || contactShape.materialOverrides.get(collision.s2MaterialOverride));
	        if (materialProperties.force !== undefined) {
	            // Set the velocity along the contact normal, but make sure it's capped
	            marble.setLinearVelocityInDirection(collision.normal, materialProperties.force, false);
	            marble.slidingTimeout = 2; // Make sure we don't slide on the interior after bouncing off it
	        }
	        else if (materialProperties.isRandom) {
	            let fac = dt / (1 / GAME_UPDATE_RATE);
	            let angVel = marble.body.angularVelocity.clone();
	            let movementVec = angVel.cross(collision.normal);
	            // Move the marble in the opposite direction
	            marble.body.linearVelocity.addScaledVector(movementVec, -0.0015 * fac);
	            marble.body.angularVelocity.multiplyScalar(1 + (0.07 * marble.speedFac * fac));
	        }
	    }
	    update() { }
	    render() { }
	    reset() { }
	    stop() { }
	    async onLevelStart() { }
	}
	/** Avoids recomputation of the same interior. */
	Interior$1.initCache = new WeakMap();
	//# sourceMappingURL=interior.js.map

	/** A group represents a collection of 3D objects. */
	class Group extends Object3D {
	    constructor() {
	        super(...arguments);
	        this.children = [];
	        /** Gets called when there's a change in the amount of descendents of this node. */
	        this.onDescendantChange = null;
	    }
	    add(child) {
	        if (child.parent)
	            child.parent.remove(child); // No weird double parent action
	        this.children.push(child);
	        child.parent = this;
	        this.signalChange(child);
	    }
	    remove(child) {
	        Util$1.removeFromArray(this.children, child);
	        child.parent = null;
	        this.signalChange(child);
	    }
	    updateWorldTransform() {
	        if (!this.needsWorldTransformUpdate)
	            return;
	        super.updateWorldTransform();
	        // Update the world transforms of all descendants
	        for (let child of this.children) {
	            if (child.needsWorldTransformUpdate)
	                child.updateWorldTransform();
	        }
	    }
	    changedTransform() {
	        super.changedTransform();
	        for (let child of this.children)
	            child.changedTransform();
	    }
	    traverse(fn) {
	        super.traverse(fn);
	        for (let child of this.children) {
	            child.traverse(fn);
	        }
	    }
	    signalChange(changed) {
	        var _a, _b;
	        // Signals a descendant count change to all ancestors
	        (_a = this.onDescendantChange) === null || _a === void 0 ? void 0 : _a.call(this, changed);
	        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.signalChange(changed);
	    }
	    /** Recursively sets the opacity of all objects in this group's subtree. */
	    setOpacity(value) {
	        for (let child of this.children) {
	            if (child instanceof Group)
	                child.setOpacity(value);
	            else
	                child.opacity = value;
	        }
	    }
	}
	//# sourceMappingURL=group.js.map

	/** A hardcoded list of shapes that should only use envmaps as textures. */
	const DROP_TEXTURE_FOR_ENV_MAP = new Set(['shapes/items/superjump.dts', 'shapes/items/antigravity.dts']);
	var MaterialFlags;
	(function (MaterialFlags) {
	    MaterialFlags[MaterialFlags["S_Wrap"] = 1] = "S_Wrap";
	    MaterialFlags[MaterialFlags["T_Wrap"] = 2] = "T_Wrap";
	    MaterialFlags[MaterialFlags["Translucent"] = 4] = "Translucent";
	    MaterialFlags[MaterialFlags["Additive"] = 8] = "Additive";
	    MaterialFlags[MaterialFlags["Subtractive"] = 16] = "Subtractive";
	    MaterialFlags[MaterialFlags["SelfIlluminating"] = 32] = "SelfIlluminating";
	    MaterialFlags[MaterialFlags["NeverEnvMap"] = 64] = "NeverEnvMap";
	    MaterialFlags[MaterialFlags["NoMipMap"] = 128] = "NoMipMap";
	    MaterialFlags[MaterialFlags["MipMap_ZeroBorder"] = 256] = "MipMap_ZeroBorder";
	    MaterialFlags[MaterialFlags["IflMaterial"] = 134217728] = "IflMaterial";
	    MaterialFlags[MaterialFlags["IflFrame"] = 268435456] = "IflFrame";
	    MaterialFlags[MaterialFlags["DetailMapOnly"] = 536870912] = "DetailMapOnly";
	    MaterialFlags[MaterialFlags["BumpMapOnly"] = 1073741824] = "BumpMapOnly";
	    MaterialFlags[MaterialFlags["ReflectanceMapOnly"] = -2147483648] = "ReflectanceMapOnly";
	})(MaterialFlags || (MaterialFlags = {}));
	var TSDrawPrimitive;
	(function (TSDrawPrimitive) {
	    TSDrawPrimitive[TSDrawPrimitive["Triangles"] = 0] = "Triangles";
	    TSDrawPrimitive[TSDrawPrimitive["Strip"] = 1073741824] = "Strip";
	    TSDrawPrimitive[TSDrawPrimitive["Fan"] = -2147483648] = "Fan";
	    TSDrawPrimitive[TSDrawPrimitive["Indexed"] = 536870912] = "Indexed";
	    TSDrawPrimitive[TSDrawPrimitive["NoMaterial"] = 268435456] = "NoMaterial";
	    TSDrawPrimitive[TSDrawPrimitive["MaterialMask"] = 268435455] = "MaterialMask";
	    TSDrawPrimitive[TSDrawPrimitive["TypeMask"] = -1073741824] = "TypeMask";
	})(TSDrawPrimitive || (TSDrawPrimitive = {}));
	/** Represents an object created from a DTS file. This is either a static object like the start pad or a sign, or an item like gems or powerups. */
	class Shape$1 extends Entity {
	    constructor() {
	        super(null);
	        /** Whether or not this shape is being used as a TSStatic. TSStatic are static, non-moving shapes that basically can't do anything. */
	        this.isTSStatic = false;
	        this.meshes = [];
	        /** Whether the marble can physically collide with this shape. */
	        this.collideable = true;
	        /** Not physical colliders, but a list bodies that overlap is checked with. This is used for things like force fields. */
	        this.colliders = [];
	        /** For each shape, the untransformed vertices of their convex hull geometry. */
	        this.shapeVertices = new Map();
	        this.currentlyColliding = new Set();
	        this.worldPosition = new Vector3$1();
	        this.worldOrientation = new Quaternion$1();
	        this.worldScale = new Vector3$1();
	        this.worldMatrix = new Matrix4();
	        /** Can be used to override certain material names. */
	        this.matNamesOverride = {};
	        this.castShadows = false;
	        /** Stores only the roots of the tree (no parent). */
	        this.rootGraphNodes = [];
	        /** One transformation matrix per DTS node */
	        this.nodeTransforms = [];
	        this.showSequences = true;
	        /** If the element has non-visual sequences, then these should be updated every simulation tick as well. */
	        this.hasNonVisualSequences = false;
	        /** Can be used to override the current keyframe of a sequence. */
	        this.sequenceKeyframeOverride = new WeakMap();
	        /** Stores the last-used keyframe of a sequence to reduce computational load. */
	        this.lastSequenceKeyframes = new WeakMap();
	        this.currentOpacity = 1;
	        this.restitution = INTERIOR_DEFAULT_RESTITUTION;
	        this.friction = INTERIOR_DEFAULT_FRICTION;
	        /** Whether or not to continuously spin. */
	        this.ambientRotate = false;
	        this.ambientSpinFactor = -1 / 3 * Math.PI * 2;
	        /** Whether or not collision meshes will receive shadows. */
	        this.receiveShadows = true;
	        this.materialPostprocessor = null;
	        /** Same shapes with a different shareId cannot share data. */
	        this.shareId = 0;
	        /** Whether or not to share the same node transforms with other shapes of the same type. */
	        this.shareNodeTransforms = true;
	        /** Whether or not to share the same materials with other shapes of the same type. */
	        this.shareMaterials = true;
	        /** A shape is a master if it was the first shape to run init() amongst those that share data with it. */
	        this.isMaster = false;
	        this.sounds = [];
	    }
	    /** Shapes with identical share hash can share data. */
	    getShareHash() {
	        return this.dtsPath + ' ' + this.constructor.name + ' ' + this.shareId;
	    }
	    async init(game, srcElement = null) {
	        var _a, _b, _c;
	        this.id = (_a = srcElement === null || srcElement === void 0 ? void 0 : srcElement._id) !== null && _a !== void 0 ? _a : 0;
	        this.game = game;
	        this.srcElement = srcElement;
	        (_b = this.colliderDtsPath) !== null && _b !== void 0 ? _b : (this.colliderDtsPath = this.dtsPath);
	        this.dts = await ((this.game) ? this.game.mission.getDts(this.dtsPath) : DtsParser.loadFile(ResourceManager$1.mainDataPath + this.dtsPath));
	        this.colliderDts = (this.dtsPath === this.colliderDtsPath) ? this.dts : await ((this.game) ? this.game.mission.getDts(this.colliderDtsPath) : DtsParser.loadFile(ResourceManager$1.mainDataPath + this.colliderDtsPath));
	        this.directoryPath = this.dtsPath.slice(0, this.dtsPath.lastIndexOf('/'));
	        this.group = new Group();
	        this.bodies = [];
	        this.materials = [];
	        this.materialInfo = new WeakMap();
	        // Check if there's already shared data from another shape of the same type
	        let sharedDataPromise = (_c = this.game) === null || _c === void 0 ? void 0 : _c.initter.sharedShapeData.get(this.getShareHash());
	        let sharedData;
	        if (sharedDataPromise) {
	            // If so, (maybe) wait for that data to complete initiation (might already be done)
	            sharedData = await sharedDataPromise;
	        }
	        else {
	            // If we're here, we're the first shape of this type, so let's prepare the shared data
	            let resolveFunc;
	            if (this.game) {
	                sharedDataPromise = new Promise((resolve) => resolveFunc = resolve);
	                this.game.initter.sharedShapeData.set(this.getShareHash(), sharedDataPromise);
	            }
	            for (let i = 0; i < this.dts.nodes.length; i++)
	                this.nodeTransforms.push(new Matrix4());
	            await this.computeMaterials();
	            // Build the node tree
	            let graphNodes = [];
	            for (let i = 0; i < this.dts.nodes.length; i++) {
	                let graphNode = {
	                    index: i,
	                    node: this.dts.nodes[i],
	                    children: [],
	                    parent: null
	                };
	                graphNodes.push(graphNode);
	            }
	            for (let i = 0; i < this.dts.nodes.length; i++) {
	                let node = this.dts.nodes[i];
	                if (node.parentIndex !== -1) {
	                    graphNodes[i].parent = graphNodes[node.parentIndex];
	                    graphNodes[node.parentIndex].children.push(graphNodes[i]);
	                }
	            }
	            this.graphNodes = graphNodes;
	            this.rootGraphNodes = graphNodes.filter((node) => !node.parent);
	            this.updateNodeTransforms();
	            let geometries = [];
	            let geometryMatrixIndices = []; // The index into nodeTransforms
	            let collisionGeometries = new Set();
	            // Go through all nodes and objects and create the geometry
	            for (let i = 0; i < this.dts.nodes.length; i++) {
	                let objects = this.dts.objects.filter((object) => object.nodeIndex === i);
	                for (let object of objects) {
	                    // Torque requires collision objects to start with "Col", so we use that here
	                    let isCollisionObject = this.dts.names[object.nameIndex].toLowerCase().startsWith("col");
	                    if (!isCollisionObject || this.collideable) {
	                        for (let j = object.startMeshIndex; j < object.startMeshIndex + object.numMeshes; j++) {
	                            let mesh = this.dts.meshes[j];
	                            if (!mesh)
	                                continue;
	                            if (mesh.parentMesh >= 0)
	                                continue; // If the node has a parent, skip it. Why? Don't know. Made teleport pad look correct.
	                            if (mesh.verts.length === 0)
	                                continue; // No need
	                            // The reason we precompute position/normal here is because skinned meshes need vector instances they can modify each frame.
	                            let vertices = mesh.verts.map((v) => new Vector3$1(v.x, v.y, v.z));
	                            let vertexNormals = mesh.norms.map((v) => new Vector3$1(v.x, v.y, v.z));
	                            let geometry = this.generateGeometryFromMesh(mesh, vertices, vertexNormals);
	                            geometries.push(geometry);
	                            geometryMatrixIndices.push(i);
	                            // Flag it
	                            if (isCollisionObject)
	                                collisionGeometries.add(geometry);
	                        }
	                    }
	                }
	            }
	            // Search for a skinned mesh (only in use for the tornado)
	            let skinnedMeshIndex = null;
	            for (let i = 0; i < this.dts.meshes.length; i++) {
	                let dtsMesh = this.dts.meshes[i];
	                if (!dtsMesh || dtsMesh.type !== MeshType.Skin)
	                    continue;
	                // Create arrays of zero vectors as they will get changed later anyway
	                let vertices = new Array(dtsMesh.verts.length).fill(null).map(() => new Vector3$1());
	                let vertexNormals = new Array(dtsMesh.norms.length).fill(null).map(() => new Vector3$1());
	                let geometry = this.generateGeometryFromMesh(dtsMesh, vertices, vertexNormals);
	                geometries.push(geometry); // Even though the mesh is animated, it doesn't count as dynamic because it's not part of any node and therefore cannot follow its transforms.
	                geometryMatrixIndices.push(null);
	                skinnedMeshIndex = i;
	                break; // This is technically not correct. A shape could have many skinned meshes, but the tornado only has one, so we gucci.
	            }
	            sharedData = {
	                materials: this.materials,
	                rootGraphNodes: this.rootGraphNodes,
	                nodeTransforms: this.nodeTransforms,
	                geometries,
	                geometryMatrixIndices,
	                collisionGeometries,
	                skinnedMeshIndex
	            };
	            this.isMaster = true;
	            resolveFunc === null || resolveFunc === void 0 ? void 0 : resolveFunc(sharedData);
	        }
	        if (!this.isMaster) {
	            // Copy some data from the shared data
	            this.nodeTransforms = sharedData.nodeTransforms;
	            if (!this.shareNodeTransforms)
	                this.nodeTransforms = this.nodeTransforms.map(x => x.clone());
	            if (this.shareMaterials)
	                this.materials = sharedData.materials;
	            else
	                await this.computeMaterials();
	            this.rootGraphNodes = sharedData.rootGraphNodes; // The node graph is necessarily identical
	        }
	        // Create the meshes for all geometries
	        for (let [i, geometry] of sharedData.geometries.entries()) {
	            let materials = this.materials;
	            if (sharedData.collisionGeometries.has(geometry)) {
	                // Create a special material that just receives shadows
	                let shadowMaterial = new Material$1();
	                shadowMaterial.isShadow = true;
	                shadowMaterial.transparent = true;
	                shadowMaterial.depthWrite = false;
	                materials = [shadowMaterial];
	                geometry.materials.fill(0);
	            }
	            let mesh = new Mesh$1(geometry, materials);
	            let transform = this.nodeTransforms[sharedData.geometryMatrixIndices[i]];
	            if (transform)
	                mesh.transform = transform;
	            if (this.castShadows)
	                mesh.castShadows = true;
	            this.group.add(mesh);
	            this.meshes.push(mesh);
	            if (sharedData.skinnedMeshIndex !== null && !this.skinMeshInfo) {
	                // Will be used for animating the skin later
	                this.skinMeshInfo = {
	                    meshIndex: sharedData.skinnedMeshIndex,
	                    vertices: this.dts.meshes[sharedData.skinnedMeshIndex].verts.map(_ => new Vector3$1()),
	                    normals: this.dts.meshes[sharedData.skinnedMeshIndex].norms.map(_ => new Vector3$1()),
	                    mesh: mesh
	                };
	            }
	        }
	        // Now, create an actual collision body for each collision object (will be initiated with geometry later)
	        for (let i = 0; i < this.colliderDts.nodes.length; i++) {
	            let objects = this.colliderDts.objects.filter((object) => object.nodeIndex === i);
	            for (let object of objects) {
	                let isCollisionObject = this.colliderDts.names[object.nameIndex].toLowerCase().startsWith("col");
	                if (isCollisionObject) {
	                    let body = new RigidBody();
	                    body.type = RigidBodyType.Static;
	                    body.userData = { nodeIndex: i };
	                    body.evaluationOrder = this.id;
	                    this.bodies.push(body);
	                }
	            }
	        }
	        // If there are no collision objects, add a single body which will later be filled with bounding box geometry.
	        if (this.bodies.length === 0 && !this.isTSStatic) {
	            let body = new RigidBody();
	            body.type = RigidBodyType.Static;
	            body.evaluationOrder = this.id;
	            this.bodies.push(body);
	        }
	        // Init collision handlers
	        for (let body of this.bodies) {
	            body.onBeforeIntegrate = () => {
	                for (let otherBody of this.currentlyColliding) {
	                    if (!body.collisions.some(x => x.s1.body === otherBody)) {
	                        this.currentlyColliding.delete(otherBody);
	                        this.internalStateNeedsStore = true;
	                        let marble = body.userData;
	                        this.onMarbleLeave(marble);
	                    }
	                }
	            };
	            body.onBeforeCollisionResponse = (t) => {
	                for (let collision of body.collisions) {
	                    let marble = collision.s1.body.userData;
	                    if (!this.currentlyColliding.has(collision.s1.body))
	                        this.onMarbleEnter(t, marble);
	                    this.onMarbleInside(t, marble);
	                    this.currentlyColliding.add(collision.s1.body);
	                    this.internalStateNeedsStore = true;
	                }
	            };
	            body.onAfterCollisionResponse = () => {
	                let chosenCollision = body.collisions[0]; // Just pick the first one, for now. There's not really a better way of choosing which one to pick, right?
	                let marble = chosenCollision.s1.body.userData;
	                this.onMarbleContact(chosenCollision, marble);
	            };
	        }
	        // Preload all sounds
	        await AudioManager$1.loadBuffers(this.sounds);
	        if (this.game)
	            this.game.initter.loadingState.loaded++;
	    }
	    /** Creates the materials for this shape. */
	    async computeMaterials() {
	        var _a;
	        let environmentMaterial = null;
	        for (let i = 0; i < this.dts.matNames.length; i++) {
	            let matName = this.matNamesOverride[this.dts.matNames[i]] || this.dts.matNames[i]; // Check the override
	            let flags = this.dts.matFlags[i];
	            let fullNames = ResourceManager$1.getFullNamesOf(this.directoryPath + '/' + matName).filter((x) => !x.endsWith('.dts'));
	            let fullName = fullNames.find(x => x.endsWith('.ifl')) || fullNames[0]; // Prefer .ifls
	            if (this.isTSStatic && environmentMaterial && DROP_TEXTURE_FOR_ENV_MAP.has(this.dtsPath)) {
	                // Simply use the env material again
	                this.materials.push(environmentMaterial);
	                continue;
	            }
	            let material = new Material$1();
	            if ((flags & MaterialFlags.SelfIlluminating) || environmentMaterial)
	                material.emissive = true;
	            this.materials.push(material);
	            if (matName instanceof Texture) {
	                material.diffuseMap = matName;
	            }
	            else if (!fullName || (this.isTSStatic && (flags & MaterialFlags.ReflectanceMapOnly))) {
	                // Usually do nothing. It's an plain white material without a texture.
	                // Ah EXCEPT if we're a TSStatic.
	                if (this.isTSStatic) {
	                    material.emissive = true;
	                    if (flags & MaterialFlags.ReflectanceMapOnly)
	                        environmentMaterial = material;
	                }
	            }
	            else if (fullName.endsWith('.ifl')) {
	                // Parse the .ifl file
	                let keyframes = await IflParser.loadFile(ResourceManager$1.mainDataPath + this.directoryPath + '/' + fullName);
	                let fullNameCache = new Map(); // To speed things up a bit for repeated entries
	                keyframes = keyframes.map(x => {
	                    var _a;
	                    if (fullNameCache.has(x))
	                        return fullNameCache.get(x);
	                    let fullName = (_a = ResourceManager$1.getFullNamesOf(this.directoryPath + '/' + x).filter((x) => !x.endsWith('.dts'))[0]) !== null && _a !== void 0 ? _a : x;
	                    fullNameCache.set(x, fullName);
	                    return fullName;
	                });
	                this.materialInfo.set(material, { keyframes });
	                // Preload all frames of the material animation
	                let promises = [];
	                for (let frame of new Set(keyframes)) {
	                    promises.push(ResourceManager$1.getTexture(this.directoryPath + '/' + frame));
	                }
	                let textures = await Promise.all(promises);
	                material.diffuseMap = textures[0]; // So that we compile the material in the right type of shader
	                material.differentiator = this.isTSStatic + ResourceManager$1.mainDataPath + this.directoryPath + '/' + fullName;
	            }
	            else {
	                let texture = await ResourceManager$1.getTexture(this.directoryPath + '/' + fullName);
	                material.diffuseMap = texture;
	            }
	            // Set some properties based on the flags
	            if (flags & MaterialFlags.Translucent) {
	                material.transparent = true;
	                material.depthWrite = false;
	            }
	            if (flags & MaterialFlags.Additive)
	                material.blending = BlendingType.Additive;
	            if (flags & MaterialFlags.Subtractive)
	                material.blending = BlendingType.Subtractive;
	            if (this.isTSStatic && !(flags & MaterialFlags.NeverEnvMap)) {
	                material.reflectivity = this.dts.matNames.length === 1 ? 1 : environmentMaterial ? 0.5 : 0.333;
	                material.envMap = this.game.renderer.envMap;
	            }
	            (_a = this.materialPostprocessor) === null || _a === void 0 ? void 0 : _a.call(this, material);
	        }
	        // If there are no materials, atleast add one environment one
	        if (this.materials.length === 0) {
	            let mat = new Material$1();
	            mat.emissive = true;
	            mat.envMap = this.game.renderer.envMap;
	            mat.reflectivity = 1;
	            this.materials.push(mat);
	        }
	    }
	    /** Generates geometry info from a given DTS mesh. */
	    generateGeometryFromMesh(dtsMesh, vertices, vertexNormals) {
	        let geometry = new Geometry$1();
	        for (let i = 0; i < vertices.length; i++) {
	            let vertex = vertices[i];
	            let uv = dtsMesh.tverts[i];
	            let normal = vertexNormals[i];
	            geometry.positions.push(vertex.x, vertex.y, vertex.z);
	            geometry.normals.push(normal.x, normal.y, normal.z);
	            geometry.uvs.push(uv.x, uv.y);
	        }
	        let ab = new Vector3$1();
	        let ac = new Vector3$1();
	        const addTriangleFromIndices = (i1, i2, i3, materialIndex) => {
	            // We first perform a check: If the computed face normal points in the opposite direction of all vertex normals, we need to invert the winding order of the vertices.
	            ab.set(vertices[i2].x - vertices[i1].x, vertices[i2].y - vertices[i1].y, vertices[i2].z - vertices[i1].z);
	            ac.set(vertices[i3].x - vertices[i1].x, vertices[i3].y - vertices[i1].y, vertices[i3].z - vertices[i1].z);
	            let normal = ab.cross(ac).normalize();
	            let dot1 = normal.dot(vertexNormals[i1]);
	            let dot2 = normal.dot(vertexNormals[i2]);
	            let dot3 = normal.dot(vertexNormals[i3]);
	            if (!this.dtsPath.includes('helicopter.dts'))
	                if (dot1 < 0 && dot2 < 0 && dot3 < 0)
	                    [i1, i3] = [i3, i1];
	            // ^ temp hardcoded fix
	            geometry.indices.push(i1, i2, i3);
	            geometry.materials.push(materialIndex, materialIndex, materialIndex);
	        };
	        for (let primitive of dtsMesh.primitives) {
	            let materialIndex = primitive.matIndex & TSDrawPrimitive.MaterialMask;
	            let drawType = primitive.matIndex & TSDrawPrimitive.TypeMask;
	            if (drawType === TSDrawPrimitive.Triangles) {
	                for (let i = primitive.start; i < primitive.start + primitive.numElements; i += 3) {
	                    let i1 = dtsMesh.indices[i];
	                    let i2 = dtsMesh.indices[i + 1];
	                    let i3 = dtsMesh.indices[i + 2];
	                    addTriangleFromIndices(i1, i2, i3, materialIndex);
	                }
	            }
	            else if (drawType === TSDrawPrimitive.Strip) {
	                let k = 0; // Keep track of current face for correct vertex winding order
	                for (let i = primitive.start; i < primitive.start + primitive.numElements - 2; i++) {
	                    let i1 = dtsMesh.indices[i];
	                    let i2 = dtsMesh.indices[i + 1];
	                    let i3 = dtsMesh.indices[i + 2];
	                    if (k % 2 === 0) {
	                        // Swap the first and last index to maintain correct winding order
	                        let temp = i1;
	                        i1 = i3;
	                        i3 = temp;
	                    }
	                    addTriangleFromIndices(i1, i2, i3, materialIndex);
	                    k++;
	                }
	            }
	            else if (drawType === TSDrawPrimitive.Fan) {
	                for (let i = primitive.start; i < primitive.start + primitive.numElements - 2; i++) {
	                    let i1 = dtsMesh.indices[primitive.start]; // Triangle fan starts at the start
	                    let i2 = dtsMesh.indices[i + 1];
	                    let i3 = dtsMesh.indices[i + 2];
	                    addTriangleFromIndices(i1, i2, i3, materialIndex);
	                }
	            }
	        }
	        return geometry;
	    }
	    /** Generates collision objects for this shape. Geometry will be generated later. */
	    generateCollisionObjects() {
	        let bodyIndex = 0;
	        let dts = this.colliderDts;
	        for (let i = 0; i < dts.nodes.length; i++) {
	            let objects = dts.objects.filter((object) => object.nodeIndex === i);
	            for (let object of objects) {
	                if (!dts.names[object.nameIndex].toLowerCase().startsWith("col"))
	                    continue;
	                let body = this.bodies[bodyIndex];
	                bodyIndex++;
	                for (let j = object.startMeshIndex; j < object.startMeshIndex + object.numMeshes; j++) {
	                    let mesh = dts.meshes[j];
	                    if (!mesh)
	                        continue;
	                    for (let primitive of mesh.primitives) {
	                        // Create the collision shape but with all zero vectors for now
	                        let shape = new ConvexHullCollisionShape(Array(primitive.numElements).fill(null).map(_ => new Vector3$1()));
	                        shape.restitution = this.restitution;
	                        shape.friction = this.friction;
	                        if (!this.collideable)
	                            shape.collisionDetectionMask = 0b10; // Collide with the big aux marble
	                        body.addCollisionShape(shape);
	                        // Remember the actual untransformed vertices for this geometry
	                        let vertices = mesh.indices.slice(primitive.start, primitive.start + primitive.numElements)
	                            .map((index) => mesh.verts[index])
	                            .map((vert) => new Vector3$1(vert.x, vert.y, vert.z));
	                        this.shapeVertices.set(shape, vertices);
	                    }
	                }
	            }
	        }
	        if (bodyIndex === 0 && !this.isTSStatic) {
	            // Create collision geometry based on the bounding box
	            let body = this.bodies[0];
	            let bounds = new Box3();
	            bounds.min.set(dts.bounds.min.x, dts.bounds.min.y, dts.bounds.min.z);
	            bounds.max.set(dts.bounds.max.x, dts.bounds.max.y, dts.bounds.max.z);
	            // Create an empty collision shape for now
	            let shape = new ConvexHullCollisionShape(Array(8).fill(null).map(_ => new Vector3$1()));
	            shape.restitution = this.restitution;
	            shape.friction = this.friction;
	            if (!this.collideable)
	                shape.collisionDetectionMask = 0b10; // Collide with the big aux marble
	            body.addCollisionShape(shape);
	            // All 8 vertices of the bounding cuboid
	            let vertices = Util$1.getBoxVertices(bounds);
	            this.shapeVertices.set(shape, vertices);
	        }
	    }
	    /** Recursively updates node transformations in the node tree.
	     * @param quaternions One quaternion for each node.
	     * @param translations One translation for each node.
	     * @param scales One scale for each node.
	     * @param bitfield Specifies which nodes have changed.
	     */
	    updateNodeTransforms(quaternions, translations, scales, bitfield = 0xffffffff) {
	        if (!quaternions) {
	            // Create the default array of quaternions
	            quaternions = this.dts.nodes.map((node, index) => {
	                let rotation = this.dts.defaultRotations[index];
	                let quaternion = new Quaternion$1(rotation.x, rotation.y, rotation.z, rotation.w);
	                quaternion.normalize();
	                quaternion.conjugate();
	                return quaternion;
	            });
	        }
	        if (!translations) {
	            // Create the default array of translations
	            translations = this.dts.nodes.map((node, index) => {
	                let translation = this.dts.defaultTranslations[index];
	                return new Vector3$1(translation.x, translation.y, translation.z);
	            });
	        }
	        if (!scales) {
	            // Create the default array of scales
	            scales = this.dts.nodes.map(() => {
	                return new Vector3$1().setScalar(1);
	            });
	        }
	        let utilityMatrix = new Matrix4();
	        const traverse = (node, needsUpdate) => {
	            if (((1 << node.index) & bitfield) !== 0)
	                needsUpdate = true;
	            if (needsUpdate) {
	                // Recompute the matrix
	                let mat = this.nodeTransforms[node.index];
	                if (!node.parent) {
	                    mat.identity();
	                }
	                else {
	                    mat.copy(this.nodeTransforms[node.parent.index]);
	                }
	                utilityMatrix.compose(translations[node.index], quaternions[node.index], scales[node.index]);
	                mat.multiplyMatrices(mat, utilityMatrix);
	            }
	            // Call all children
	            for (let i = 0; i < node.children.length; i++)
	                traverse(node.children[i], needsUpdate);
	        };
	        // Start with the roots
	        for (let i = 0; i < this.rootGraphNodes.length; i++) {
	            let rootNode = this.rootGraphNodes[i];
	            traverse(rootNode, false);
	        }
	    }
	    /** Updates the geometries of the bodies matching the bitfield based on node transforms. */
	    updateCollisionGeometry(bitfield) {
	        var _a;
	        for (let i = 0; i < this.bodies.length; i++) {
	            let body = this.bodies[i];
	            let mat;
	            if (((_a = body.userData) === null || _a === void 0 ? void 0 : _a.nodeIndex) !== undefined) {
	                if (((1 << body.userData.nodeIndex) & bitfield) === 0)
	                    continue;
	                mat = this.worldMatrix.clone();
	                mat.multiplyMatrices(this.worldMatrix, this.nodeTransforms[body.userData.nodeIndex]);
	            }
	            else {
	                mat = this.worldMatrix;
	            }
	            // For all shapes...
	            for (let shape of body.shapes) {
	                let vertices = this.shapeVertices.get(shape);
	                // Assign the transformed vectors to the vertices of the geometry
	                for (let i = 0; i < vertices.length; i++) {
	                    shape.points[i].copy(vertices[i]).applyMatrix4(mat);
	                }
	                shape.computeLocalBoundingBox();
	            }
	            body.syncShapes();
	        }
	    }
	    update(onlyVisual = false) {
	        var _a, _b, _c, _d;
	        // If onlyVisual is set, collision bodies need not be updated.
	        if (!this.showSequences)
	            return;
	        if (!onlyVisual && !this.hasNonVisualSequences)
	            return;
	        if (!this.shareNodeTransforms || this.isMaster)
	            for (let sequence of this.dts.sequences) {
	                let rot = (_a = sequence.rotationMatters[0]) !== null && _a !== void 0 ? _a : 0;
	                let trans = (_b = sequence.translationMatters[0]) !== null && _b !== void 0 ? _b : 0;
	                let scale = (_c = sequence.scaleMatters[0]) !== null && _c !== void 0 ? _c : 0;
	                let affectedCount = 0;
	                let completion = this.game.state.time / sequence.duration;
	                let quaternions;
	                let translations;
	                let scales;
	                // Possibly get the keyframe from the overrides
	                let actualKeyframe = (_d = this.sequenceKeyframeOverride.get(sequence)) !== null && _d !== void 0 ? _d : (completion * sequence.numKeyframes) % sequence.numKeyframes;
	                if (this.lastSequenceKeyframes.get(sequence) === actualKeyframe)
	                    continue;
	                this.lastSequenceKeyframes.set(sequence, actualKeyframe);
	                let keyframeLow = Math.floor(actualKeyframe);
	                let keyframeHigh = Math.ceil(actualKeyframe) % sequence.numKeyframes;
	                let t = (actualKeyframe - keyframeLow) % 1; // The completion between two keyframes
	                // Handle rotation sequences
	                if (rot > 0)
	                    quaternions = this.dts.nodes.map((node, index) => {
	                        let affected = ((1 << index) & rot) !== 0;
	                        if (affected) {
	                            let rot1 = this.dts.nodeRotations[sequence.numKeyframes * affectedCount + keyframeLow];
	                            let rot2 = this.dts.nodeRotations[sequence.numKeyframes * affectedCount + keyframeHigh];
	                            let quaternion1 = new Quaternion$1(rot1.x, rot1.y, rot1.z, rot1.w);
	                            quaternion1.normalize();
	                            quaternion1.conjugate();
	                            let quaternion2 = new Quaternion$1(rot2.x, rot2.y, rot2.z, rot2.w);
	                            quaternion2.normalize();
	                            quaternion2.conjugate();
	                            // Interpolate between the two quaternions
	                            quaternion1.slerp(quaternion2, t);
	                            affectedCount++;
	                            return quaternion1;
	                        }
	                        else {
	                            // The rotation for this node is not animated and therefore we return the default rotation.
	                            let rotation = this.dts.defaultRotations[index];
	                            let quaternion = new Quaternion$1(rotation.x, rotation.y, rotation.z, rotation.w);
	                            quaternion.normalize();
	                            quaternion.conjugate();
	                            return quaternion;
	                        }
	                    });
	                // Handle translation sequences
	                affectedCount = 0;
	                if (trans > 0)
	                    translations = this.dts.nodes.map((node, index) => {
	                        let affected = ((1 << index) & trans) !== 0;
	                        if (affected) {
	                            let trans1 = this.dts.nodeTranslations[sequence.numKeyframes * affectedCount + keyframeLow];
	                            let trans2 = this.dts.nodeTranslations[sequence.numKeyframes * affectedCount + keyframeHigh];
	                            affectedCount++;
	                            // Interpolate between the two translations
	                            return new Vector3$1(Util$1.lerp(trans1.x, trans2.x, t), Util$1.lerp(trans1.y, trans2.y, t), Util$1.lerp(trans1.z, trans2.z, t));
	                        }
	                        else {
	                            // The translation for this node is not animated and therefore we return the default translation.
	                            let translation = this.dts.defaultTranslations[index];
	                            return new Vector3$1(translation.x, translation.y, translation.z);
	                        }
	                    });
	                // Handle scale sequences
	                affectedCount = 0;
	                if (scale > 0)
	                    scales = this.dts.nodes.map((node, index) => {
	                        let affected = ((1 << index) & scale) !== 0;
	                        if (affected) {
	                            let scale1 = this.dts.nodeAlignedScales[sequence.numKeyframes * affectedCount + keyframeLow];
	                            let scale2 = this.dts.nodeAlignedScales[sequence.numKeyframes * affectedCount + keyframeHigh];
	                            affectedCount++;
	                            // Interpolate between the two scales
	                            return new Vector3$1(Util$1.lerp(scale1.x, scale2.x, t), Util$1.lerp(scale1.y, scale2.y, t), Util$1.lerp(scale1.z, scale2.z, t));
	                        }
	                        else {
	                            // The scale for this node is not animated and therefore we return the default scale.
	                            return new Vector3$1().setScalar(1); // Apparently always this
	                        }
	                    });
	                if (rot | trans | scale) {
	                    this.updateNodeTransforms(quaternions, translations, scales, rot | trans | scale);
	                    if (!onlyVisual)
	                        this.updateCollisionGeometry(rot | trans | scale);
	                }
	            }
	        for (let mesh of this.meshes) {
	            mesh.changedTransform();
	        }
	    }
	    render() {
	        let time = this.game.state.time;
	        this.update(true); // Execute an only-visual tick
	        if (this.skinMeshInfo && this.isMaster) {
	            // Update the skin mesh.
	            let info = this.skinMeshInfo;
	            let mesh = this.dts.meshes[info.meshIndex];
	            // Zero all vectors at first
	            for (let i = 0; i < info.vertices.length; i++) {
	                info.vertices[i].set(0, 0, 0);
	                info.normals[i].set(0, 0, 0);
	            }
	            // Compute the transformation matrix for each bone
	            let boneTransformations = [];
	            let boneTransformationsTransposed = [];
	            for (let i = 0; i < mesh.nodeIndices.length; i++) {
	                let mat = new Matrix4();
	                mat.elements = mesh.initialTransforms[i].slice();
	                mat.transpose();
	                mat.multiplyMatrices(this.nodeTransforms[mesh.nodeIndices[i]], mat);
	                boneTransformations.push(mat);
	                boneTransformationsTransposed.push(mat.clone().transpose());
	            }
	            // Now fill the vertex and normal vector values
	            let vec = new Vector3$1();
	            let vec2 = new Vector3$1();
	            for (let i = 0; i < mesh.vertIndices.length; i++) {
	                let vIndex = mesh.vertIndices[i];
	                let vertex = mesh.verts[vIndex];
	                let normal = mesh.norms[vIndex];
	                vec.set(vertex.x, vertex.y, vertex.z);
	                vec2.set(normal.x, normal.y, normal.z);
	                let mat = boneTransformations[mesh.boneIndices[i]];
	                vec.applyMatrix4(mat);
	                vec.multiplyScalar(mesh.weights[i]);
	                Util$1.m_matF_x_vectorF(mat, vec2);
	                vec2.multiplyScalar(mesh.weights[i]);
	                info.vertices[vIndex].add(vec);
	                info.normals[vIndex].add(vec2);
	            }
	            // Normalize the normals
	            for (let i = 0; i < info.normals.length; i++) {
	                let norm = info.normals[i];
	                let len2 = norm.dot(norm);
	                // This condition is also present in the Torque 3D source
	                if (len2 > 0.01)
	                    norm.normalize();
	            }
	            // Update the values in the buffer attributes
	            let geometry = info.mesh.geometry;
	            for (let i = 0; i < info.vertices.length; i++) {
	                let vertex = info.vertices[i];
	                let normal = info.normals[i];
	                geometry.positions[3 * i + 0] = vertex.x;
	                geometry.positions[3 * i + 1] = vertex.y;
	                geometry.positions[3 * i + 2] = vertex.z;
	                geometry.normals[3 * i + 0] = normal.x;
	                geometry.normals[3 * i + 1] = normal.y;
	                geometry.normals[3 * i + 2] = normal.z;
	            }
	        }
	        if (this.skinMeshInfo)
	            this.skinMeshInfo.mesh.needsVertexBufferUpdate = true;
	        // Handle animated materials
	        if (!this.shareMaterials || this.isMaster)
	            for (let i = 0; i < this.materials.length; i++) {
	                let info = this.materialInfo.get(this.materials[i]);
	                if (!info)
	                    continue;
	                let iflSequence = this.dts.sequences.find((seq) => seq.iflMatters[0] > 0);
	                if (!iflSequence || !this.showSequences)
	                    continue;
	                let completion = time / iflSequence.duration;
	                let keyframe = Math.floor(completion * info.keyframes.length) % info.keyframes.length;
	                let currentFile = info.keyframes[keyframe];
	                // Select the correct texture based on the frame and apply it
	                let texture = ResourceManager$1.getTextureFromCache(this.directoryPath + '/' + currentFile);
	                this.materials[i].diffuseMap = texture;
	            }
	        // Spin the shape round 'n' round
	        if (this.ambientRotate) {
	            let spinAnimation = new Quaternion$1();
	            let up = new Vector3$1(0, 0, 1);
	            spinAnimation.setFromAxisAngle(up, time * this.ambientSpinFactor);
	            let orientation = this.worldOrientation.clone();
	            spinAnimation.multiplyQuaternions(orientation, spinAnimation);
	            this.group.orientation.copy(spinAnimation);
	            this.group.recomputeTransform();
	        }
	    }
	    /** Updates the transform of the shape's objects and bodies. */
	    setTransform(position, orientation, scale) {
	        let scaleUpdated = scale.clone().sub(this.worldScale).length() !== 0;
	        this.worldPosition = position;
	        this.worldOrientation = orientation;
	        this.worldScale = scale;
	        this.worldMatrix.compose(position, orientation, scale);
	        this.group.position.copy(position);
	        this.group.orientation.copy(orientation);
	        this.group.scale.copy(scale);
	        this.group.recomputeTransform();
	        let colliderMatrix = new Matrix4();
	        colliderMatrix.compose(this.worldPosition, this.worldOrientation, new Vector3$1(1, 1, 1));
	        // Update the colliders
	        for (let collider of this.colliders) {
	            let mat = collider.transform.clone();
	            mat.multiplyMatrices(colliderMatrix, mat);
	            let position = new Vector3$1();
	            let orientation = new Quaternion$1();
	            mat.decompose(position, orientation, new Vector3$1());
	            collider.body.position.copy(position);
	            collider.body.orientation.copy(orientation);
	            collider.body.evaluationOrder = this.id;
	            while (collider.body.shapes.length)
	                collider.body.removeCollisionShape(collider.body.shapes[0]); // Remove all shapes
	            // Create the new shape
	            let shape = collider.generateShape(this.worldScale);
	            shape.collisionDetectionMask = 0b100; // Collide with the small aux marble
	            collider.body.addCollisionShape(shape);
	        }
	        if (scaleUpdated)
	            this.generateCollisionObjects(); // We need to recompute the geometry if the scale changed; this will always be called at least once in the first call
	        this.updateCollisionGeometry(0xffffffff); // Update collision geometry
	    }
	    /** Sets the opacity of the shape. Since there's no quick and easy way of doing this, this method recursively sets it for all materials. */
	    setOpacity(opacity) {
	        if (opacity === this.currentOpacity)
	            return;
	        this.currentOpacity = opacity;
	        this.group.setOpacity(opacity);
	    }
	    /** Adds a collider shape. Whenever the marble overlaps with the shape, a callback is fired. */
	    addCollider(generateShape, localTransform, onInside) {
	        let body = new RigidBody();
	        body.type = RigidBodyType.Static;
	        this.colliders.push({
	            generateShape: generateShape,
	            body: body,
	            transform: localTransform
	        });
	        body.onAfterCollisionResponse = (t, dt) => {
	            for (let collision of body.collisions) {
	                let marble = collision.s1.body.userData;
	                onInside(t, dt, marble);
	            }
	        };
	    }
	    /** Enable or disable collision. */
	    setCollisionEnabled(enabled) {
	        for (let body of this.bodies) {
	            body.enabled = enabled;
	        }
	    }
	    stop() { }
	    getInternalState() {
	        return {
	            currentlyColliding: new Set(this.currentlyColliding)
	        };
	    }
	    loadInternalState(state) {
	        this.currentlyColliding = new Set(state.currentlyColliding);
	    }
	    /* eslint-disable  @typescript-eslint/no-unused-vars */
	    onMarbleContact(collision, marble) { }
	    onMarbleInside(t, marble) { }
	    onMarbleEnter(t, marble) { }
	    onMarbleLeave(marble) { }
	    async onLevelStart() { }
	}
	//# sourceMappingURL=shape.js.map

	/** Encapsulates a vertex buffer object, its data and its vertex attributes. */
	class VertexBuffer {
	    constructor(renderer, data, attributes) {
	        /** Keeps track of what needs to be updated to send minimum data to the GPU when doing bufferSubData. */
	        this.updateRange = { start: Infinity, end: 0 };
	        this.renderer = renderer;
	        this.buffer = renderer.gl.createBuffer();
	        this.data = data;
	        this.attributes = attributes;
	        this.stride = Object.values(attributes).reduce((a, b) => a + b, 0);
	        if (Object.keys(attributes).length === 1)
	            this.stride = 0; // Indicates a tightly-packed vertex attribute
	        let { gl } = renderer;
	        // Upload the data and done
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
	        gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    }
	    /** Overrides a portion of this VBO's data. Will only be uploaded to the GPU with a call to `update()`. */
	    set(data, offset = 0) {
	        this.data.set(data, offset);
	        this.updateRange.start = Math.min(this.updateRange.start, offset);
	        this.updateRange.end = Math.max(this.updateRange.end, offset + data.length);
	    }
	    /** Uploads any changed data to the GPU. */
	    update() {
	        if (this.updateRange.start >= this.updateRange.end)
	            return;
	        let { gl } = this.renderer;
	        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
	        let slice = this.data.subarray(this.updateRange.start, this.updateRange.end); // This simply creates another view onto the same array buffer, no data is copied here, yay
	        gl.bufferSubData(gl.ARRAY_BUFFER, this.updateRange.start * Float32Array.BYTES_PER_ELEMENT, slice); // Doing it like this appears to be faster than using the new WebGL2 signature
	        // Reset the range
	        this.updateRange.start = Infinity;
	        this.updateRange.end = 0;
	    }
	    dispose() {
	        let { gl } = this.renderer;
	        gl.deleteBuffer(this.buffer);
	    }
	}
	// Most primitive thing ever
	class VertexBufferGroup {
	    constructor(buffers) {
	        this.buffers = buffers;
	    }
	}
	//# sourceMappingURL=vertex_buffer.js.map

	const PATHS = ['particles/bubble.png', 'particles/saturn.png', 'particles/smoke.png', 'particles/spark.png', 'particles/star.png', 'particles/twirl.png'];
	const MAX_PARTICLES_PER_GROUP = 2 ** 14;
	// These two buffers define the geometry of the billboard:
	const positions = new Float32Array(Array(MAX_PARTICLES_PER_GROUP).fill([
	    -0.5, -0.5,
	    0.5, -0.5,
	    0.5, 0.5,
	    -0.5, 0.5
	]).flat());
	const uvs = new Float32Array(Array(MAX_PARTICLES_PER_GROUP).fill([
	    0, 0,
	    1, 0,
	    1, 1,
	    0, 1
	]).flat());
	const indices = [];
	for (let i = 0; i < MAX_PARTICLES_PER_GROUP; i++)
	    indices.push(4 * i + 0, 4 * i + 1, 4 * i + 2, 4 * i + 0, 4 * i + 2, 4 * i + 3);
	/** Manages emitters and particles. */
	class ParticleManager$1 {
	    constructor(getTime) {
	        this.emitters = [];
	        this.particleGroups = new Map();
	        /** For non-instanced, legacy particles. */
	        this.particles = [];
	        this.getTime = getTime;
	    }
	    async init(renderer) {
	        this.renderer = renderer;
	        let { gl } = renderer;
	        // Setup the vertex buffers that will be used to draw all particles
	        this.positionBuffer = new VertexBuffer(renderer, positions, { 'position': 2 });
	        this.uvBuffer = new VertexBuffer(renderer, uvs, { 'uv': 2 });
	        this.bufferGroup = new VertexBufferGroup([this.positionBuffer, this.uvBuffer]);
	        this.indexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
	        let promises = [];
	        // Preload all textures so we can load them instantly from cache later
	        for (let path of PATHS) {
	            promises.push(ResourceManager$1.getTexture(path));
	        }
	        let textures = await Promise.all(promises);
	        for (let texture of textures)
	            texture.getGLTexture(renderer); // Also preload the GL texture
	    }
	    /** Gets or creates a particle group for the given options. */
	    getParticleGroup(o) {
	        let group = this.particleGroups.get(o);
	        if (!group) {
	            group = this.createParticleGroup(o);
	            this.particleGroups.set(o, group);
	        }
	        return group;
	    }
	    createParticleGroup(o) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
	        let attributes = {
	            'particleSpawnTime': 1,
	            'particleLifetime': 1,
	            'particlePosition': 3,
	            'particleVelocity': 3,
	            'particleInitialSpin': 1
	        };
	        const floatsPerParticle = Object.values(attributes).reduce((a, b) => a + b, 0);
	        const vertsPerParticle = 4;
	        let buffer = new Float32Array(floatsPerParticle * vertsPerParticle * MAX_PARTICLES_PER_GROUP); // Make the buffer large enough so that we won't ever have to worry about not being able to fit enough particles in
	        let vertexBuffer = new VertexBuffer(this.renderer, buffer, attributes);
	        let colorsMatrix = new Matrix4();
	        colorsMatrix.set(((_a = o.colors[0]) === null || _a === void 0 ? void 0 : _a.r) || 0, ((_b = o.colors[0]) === null || _b === void 0 ? void 0 : _b.g) || 0, ((_c = o.colors[0]) === null || _c === void 0 ? void 0 : _c.b) || 0, ((_d = o.colors[0]) === null || _d === void 0 ? void 0 : _d.a) || 0, ((_e = o.colors[1]) === null || _e === void 0 ? void 0 : _e.r) || 0, ((_f = o.colors[1]) === null || _f === void 0 ? void 0 : _f.g) || 0, ((_g = o.colors[1]) === null || _g === void 0 ? void 0 : _g.b) || 0, ((_h = o.colors[1]) === null || _h === void 0 ? void 0 : _h.a) || 0, ((_j = o.colors[2]) === null || _j === void 0 ? void 0 : _j.r) || 0, ((_k = o.colors[2]) === null || _k === void 0 ? void 0 : _k.g) || 0, ((_l = o.colors[2]) === null || _l === void 0 ? void 0 : _l.b) || 0, ((_m = o.colors[2]) === null || _m === void 0 ? void 0 : _m.a) || 0, ((_o = o.colors[3]) === null || _o === void 0 ? void 0 : _o.r) || 0, ((_p = o.colors[3]) === null || _p === void 0 ? void 0 : _p.g) || 0, ((_q = o.colors[3]) === null || _q === void 0 ? void 0 : _q.b) || 0, ((_r = o.colors[3]) === null || _r === void 0 ? void 0 : _r.a) || 0);
	        colorsMatrix.transpose();
	        // Set all the values that are true for every particle of this type
	        let uniforms = {
	            acceleration: o.acceleration,
	            spinSpeed: Util$1.degToRad(o.spinSpeed),
	            dragCoefficient: o.dragCoefficient,
	            times: new Float32Array([(_s = o.times[0]) !== null && _s !== void 0 ? _s : Infinity, (_t = o.times[1]) !== null && _t !== void 0 ? _t : Infinity, (_u = o.times[2]) !== null && _u !== void 0 ? _u : Infinity, (_v = o.times[3]) !== null && _v !== void 0 ? _v : Infinity]),
	            sizes: new Float32Array([o.sizes[0] || 0, o.sizes[1] || 0, o.sizes[2] || 0, o.sizes[3] || 0]),
	            colors: new Float32Array(colorsMatrix.elements)
	        };
	        let group = {
	            vertexBuffer: vertexBuffer,
	            uniforms,
	            particles: []
	        };
	        return group;
	    }
	    createEmitter(options, initialPos, getPos, spawnSphereSquish) {
	        var _a;
	        let emitter = new ParticleEmitter(options, this, getPos, spawnSphereSquish);
	        emitter.currPos = (_a = getPos === null || getPos === void 0 ? void 0 : getPos()) !== null && _a !== void 0 ? _a : initialPos.clone();
	        emitter.currPosTime = this.getTime();
	        emitter.spawn(this.getTime());
	        this.emitters.push(emitter);
	        return emitter;
	    }
	    removeEmitter(emitter) {
	        Util$1.removeFromArray(this.emitters, emitter);
	    }
	    render() {
	        let time = this.getTime();
	        this.currentRenderTime = time;
	        // Tick all emitters
	        for (let i = 0; i < this.emitters.length; i++) {
	            let emitter = this.emitters[i];
	            if (emitter.getPos)
	                emitter.setPos(emitter.getPos(), time);
	            let alive = emitter.tick(time);
	            if (!alive)
	                this.emitters.splice(i--, 1);
	        }
	        // Update all the particle groups
	        for (let [, group] of this.particleGroups) {
	            for (let i = 0; i < group.particles.length; i++) {
	                let particle = group.particles[i];
	                let dead = !particle.isAlive(time);
	                if (dead) {
	                    if (i < group.particles.length - 1) {
	                        // Since we want the array to be contiguous, swap in the last particle in the list to fill the hole
	                        group.particles[i] = group.particles[group.particles.length - 1];
	                        group.particles[i].applyToGroup(group, i);
	                    }
	                    group.particles.length--;
	                    i--;
	                }
	            }
	            group.vertexBuffer.update();
	        }
	    }
	    dispose() {
	        for (let [, group] of this.particleGroups) {
	            group.vertexBuffer.dispose();
	        }
	    }
	}
	class ParticleEmitter {
	    constructor(options, manager, getPos, spawnSphereSquish) {
	        this.vel = new Vector3$1();
	        this.velComputed = false;
	        this.o = options;
	        this.manager = manager;
	        this.getPos = getPos;
	        this.spawnSphereSquish = spawnSphereSquish !== null && spawnSphereSquish !== void 0 ? spawnSphereSquish : new Vector3$1(1, 1, 1);
	    }
	    spawn(time) {
	        this.spawnTime = time;
	        this.emit(time);
	    }
	    tick(time) {
	        // Cap the amount of particles emitted in such a case to prevent lag
	        if (time - this.lastEmitTime >= 1000)
	            this.lastEmitTime = time - 1000;
	        // Spawn as many particles as needed
	        while (this.lastEmitTime + this.currentWaitPeriod <= time) {
	            this.emit(this.lastEmitTime + this.currentWaitPeriod);
	            let completion = Util$1.clamp((this.lastEmitTime - this.spawnTime) / this.o.emitterLifetime, 0, 1);
	            if (completion === 1)
	                return false;
	        }
	        return true;
	    }
	    /** Emit a single particle. */
	    emit(time) {
	        this.lastEmitTime = time;
	        this.currentWaitPeriod = this.o.ejectionPeriod;
	        if (this.getPos && !this.velComputed)
	            return;
	        let pos = this.getPosAtTime(time).clone();
	        if (this.o.spawnOffset)
	            pos.add(this.o.spawnOffset()); // Call the spawnOffset function if it's there
	        // Generate a point uniformly chosen on a sphere's surface.
	        let randomPointOnSphere = new Vector3$1().randomDirection();
	        randomPointOnSphere.multiply(this.spawnSphereSquish);
	        // Compute the total velocity
	        let vel = this.vel.clone().multiplyScalar(this.o.inheritedVelFactor).add(randomPointOnSphere.multiplyScalar(this.o.ejectionVelocity + this.o.velocityVariance * (Math.random() * 2 - 1))).add(this.o.ambientVelocity);
	        let group = this.manager.getParticleGroup(this.o.particleOptions);
	        if (group.particles.length === MAX_PARTICLES_PER_GROUP)
	            return;
	        let particle = new Particle(this.o.particleOptions, this.manager, time, pos, vel);
	        particle.applyToGroup(group, group.particles.length);
	        group.particles.push(particle);
	    }
	    /** Computes the interpolated emitter position at a point in time. */
	    getPosAtTime(time) {
	        if (!this.lastPos)
	            return this.currPos;
	        let completion = Util$1.clamp((time - this.lastPosTime) / (this.currPosTime - this.lastPosTime), 0, 1);
	        return this.lastPos.clone().lerp(this.currPos, completion);
	    }
	    setPos(pos, time) {
	        this.lastPos = this.currPos;
	        this.lastPosTime = this.currPosTime;
	        this.currPos = pos.clone();
	        this.currPosTime = time;
	        this.vel = this.currPos.clone().sub(this.lastPos).multiplyScalar(1000 / (this.currPosTime - this.lastPosTime));
	        this.velComputed = true;
	    }
	    static cloneOptions(options) {
	        let clone = Util$1.jsonClone(options);
	        clone.ambientVelocity = new Vector3$1(options.ambientVelocity.x, options.ambientVelocity.y, options.ambientVelocity.z);
	        clone.spawnOffset = options.spawnOffset;
	        return clone;
	    }
	}
	class Particle {
	    constructor(options, manager, spawnTime, pos, vel) {
	        this.o = options;
	        this.manager = manager;
	        this.spawnTime = spawnTime;
	        this.pos = pos;
	        this.vel = vel;
	        this.lifetime = this.o.lifetime + this.o.lifetimeVariance * (Math.random() * 2 - 1);
	        this.initialSpin = Util$1.lerp(this.o.spinRandomMin, this.o.spinRandomMax, Math.random());
	    }
	    /** Writes this particle's starting state into vertex buffers so that it can be simulated on the GPU. */
	    applyToGroup(group, index) {
	        let data = [
	            this.spawnTime,
	            this.lifetime,
	            this.pos.x, this.pos.y, this.pos.z,
	            this.vel.x, this.vel.y, this.vel.z,
	            Util$1.degToRad(this.initialSpin)
	        ];
	        // Update the data about the particle for each of the vertices. Yeah, it's a bit redundant, but name a better way. Data texture, you say? 😂
	        let buf = group.vertexBuffer;
	        buf.set(data, 4 * index * buf.stride + 0 * buf.stride);
	        buf.set(data, 4 * index * buf.stride + 1 * buf.stride);
	        buf.set(data, 4 * index * buf.stride + 2 * buf.stride);
	        buf.set(data, 4 * index * buf.stride + 3 * buf.stride);
	    }
	    isAlive(time) {
	        let elapsed = time - this.spawnTime;
	        let completion = Util$1.clamp(elapsed / this.lifetime, 0, 1);
	        return completion < 1;
	    }
	}
	const particleNodeEmittersEmitterOptions = {
	    MarbleTrailEmitter: {
	        ejectionPeriod: 5,
	        ambientVelocity: new Vector3$1(0, 0, 0),
	        ejectionVelocity: 0,
	        velocityVariance: 0.25,
	        emitterLifetime: 10000,
	        inheritedVelFactor: 0,
	        particleOptions: {
	            texture: 'particles/smoke.png',
	            blending: BlendingType.Normal,
	            spinSpeed: 0,
	            spinRandomMin: 0,
	            spinRandomMax: 0,
	            lifetime: 100,
	            lifetimeVariance: 10,
	            dragCoefficient: 0,
	            acceleration: 0,
	            colors: [{ r: 1, g: 1, b: 0, a: 0 }, { r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 1, b: 1, a: 0 }],
	            sizes: [0.4, 0.4, 0.4],
	            times: [0, 0.15, 1]
	        }
	    },
	    LandMineEmitter: {
	        ejectionPeriod: 10,
	        ambientVelocity: new Vector3$1(0, 0, 0),
	        ejectionVelocity: 0.5,
	        velocityVariance: 0.25,
	        emitterLifetime: Infinity,
	        inheritedVelFactor: 0.2,
	        particleOptions: {
	            texture: 'particles/smoke.png',
	            blending: BlendingType.Additive,
	            spinSpeed: 40,
	            spinRandomMin: -90,
	            spinRandomMax: 90,
	            lifetime: 1000,
	            lifetimeVariance: 150,
	            dragCoefficient: 0.8,
	            acceleration: 0,
	            colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.56, g: 0.36, b: 0.26, a: 0 }],
	            sizes: [0.5, 1],
	            times: [0, 1]
	        }
	    }
	};

	/** Stores a cube texture. */
	class CubeTexture$1 {
	    constructor(renderer, arg2) {
	        this.id = Util$1.uuid();
	        /** For efficiency purposes, not all faces of the texture are rendered to in one step. Therefore, we need to keep track of where we left off. */
	        this.nextFaceToRender = 0;
	        this.renderer = renderer;
	        let { gl } = renderer;
	        let texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
	        if (Array.isArray(arg2)) {
	            let images = arg2;
	            if (images.some(x => !x.complete))
	                throw new Error("Can only pass loaded images into CubeTexture.");
	            this.size = images[0].naturalWidth; // Assume square images
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[0]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[1]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[2]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[3]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[4]);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[5]);
	            gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	        }
	        else {
	            let size = arg2;
	            this.size = size;
	            let data = new Uint8Array(size * size * 4); // Passing the (albeit empty) data suppresses an annoying warning on Firefox
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
	            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        }
	        // Make sure to set min/mag filters, otherwise nothing will render
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	        this.glTexture = texture;
	    }
	    /** Creates a framebuffer that will be used to render a scene to this cube texture. */
	    createFramebuffer() {
	        let { gl } = this.renderer;
	        let framebuffer = gl.createFramebuffer();
	        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
	        let depthBuffer = gl.createRenderbuffer();
	        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
	        // Make a depth buffer and the same size as the target texture
	        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.size, this.size);
	        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
	        this.framebuffer = framebuffer;
	        this.depthBuffer = depthBuffer;
	    }
	    /**
	     * Renders a given scene to the cube texture. Depending on the budget, this might not render to all six faces.
	     * @param budget Defines the maximum amount of time in milliseconds this method should run. Can be used to set an upper bound on render time, since rendering a scene six times _can_ get expensive.
	     */
	    render(scene, cubeCamera, budget = Infinity) {
	        let { gl } = this.renderer;
	        if (!this.framebuffer)
	            this.createFramebuffer(); // We're here for the first time, so go and create a framebuffer first
	        let start = performance.now();
	        let renderedFaces = 0;
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
	        for (let i = 0; i < 6; i++) {
	            // Figure out what face we need to render next based on where we left off
	            let index = (this.nextFaceToRender + i) % 6;
	            // Update the camera's position
	            let camera = cubeCamera.cameras[index];
	            camera.position.copy(cubeCamera.position);
	            camera.updateMatrixWorld();
	            // Bind the correct side of the cube texture to the framebuffer as a texture target
	            let target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + index;
	            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, this.glTexture, 0);
	            // Render the scene
	            this.renderer.render(scene, camera, { framebuffer: this.framebuffer, width: this.size, height: this.size, colorTexture: this.glTexture });
	            renderedFaces++;
	            let time = performance.now();
	            let elapsed = time - start;
	            let elapsedPerFace = elapsed / renderedFaces;
	            if (elapsedPerFace * (renderedFaces + 1) >= budget)
	                break; // We predict that the next loop iteration would exceed the budget, so break
	        }
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.glTexture);
	        gl.generateMipmap(gl.TEXTURE_CUBE_MAP); // Make sure to generate mips
	        this.nextFaceToRender += renderedFaces;
	        this.nextFaceToRender %= 6;
	    }
	    dispose() {
	        let { gl } = this.renderer;
	        gl.deleteTexture(this.glTexture);
	        gl.deleteFramebuffer(this.framebuffer);
	        gl.deleteRenderbuffer(this.depthBuffer);
	    }
	}
	//# sourceMappingURL=cube_texture.js.map

	let m1$1 = new Matrix4();
	class Camera {
	    constructor() {
	        this.position = new Vector3$1();
	        this.orientation = new Quaternion$1();
	        this.up = new Vector3$1(0, 0, 1);
	        this.matrixWorld = new Matrix4();
	        this.matrixWorldInverse = new Matrix4();
	        this.projectionMatrix = new Matrix4();
	        this.projectionMatrixInverse = new Matrix4();
	    }
	    updateMatrixWorld() {
	        this.matrixWorld.compose(this.position, this.orientation, new Vector3$1().setScalar(1));
	        this.matrixWorldInverse.copy(this.matrixWorld).invert();
	    }
	    lookAt(target) {
	        m1$1.lookAt(this.position, target, this.up);
	        this.orientation.setFromRotationMatrix(m1$1);
	    }
	}
	class PerspectiveCamera$1 extends Camera {
	    constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
	        super();
	        this.fov = fov;
	        this.zoom = 1;
	        this.near = near;
	        this.far = far;
	        this.aspect = aspect;
	        this.updateProjectionMatrix();
	    }
	    updateProjectionMatrix() {
	        const near = this.near;
	        let top = (near * Math.tan(Util$1.degToRad(0.5 * this.fov))) / this.zoom;
	        let height = 2 * top;
	        let width = this.aspect * height;
	        let left = -0.5 * width;
	        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
	        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	    }
	}
	class OrthographicCamera$1 extends Camera {
	    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
	        super();
	        this.zoom = 1;
	        this.left = left;
	        this.right = right;
	        this.top = top;
	        this.bottom = bottom;
	        this.near = near;
	        this.far = far;
	        this.updateProjectionMatrix();
	    }
	    updateProjectionMatrix() {
	        const dx = (this.right - this.left) / (2 * this.zoom);
	        const dy = (this.top - this.bottom) / (2 * this.zoom);
	        const cx = (this.right + this.left) / 2;
	        const cy = (this.top + this.bottom) / 2;
	        let left = cx - dx;
	        let right = cx + dx;
	        let top = cy + dy;
	        let bottom = cy - dy;
	        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
	        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	    }
	}
	//# sourceMappingURL=camera.js.map

	/** Cube cameras can be used to render to cube textures. */
	class CubeCamera {
	    constructor(near, far) {
	        this.cameras = [];
	        this.position = new Vector3$1();
	        const fov = 90, aspect = 1;
	        // Create all 6 cameras, each capturing exactly 1/6th of the cube (taken from three.js)
	        const cameraPX = new PerspectiveCamera$1(fov, aspect, near, far);
	        cameraPX.up.set(0, -1, 0);
	        cameraPX.lookAt(new Vector3$1(1, 0, 0));
	        this.cameras.push(cameraPX);
	        const cameraNX = new PerspectiveCamera$1(fov, aspect, near, far);
	        cameraNX.up.set(0, -1, 0);
	        cameraNX.lookAt(new Vector3$1(-1, 0, 0));
	        this.cameras.push(cameraNX);
	        const cameraPY = new PerspectiveCamera$1(fov, aspect, near, far);
	        cameraPY.up.set(0, 0, 1);
	        cameraPY.lookAt(new Vector3$1(0, 1, 0));
	        this.cameras.push(cameraPY);
	        const cameraNY = new PerspectiveCamera$1(fov, aspect, near, far);
	        cameraNY.up.set(0, 0, -1);
	        cameraNY.lookAt(new Vector3$1(0, -1, 0));
	        this.cameras.push(cameraNY);
	        const cameraPZ = new PerspectiveCamera$1(fov, aspect, near, far);
	        cameraPZ.up.set(0, -1, 0);
	        cameraPZ.lookAt(new Vector3$1(0, 0, 1));
	        this.cameras.push(cameraPZ);
	        const cameraNZ = new PerspectiveCamera$1(fov, aspect, near, far);
	        cameraNZ.up.set(0, -1, 0);
	        cameraNZ.lookAt(new Vector3$1(0, 0, -1));
	        this.cameras.push(cameraNZ);
	    }
	}
	//# sourceMappingURL=cube_camera.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	const _matrix = new Matrix4();
	const _quaternion$1 = new Quaternion$1();
	/**
	A class representing Euler Angles using intrinsic Tait-Bryan angles.

	Euler angles describe a rotational transformation by rotating an object on its various axes in specified amounts per axis, and a specified axis order.
	 */
	class Euler$1 {
	    constructor(x = 0, y = 0, z = 0, order = Euler$1.defaultOrder) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.order = order;
	    }
	    /** Sets the angles of this euler transform and optionally the `order`. */
	    set(x, y, z, order = this.order) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.order = order;
	        return this;
	    }
	    /** Returns a new Euler with the same parameters as this one. */
	    clone() {
	        return new Euler$1(this.x, this.y, this.z, this.order);
	    }
	    /** Copies value of `euler` to this euler. */
	    copy(euler) {
	        this.x = euler.x;
	        this.y = euler.y;
	        this.z = euler.z;
	        this.order = euler.order;
	        return this;
	    }
	    /** Sets the angles of this euler transform from a pure rotation matrix based on the orientation specified by `order`. */
	    setFromRotationMatrix(m, order = this.order) {
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        const te = m.elements;
	        const m11 = te[0], m12 = te[4], m13 = te[8];
	        const m21 = te[1], m22 = te[5], m23 = te[9];
	        const m31 = te[2], m32 = te[6], m33 = te[10];
	        switch (order) {
	            case "XYZ":
	                this.y = Math.asin(Util$1.clamp(m13, -1, 1));
	                if (Math.abs(m13) < 0.9999999) {
	                    this.x = Math.atan2(-m23, m33);
	                    this.z = Math.atan2(-m12, m11);
	                }
	                else {
	                    this.x = Math.atan2(m32, m22);
	                    this.z = 0;
	                }
	                break;
	            case "YXZ":
	                this.x = Math.asin(-Util$1.clamp(m23, -1, 1));
	                if (Math.abs(m23) < 0.9999999) {
	                    this.y = Math.atan2(m13, m33);
	                    this.z = Math.atan2(m21, m22);
	                }
	                else {
	                    this.y = Math.atan2(-m31, m11);
	                    this.z = 0;
	                }
	                break;
	            case "ZXY":
	                this.x = Math.asin(Util$1.clamp(m32, -1, 1));
	                if (Math.abs(m32) < 0.9999999) {
	                    this.y = Math.atan2(-m31, m33);
	                    this.z = Math.atan2(-m12, m22);
	                }
	                else {
	                    this.y = 0;
	                    this.z = Math.atan2(m21, m11);
	                }
	                break;
	            case "ZYX":
	                this.y = Math.asin(-Util$1.clamp(m31, -1, 1));
	                if (Math.abs(m31) < 0.9999999) {
	                    this.x = Math.atan2(m32, m33);
	                    this.z = Math.atan2(m21, m11);
	                }
	                else {
	                    this.x = 0;
	                    this.z = Math.atan2(-m12, m22);
	                }
	                break;
	            case "YZX":
	                this.z = Math.asin(Util$1.clamp(m21, -1, 1));
	                if (Math.abs(m21) < 0.9999999) {
	                    this.x = Math.atan2(-m23, m22);
	                    this.y = Math.atan2(-m31, m11);
	                }
	                else {
	                    this.x = 0;
	                    this.y = Math.atan2(m13, m33);
	                }
	                break;
	            case "XZY":
	                this.z = Math.asin(-Util$1.clamp(m12, -1, 1));
	                if (Math.abs(m12) < 0.9999999) {
	                    this.x = Math.atan2(m32, m22);
	                    this.y = Math.atan2(m13, m11);
	                }
	                else {
	                    this.x = Math.atan2(-m23, m33);
	                    this.y = 0;
	                }
	                break;
	            default:
	                console.warn("Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
	        }
	        this.order = order;
	        return this;
	    }
	    /** Sets the angles of this euler transform from a normalized quaternion based on the orientation specified by `order`. */
	    setFromQuaternion(q, order) {
	        _matrix.makeRotationFromQuaternion(q);
	        return this.setFromRotationMatrix(_matrix, order);
	    }
	    /** Set the x, y and z, and optionally update the `order`. */
	    setFromVector3(v, order = this.order) {
	        return this.set(v.x, v.y, v.z, order);
	    }
	    /** Resets the euler angle with a new order by creating a quaternion from this euler angle and then setting this euler angle with the quaternion and the new order. WARNING: this discards revolution information. */
	    reorder(newOrder) {
	        // WARNING: this discards revolution information -bhouston
	        _quaternion$1.setFromEuler(this);
	        return this.setFromQuaternion(_quaternion$1, newOrder);
	    }
	    /** Checks for strict equality of this euler and `euler`. */
	    equals(euler) {
	        return euler.x === this.x && euler.y === this.y && euler.z === this.z && euler.order === this.order;
	    }
	    /** Assigns this euler's x angle to array[0]. Assigns this euler's y angle to array[1]. Assigns this euler's z angle to array[2]. Optionally assigns this euler's order to array[3]. */
	    fromArray(array) {
	        this.x = array[0];
	        this.y = array[1];
	        this.z = array[2];
	        if (array[3] !== undefined)
	            this.order = array[3];
	        return this;
	    }
	    /** Returns an array of the form [x, y, z, order]. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.order;
	        return array;
	    }
	    /** Returns the Euler's x, y and z properties as a Vector3. */
	    toVector3(optionalResult) {
	        if (optionalResult) {
	            return optionalResult.set(this.x, this.y, this.z);
	        }
	        else {
	            return new Vector3$1(this.x, this.y, this.z);
	        }
	    }
	}
	Euler$1.defaultOrder = "XYZ";
	Euler$1.rotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
	//# sourceMappingURL=euler.js.map

	// Adapted from https://github.com/mrdoob/three.js/tree/dev/src/math
	/** Class representing a 4D vector. */
	class Vector4 {
	    constructor(x = 0, y = 0, z = 0, w = 1) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    get width() {
	        return this.z;
	    }
	    set width(value) {
	        this.z = value;
	    }
	    get height() {
	        return this.w;
	    }
	    set height(value) {
	        this.w = value;
	    }
	    /** Sets the x, y, z and w components of this vector. */
	    set(x, y, z, w) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	        return this;
	    }
	    /** Sets the x, y, z and w values of this vector both equal to scalar. */
	    setScalar(scalar) {
	        this.x = scalar;
	        this.y = scalar;
	        this.z = scalar;
	        this.w = scalar;
	        return this;
	    }
	    /** Replaces this vector's x value with x. */
	    setX(x) {
	        this.x = x;
	        return this;
	    }
	    /** Replaces this vector's y value with y. */
	    setY(y) {
	        this.y = y;
	        return this;
	    }
	    /** Replaces this vector's z value with z. */
	    setZ(z) {
	        this.z = z;
	        return this;
	    }
	    /** Replaces this vector's w value with w. */
	    setW(w) {
	        this.w = w;
	        return this;
	    }
	    /** If index equals 0 set x to value. If index equals 1 set y to value. If index equals 2 set z to value. If index equals 3 set w to value. */
	    setComponent(index, value) {
	        switch (index) {
	            case 0:
	                this.x = value;
	                break;
	            case 1:
	                this.y = value;
	                break;
	            case 2:
	                this.z = value;
	                break;
	            case 3:
	                this.w = value;
	                break;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	        return this;
	    }
	    /** If index equals 0 returns the x value. If index equals 1 returns the y value. If index equals 2 returns the z value. If index equals 3 returns the w value. */
	    getComponent(index) {
	        switch (index) {
	            case 0:
	                return this.x;
	            case 1:
	                return this.y;
	            case 2:
	                return this.z;
	            case 3:
	                return this.w;
	            default:
	                throw new Error("index is out of range: " + index);
	        }
	    }
	    /** Returns a new Vector4 with the same x, y, z and w values as this one. */
	    clone() {
	        return new Vector4(this.x, this.y, this.z, this.w);
	    }
	    /** Copies the values of the passed Vector4's x, y, z and w properties to this Vector4. */
	    copy(v) {
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        this.w = v.w !== undefined ? v.w : 1;
	        return this;
	    }
	    /** Adds v to this vector. */
	    add(v) {
	        this.x += v.x;
	        this.y += v.y;
	        this.z += v.z;
	        this.w += v.w;
	        return this;
	    }
	    /** Adds the scalar value s to this vector's x, y, z and w values. */
	    addScalar(s) {
	        this.x += s;
	        this.y += s;
	        this.z += s;
	        this.w += s;
	        return this;
	    }
	    /** Sets this vector to a + b. */
	    addVectors(a, b) {
	        this.x = a.x + b.x;
	        this.y = a.y + b.y;
	        this.z = a.z + b.z;
	        this.w = a.w + b.w;
	        return this;
	    }
	    /** Adds the multiple of v and s to this vector. */
	    addScaledVector(v, s) {
	        this.x += v.x * s;
	        this.y += v.y * s;
	        this.z += v.z * s;
	        this.w += v.w * s;
	        return this;
	    }
	    /** Subtracts v from this vector. */
	    sub(v) {
	        this.x -= v.x;
	        this.y -= v.y;
	        this.z -= v.z;
	        this.w -= v.w;
	        return this;
	    }
	    /** Subtracts s from this vector's x, y, z and w compnents. */
	    subScalar(s) {
	        this.x -= s;
	        this.y -= s;
	        this.z -= s;
	        this.w -= s;
	        return this;
	    }
	    /** Sets this vector to a - b. */
	    subVectors(a, b) {
	        this.x = a.x - b.x;
	        this.y = a.y - b.y;
	        this.z = a.z - b.z;
	        this.w = a.w - b.w;
	        return this;
	    }
	    /** Multiplies this vector by v. */
	    multiply(v) {
	        this.x *= v.x;
	        this.y *= v.y;
	        this.z *= v.z;
	        this.w *= v.w;
	        return this;
	    }
	    /** Multiplies this vector by scalar s. */
	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        this.z *= scalar;
	        this.w *= scalar;
	        return this;
	    }
	    /** Multiplies this vector by 4 x 4 m. */
	    applyMatrix4(m) {
	        const x = this.x, y = this.y, z = this.z, w = this.w;
	        const e = m.elements;
	        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
	        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
	        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
	        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
	        return this;
	    }
	    /** Divides this vector by scalar s. */
	    divideScalar(scalar) {
	        return this.multiplyScalar(1 / scalar);
	    }
	    /** Sets the x, y and z components of this vector to the quaternion's axis and w to the angle. */
	    setAxisAngleFromQuaternion(q) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	        // q is assumed to be normalized
	        this.w = 2 * Math.acos(q.w);
	        const s = Math.sqrt(1 - q.w * q.w);
	        if (s < 0.0001) {
	            this.x = 1;
	            this.y = 0;
	            this.z = 0;
	        }
	        else {
	            this.x = q.x / s;
	            this.y = q.y / s;
	            this.z = q.z / s;
	        }
	        return this;
	    }
	    /** Sets the x, y and z to the axis of rotation and w to the angle. */
	    setAxisAngleFromRotationMatrix(m) {
	        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	        let angle, x, y, z; // variables for result
	        const epsilon = 0.01, // margin to allow for rounding errors
	        epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
	        te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
	        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
	            // singularity found
	            // first check for identity matrix which must have +1 for all terms
	            // in leading diagonal and zero in other terms
	            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
	                // this singularity is identity matrix so angle = 0
	                this.set(1, 0, 0, 0);
	                return this; // zero angle, arbitrary axis
	            }
	            // otherwise this singularity is angle = 180
	            angle = Math.PI;
	            const xx = (m11 + 1) / 2;
	            const yy = (m22 + 1) / 2;
	            const zz = (m33 + 1) / 2;
	            const xy = (m12 + m21) / 4;
	            const xz = (m13 + m31) / 4;
	            const yz = (m23 + m32) / 4;
	            if (xx > yy && xx > zz) {
	                // m11 is the largest diagonal term
	                if (xx < epsilon) {
	                    x = 0;
	                    y = 0.707106781;
	                    z = 0.707106781;
	                }
	                else {
	                    x = Math.sqrt(xx);
	                    y = xy / x;
	                    z = xz / x;
	                }
	            }
	            else if (yy > zz) {
	                // m22 is the largest diagonal term
	                if (yy < epsilon) {
	                    x = 0.707106781;
	                    y = 0;
	                    z = 0.707106781;
	                }
	                else {
	                    y = Math.sqrt(yy);
	                    x = xy / y;
	                    z = yz / y;
	                }
	            }
	            else {
	                // m33 is the largest diagonal term so base result on this
	                if (zz < epsilon) {
	                    x = 0.707106781;
	                    y = 0.707106781;
	                    z = 0;
	                }
	                else {
	                    z = Math.sqrt(zz);
	                    x = xz / z;
	                    y = yz / z;
	                }
	            }
	            this.set(x, y, z, angle);
	            return this; // return 180 deg rotation
	        }
	        // as we have reached here there are no singularities so we can handle normally
	        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
	        if (Math.abs(s) < 0.001)
	            s = 1;
	        // prevent divide by zero, should not happen if matrix is orthogonal and should be
	        // caught by singularity test above, but I've left it in just in case
	        this.x = (m32 - m23) / s;
	        this.y = (m13 - m31) / s;
	        this.z = (m21 - m12) / s;
	        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
	        return this;
	    }
	    /** If this vector's x, y, z or w value is greater than v's x, y, z or w value, replace that value with the corresponding min value. */
	    min(v) {
	        this.x = Math.min(this.x, v.x);
	        this.y = Math.min(this.y, v.y);
	        this.z = Math.min(this.z, v.z);
	        this.w = Math.min(this.w, v.w);
	        return this;
	    }
	    /** If this vector's x, y, z or w value is less than v's x, y, z or w value, replace that value with the corresponding max value. */
	    max(v) {
	        this.x = Math.max(this.x, v.x);
	        this.y = Math.max(this.y, v.y);
	        this.z = Math.max(this.z, v.z);
	        this.w = Math.max(this.w, v.w);
	        return this;
	    }
	    /** If this vector's x, y, z or w value is greater than the max vector's x, y, z or w value, it is replaced by the corresponding value. If this vector's x, y, z or w value is less than the min vector's x, y, z or w value, it is replaced by the corresponding value. */
	    clamp(min, max) {
	        // assumes min < max, componentwise
	        this.x = Math.max(min.x, Math.min(max.x, this.x));
	        this.y = Math.max(min.y, Math.min(max.y, this.y));
	        this.z = Math.max(min.z, Math.min(max.z, this.z));
	        this.w = Math.max(min.w, Math.min(max.w, this.w));
	        return this;
	    }
	    /** If this vector's x, y, z or w values are greater than the max value, they are replaced by the max value. If this vector's x, y, z or w values are less than the min value, they are replaced by the min value. */
	    clampScalar(minVal, maxVal) {
	        this.x = Math.max(minVal, Math.min(maxVal, this.x));
	        this.y = Math.max(minVal, Math.min(maxVal, this.y));
	        this.z = Math.max(minVal, Math.min(maxVal, this.z));
	        this.w = Math.max(minVal, Math.min(maxVal, this.w));
	        return this;
	    }
	    /** If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value. */
	    clampLength(min, max) {
	        const length = this.length();
	        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	    }
	    /** The components of this vector are rounded down to the nearest integer value. */
	    floor() {
	        this.x = Math.floor(this.x);
	        this.y = Math.floor(this.y);
	        this.z = Math.floor(this.z);
	        this.w = Math.floor(this.w);
	        return this;
	    }
	    /** The components of this vector are rounded up to the nearest integer value. */
	    ceil() {
	        this.x = Math.ceil(this.x);
	        this.y = Math.ceil(this.y);
	        this.z = Math.ceil(this.z);
	        this.w = Math.ceil(this.w);
	        return this;
	    }
	    /** The components of this vector are rounded to the nearest integer value. */
	    round() {
	        this.x = Math.round(this.x);
	        this.y = Math.round(this.y);
	        this.z = Math.round(this.z);
	        this.w = Math.round(this.w);
	        return this;
	    }
	    /** The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value. */
	    roundToZero() {
	        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
	        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
	        return this;
	    }
	    /** Inverts this vector - i.e. sets x = -x, y = -y, z = -z and w = -w. */
	    negate() {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	        this.w = -this.w;
	        return this;
	    }
	    /** Calculates the dot product of this vector and v. */
	    dot(v) {
	        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	    }
	    /** Computes the square of the Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w). */
	    lengthSq() {
	        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	    }
	    /** Computes the Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w). */
	    length() {
	        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    }
	    /** Computes the Manhattan length of this vector. */
	    manhattanLength() {
	        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	    }
	    /** Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but length 1. */
	    normalize() {
	        return this.divideScalar(this.length() || 1);
	    }
	    /** Sets this vector to a vector with the same direction as this one, but length l. */
	    setLength(length) {
	        return this.normalize().multiplyScalar(length);
	    }
	    /** Linearly interpolates between this vector and v, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v. */
	    lerp(v, alpha) {
	        this.x += (v.x - this.x) * alpha;
	        this.y += (v.y - this.y) * alpha;
	        this.z += (v.z - this.z) * alpha;
	        this.w += (v.w - this.w) * alpha;
	        return this;
	    }
	    /** Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the percent distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2. */
	    lerpVectors(v1, v2, alpha) {
	        this.x = v1.x + (v2.x - v1.x) * alpha;
	        this.y = v1.y + (v2.y - v1.y) * alpha;
	        this.z = v1.z + (v2.z - v1.z) * alpha;
	        this.w = v1.w + (v2.w - v1.w) * alpha;
	        return this;
	    }
	    /** Returns true if the components of this vector and v are strictly equal; false otherwise. */
	    equals(v) {
	        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
	    }
	    /** Sets this vector's x value to be array[offset + 0], y value to be array[offset + 1] z value to be array[offset + 2] and w value to be array[offset + 3]. */
	    fromArray(array, offset = 0) {
	        this.x = array[offset];
	        this.y = array[offset + 1];
	        this.z = array[offset + 2];
	        this.w = array[offset + 3];
	        return this;
	    }
	    /** Returns an array [x, y, z, w], or copies x, y, z and w into the provided array. */
	    toArray(array = [], offset = 0) {
	        array[offset] = this.x;
	        array[offset + 1] = this.y;
	        array[offset + 2] = this.z;
	        array[offset + 3] = this.w;
	        return array;
	    }
	    /** Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1. */
	    random() {
	        this.x = Math.random();
	        this.y = Math.random();
	        this.z = Math.random();
	        this.w = Math.random();
	        return this;
	    }
	    *[Symbol.iterator]() {
	        yield this.x;
	        yield this.y;
	        yield this.z;
	        yield this.w;
	    }
	}
	//# sourceMappingURL=vector4.js.map

	/** Compiles additional utilities for reading out values from .mis files. */
	class MisUtils {
	    /** Parses a 3-component vector from a string of three numbers. */
	    static parseVector3(string) {
	        if (!string)
	            return new Vector3$1();
	        let parts = string.split(' ').map((part) => Number(part));
	        if (parts.length < 3)
	            return new Vector3$1();
	        if (parts.find(x => !isFinite(x)) !== undefined)
	            return new Vector3$1();
	        return new Vector3$1(parts[0], parts[1], parts[2]);
	    }
	    /** Parses a 4-component vector from a string of four numbers. */
	    static parseVector4(string) {
	        if (!string)
	            return new Vector4();
	        let parts = string.split(' ').map((part) => Number(part));
	        if (parts.length < 4)
	            return new Vector4();
	        if (parts.find(x => !isFinite(x)) !== undefined)
	            return new Vector4();
	        return new Vector4(parts[0], parts[1], parts[2], parts[3]);
	    }
	    /** Returns a quaternion based on a rotation specified from 4 numbers. */
	    static parseRotation(string) {
	        if (!string)
	            return new Quaternion$1();
	        let parts = string.split(' ').map((part) => Number(part));
	        if (parts.length < 4)
	            return new Quaternion$1();
	        if (parts.find(x => !isFinite(x)) !== undefined)
	            return new Quaternion$1();
	        let quaternion = new Quaternion$1();
	        // The first 3 values represent the axis to rotate on, the last represents the negative angle in degrees.
	        quaternion.setFromAxisAngle(new Vector3$1(parts[0], parts[1], parts[2]), -Util$1.degToRad(parts[3]));
	        return quaternion;
	    }
	    /** Parses a list of space-separated numbers. */
	    static parseNumberList(string) {
	        let parts = string.split(' ');
	        let result = [];
	        for (let part of parts) {
	            let number = Number(part);
	            if (!isNaN(number)) {
	                // The number parsed without issues; simply add it to the array.
	                result.push(number);
	            }
	            else {
	                // Since we got NaN, we assume the number did not parse correctly and we have a case where the space between multiple numbers are missing. So "0.0000000 1.0000000" turning into "0.00000001.0000000".
	                const assumedDecimalPlaces = 7; // Reasonable assumption
	                // Scan the part to try to find all numbers contained in it
	                while (part.length > 0) {
	                    let dotIndex = part.indexOf('.');
	                    if (dotIndex === -1)
	                        break;
	                    let section = part.slice(0, Math.min(dotIndex + assumedDecimalPlaces + 1, part.length));
	                    result.push(Number(section));
	                    part = part.slice(dotIndex + assumedDecimalPlaces + 1);
	                }
	            }
	        }
	        return result;
	    }
	}
	//# sourceMappingURL=mis_utils.js.map

	// List all of gem colors for randomly choosing one
	const GEM_COLORS = ["blue", "red", "yellow", "purple", "green", "turquoise", "orange", "black"]; // "Platinum" is also a color, but it can't appear by chance
	/** Gems need to be collected before being able to finish. */
	class Gem$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.restartable = true;
	        this.dtsPath = "shapes/items/gem.dts";
	        this.ambientRotate = true;
	        this.collideable = false;
	        this.shareMaterials = false;
	        this.showSequences = false; // Gems actually have an animation for the little shiny thing, but the actual game ignores that. I get it, it was annoying as hell.
	        this.sounds = ['gotgem.wav', 'gotallgems.wav', 'missinggems.wav'];
	        this.pickedUpBy = null;
	        this.pickUpFrame = -Infinity;
	    }
	    init(game, srcElement) {
	        // Determine the color of the gem:
	        let color = srcElement.datablock.slice("GemItem".length);
	        if (color.length === 0)
	            color = Gem$1.pickRandomColor(game.seed + srcElement._id); // Random if no color specified
	        this.matNamesOverride["base.gem"] = color.toLowerCase() + ".gem";
	        if (game instanceof MultiplayerGame)
	            this.sounds.push('opponentdiamond.wav');
	        return super.init(game, srcElement);
	    }
	    onMarbleInside(t, marble) {
	        marble.affect(this);
	        if (this.pickedUpBy)
	            return;
	        this.pickedUpBy = marble;
	        this.pickUpFrame = this.game.state.frame;
	        G$1.menu.hud.displayAlert(this.getAlertMessage.bind(this), this.game.state.frame);
	        this.playSound();
	        this.stateNeedsStore = true;
	    }
	    /** lmao name */
	    pickDown() {
	        this.pickedUpBy = null;
	        this.stateNeedsStore = true;
	    }
	    update(onlyVisual) {
	        if (onlyVisual)
	            return;
	        this.setCollisionEnabled(!this.pickedUpBy);
	    }
	    render() {
	        super.render();
	        this.setOpacity(Number(!this.pickedUpBy));
	    }
	    getState() {
	        var _a, _b;
	        return {
	            entityType: 'gem',
	            pickedUpBy: (_b = (_a = this.pickedUpBy) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,
	            pickUpFrame: isFinite(this.pickUpFrame) ? this.pickUpFrame : null
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'gem',
	            pickedUpBy: null,
	            pickUpFrame: null
	        };
	    }
	    loadState(state, { frame }) {
	        var _a;
	        let prevPickUpFrame = this.pickUpFrame;
	        this.pickedUpBy = this.game.getEntityById(state.pickedUpBy);
	        this.pickUpFrame = (_a = state.pickUpFrame) !== null && _a !== void 0 ? _a : -Infinity;
	        this.setOpacity(Number(this.pickedUpBy === null));
	        this.setCollisionEnabled(this.pickedUpBy === null);
	        if (this.pickUpFrame > prevPickUpFrame) {
	            G$1.menu.hud.displayAlert(this.getAlertMessage.bind(this), frame);
	            this.playSound();
	        }
	    }
	    getAlertMessage() {
	        let string;
	        let gemWord = (G$1.modification === 'gold') ? 'gem' : 'diamond';
	        let gemCount = this.game.entities.filter(x => x instanceof Gem$1 && x.pickedUpBy !== null).length;
	        // Show a notification (and play a sound) based on the gems remaining
	        if (gemCount === this.game.totalGems) {
	            string = `You have all the ${gemWord}s, head for the finish!`;
	            //AudioManager.play('gotallgems.wav');
	            // todo Some levels with this package end immediately upon collection of all gems
	            /*
	            if (this.mission.misFile.activatedPackages.includes('endWithTheGems')) {
	                this.touchFinish(t);
	            }*/
	        }
	        else {
	            let subject;
	            let marble = this.pickedUpBy;
	            if (!marble || !marble.controllingPlayer) {
	                subject = 'A marble';
	            }
	            else {
	                if (marble.controllingPlayer === this.game.localPlayer)
	                    subject = 'You';
	                else {
	                    let session = G$1.lobby.sockets.find(x => { var _a; return x.id === ((_a = marble.controllingPlayer) === null || _a === void 0 ? void 0 : _a.sessionId); });
	                    subject = session ? session.name : 'A marble';
	                }
	            }
	            string = `${subject} picked up a ${gemWord}${G$1.modification === 'gold' ? '.' : '!'}  `;
	            let remaining = this.game.totalGems - gemCount;
	            if (remaining === 1) {
	                string += `Only one ${gemWord} to go!`;
	            }
	            else {
	                string += `${remaining} ${gemWord}s to go!`;
	            }
	        }
	        return string;
	    }
	    playSound() {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            let gemCount = this.game.entities.filter(x => x instanceof Gem$1 && x.pickedUpBy !== null).length;
	            let sound = gemCount === this.game.totalGems ? this.sounds[1] : this.pickedUpBy === this.game.localPlayer.controlledMarble ? this.sounds[0] : this.sounds[3];
	            AudioManager$1.play(sound);
	        }, `${this.id}sound`, true);
	    }
	    static pickRandomColor(seed) {
	        if (seed !== undefined)
	            return GEM_COLORS[Math.floor(Util$1.seededRandom(seed, 10) * GEM_COLORS.length)];
	        return Util$1.randomFromArray(GEM_COLORS);
	    }
	}
	//# sourceMappingURL=gem.js.map

	class CheckpointState extends Entity {
	    constructor(game, id, marble) {
	        super(game);
	        this.restartable = true;
	        /** Stores the shape that is the destination of the current checkpoint. */
	        this.currentCheckpoint = null;
	        /** If the checkpoint was triggered by a trigger, this field stores that trigger. */
	        this.currentCheckpointTrigger = null;
	        this.checkpointCollectedGems = new Set();
	        this.checkpointHeldPowerUp = null;
	        /** Up vector at the point of checkpointing */
	        this.checkpointUp = null;
	        this.checkpointBlast = null;
	        this.scheduledPickUpFrame = null;
	        this.id = id;
	        this.marble = marble;
	    }
	    /** Sets a new active checkpoint. */
	    save(shape, trigger) {
	        var _a, _b;
	        if (this.currentCheckpoint === shape)
	            return;
	        if ((_a = this.currentCheckpoint) === null || _a === void 0 ? void 0 : _a.worldPosition.equals(shape.worldPosition))
	            return; // Some levels have identical overlapping checkpoints, which can cause an infinite checkpointing loop.
	        let disableOob = ((_b = shape.srcElement) === null || _b === void 0 ? void 0 : _b.disableOob) || (trigger === null || trigger === void 0 ? void 0 : trigger.element.disableOob);
	        if (MisParser$1.parseBoolean(disableOob) && this.marble.outOfBoundsFrame !== null)
	            return; // The checkpoint is configured to not work when the player is already OOB
	        this.currentCheckpoint = shape;
	        this.currentCheckpointTrigger = trigger;
	        this.checkpointCollectedGems.clear();
	        this.checkpointUp = this.marble.currentUp.clone();
	        this.checkpointBlast = this.marble.blastAmount;
	        // Remember all gems that were collected up to this point
	        for (let shape of this.game.shapes) {
	            if (!(shape instanceof Gem$1))
	                continue;
	            if (shape.pickedUpBy === this.marble)
	                this.checkpointCollectedGems.add(shape);
	        }
	        this.checkpointHeldPowerUp = this.marble.heldPowerUp;
	        G$1.menu.hud.displayAlert(() => {
	            return this.marble === this.game.localPlayer.controlledMarble ? "Checkpoint reached!" : null;
	        }, this.game.state.frame);
	        if (this.marble === this.game.localPlayer.controlledMarble) {
	            this.game.simulator.executeNonDuplicatableEvent(() => {
	                AudioManager$1.play('checkpoint.wav');
	            }, `${this.id}sound`, true);
	        }
	        this.marble.affect(this);
	        this.stateNeedsStore = true;
	    }
	    /** Resets to the last stored checkpoint state. */
	    load() {
	        var _a, _b, _c, _d, _e, _f;
	        if (!this.currentCheckpoint)
	            return;
	        let marble = this.marble;
	        // Quite note: Checkpoints have slightly different behavior in Ultra, that's why there's some checks
	        let gravityField = ((_a = this.currentCheckpoint.srcElement) === null || _a === void 0 ? void 0 : _a.gravity) || ((_b = this.currentCheckpointTrigger) === null || _b === void 0 ? void 0 : _b.element.gravity);
	        if (MisParser$1.parseBoolean(gravityField) || this.game.mission.modification === 'ultra') {
	            // In this case, we set the gravity to the relative "up" vector of the checkpoint shape.
	            let up = new Vector3$1(0, 0, 1);
	            up.applyQuaternion(this.currentCheckpoint.worldOrientation);
	            marble.setUp(up, true);
	        }
	        else {
	            // Otherwise, we restore gravity to what was stored.
	            marble.setUp(this.checkpointUp, true);
	        }
	        // Determine where to spawn the marble
	        let offset = new Vector3$1();
	        let add = ((_c = this.currentCheckpoint.srcElement) === null || _c === void 0 ? void 0 : _c.add) || ((_d = this.currentCheckpointTrigger) === null || _d === void 0 ? void 0 : _d.element.add);
	        if (add)
	            offset.add(MisUtils.parseVector3(add));
	        let sub = ((_e = this.currentCheckpoint.srcElement) === null || _e === void 0 ? void 0 : _e.sub) || ((_f = this.currentCheckpointTrigger) === null || _f === void 0 ? void 0 : _f.element.sub);
	        if (sub)
	            offset.sub(MisUtils.parseVector3(sub));
	        if (!add && !sub) {
	            offset.z = 3; // Defaults to (0, 0, 3)
	            if (this.game.mission.modification === 'ultra')
	                offset.applyQuaternion(this.currentCheckpoint.worldOrientation); // weird <3
	        }
	        marble.body.position.copy(this.currentCheckpoint.worldPosition).add(offset);
	        marble.body.linearVelocity.setScalar(0);
	        marble.body.angularVelocity.setScalar(0);
	        marble.calculatePredictiveTransforms();
	        marble.group.position.copy(marble.body.position);
	        marble.group.recomputeTransform();
	        marble.cancelInterpolation();
	        if (marble.controllingPlayer) {
	            // Set camera orienation
	            let euler = new Euler$1();
	            euler.setFromQuaternion(this.currentCheckpoint.worldOrientation, "ZXY");
	            marble.controllingPlayer.yaw = DEFAULT_YAW + euler.z;
	            marble.controllingPlayer.pitch = DEFAULT_PITCH;
	        }
	        // Restore gem states
	        for (let shape of this.game.shapes) {
	            if (!(shape instanceof Gem$1))
	                continue;
	            if (shape.pickedUpBy === marble && !this.checkpointCollectedGems.has(shape)) {
	                shape.pickDown();
	                marble.affect(shape);
	            }
	        }
	        // Turn all of these off
	        marble.superBounceEnableFrame = -Infinity;
	        marble.shockAbsorberEnableFrame = -Infinity;
	        marble.helicopterEnableFrame = -Infinity;
	        marble.megaMarbleEnableFrame = -Infinity;
	        this.scheduledPickUpFrame = null;
	        marble.outOfBoundsFrame = null;
	        marble.blastAmount = this.checkpointBlast;
	        marble.inFinishState = false; // For those very, very rare cases where the player touched the finish while OOB, but not fast enough, so they get respawned at the checkpoint and we need to remove the "finish lock".
	        marble.unequipPowerUp(); // Always deselect first
	        // Wait a bit to select the powerup to prevent immediately using it incase the user skipped the OOB screen by clicking
	        if (this.checkpointHeldPowerUp) {
	            this.scheduledPickUpFrame = this.game.state.frame + GAME_UPDATE_RATE / 2;
	            this.internalStateNeedsStore = true;
	        }
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play('spawn.wav', undefined, undefined, marble.body.position);
	        }, `${this.id}spawn`);
	    }
	    update() {
	        if (this.scheduledPickUpFrame !== null && this.game.state.frame === this.scheduledPickUpFrame) {
	            this.marble.pickUpPowerUp(this.checkpointHeldPowerUp);
	            this.scheduledPickUpFrame = null;
	            this.internalStateNeedsStore = true;
	        }
	    }
	    render() { }
	    getState() {
	        var _a, _b, _c, _d, _e, _f;
	        return {
	            entityType: 'checkpointState',
	            currentCheckpoint: (_b = (_a = this.currentCheckpoint) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,
	            currentCheckpointTrigger: (_d = (_c = this.currentCheckpointTrigger) === null || _c === void 0 ? void 0 : _c.id) !== null && _d !== void 0 ? _d : null,
	            checkpointCollectedGems: [...this.checkpointCollectedGems].map(x => x.id),
	            checkpointHeldPowerUp: (_f = (_e = this.checkpointHeldPowerUp) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : null,
	            checkpointUp: this.checkpointUp,
	            checkpointBlast: this.checkpointBlast
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'checkpointState',
	            currentCheckpoint: null,
	            currentCheckpointTrigger: null,
	            checkpointCollectedGems: [],
	            checkpointHeldPowerUp: null,
	            checkpointUp: null,
	            checkpointBlast: null
	        };
	    }
	    loadState(state) {
	        this.currentCheckpoint = this.game.getEntityById(state.currentCheckpoint);
	        this.currentCheckpointTrigger = this.game.getEntityById(state.currentCheckpointTrigger);
	        this.checkpointCollectedGems = new Set(state.checkpointCollectedGems.map(x => this.game.getEntityById(x)));
	        this.checkpointHeldPowerUp = this.game.getEntityById(state.checkpointHeldPowerUp);
	        this.checkpointUp = state.checkpointUp && new Vector3$1().fromObject(state.checkpointUp);
	        this.checkpointBlast = state.checkpointBlast;
	    }
	    getInternalState() {
	        return {
	            scheduledPickUpFrame: this.scheduledPickUpFrame
	        };
	    }
	    loadInternalState(state) {
	        this.scheduledPickUpFrame = state.scheduledPickUpFrame;
	    }
	}
	//# sourceMappingURL=checkpoint_state.js.map

	/** The starting location of the level. */
	class StartPad$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/pads/startarea.dts";
	    }
	}
	//# sourceMappingURL=start_pad.js.map

	const DEFAULT_RADIUS = 0.2;
	const ULTRA_RADIUS = 0.3;
	const MEGA_MARBLE_RADIUS = 0.6666;
	const MARBLE_ROLL_FORCE = 40 ;
	const TELEPORT_FADE_DURATION = 0.5;
	const BLAST_CHARGE_TIME = 25000;
	const DEFAULT_PITCH = 0.45;
	const DEFAULT_YAW = Math.PI / 2;
	const bounceParticleOptions = {
	    ejectionPeriod: 1,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 2.6,
	    velocityVariance: 0.25 * 0.5,
	    emitterLifetime: 3,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/star.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 90,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 500,
	        lifetimeVariance: 100,
	        dragCoefficient: 0.5,
	        acceleration: -2,
	        colors: [{ r: 0.9, g: 0, b: 0, a: 1 }, { r: 0.9, g: 0.9, b: 0, a: 1 }, { r: 0.9, g: 0.9, b: 0, a: 0 }],
	        sizes: [0.25, 0.25, 0.25],
	        times: [0, 0.75, 1]
	    }
	};
	const blastParticleOptions = {
	    ejectionPeriod: 0.9,
	    ambientVelocity: new Vector3$1(0, 0, -0.3),
	    ejectionVelocity: 3,
	    velocityVariance: 0.4,
	    emitterLifetime: 300,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 20,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 600,
	        lifetimeVariance: 250,
	        dragCoefficient: 0.2,
	        acceleration: -0.1,
	        colors: [{ r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 0.2 }, { r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 1 }, { r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 1 }, { r: 25 / 255, g: 244 / 255, b: 255 / 255, a: 0 }],
	        sizes: [0.1, 0.1, 0.1],
	        times: [0, 0.2, 0.75, 1]
	    }
	};
	const blastMaxParticleOptions = ParticleEmitter.cloneOptions(blastParticleOptions);
	blastMaxParticleOptions.ejectionVelocity = 4;
	blastMaxParticleOptions.ejectionPeriod = 0.7;
	blastMaxParticleOptions.particleOptions.dragCoefficient = 0.3;
	blastMaxParticleOptions.particleOptions.colors = blastMaxParticleOptions.particleOptions.colors.map(x => { x.r = 255 / 255; x.g = 159 / 255; x.b = 25 / 255; return x; });
	class Marble$1 extends Entity {
	    constructor(game, id, checkpointStateId) {
	        super(game);
	        this.restartable = true;
	        /** The predicted position of the marble in the next tick. */
	        this.predictedPosition = new Vector3$1();
	        /** The predicted orientation of the marble in the next tick. */
	        this.predictedOrientation = new Quaternion$1();
	        this.addedToGame = false;
	        /** The radius of the marble. */
	        this.radius = null;
	        /** The default jump impulse of the marble. */
	        this.jumpImpulse =  7.3; // For now, seems to fit more than the "actual" 7.5.
	        /** The default restitution of the marble. */
	        this.bounceRestitution = 0.5;
	        this.currentControlState = Marble$1.getPassiveControlState();
	        this.superBounceEnableFrame = -Infinity;
	        this.shockAbsorberEnableFrame = -Infinity;
	        this.helicopterEnableFrame = -Infinity;
	        this.megaMarbleEnableFrame = -Infinity;
	        this.helicopterSound = null;
	        this.shockAbsorberSound = null;
	        this.superBounceSound = null;
	        this.teleportEnableTime = null;
	        this.teleportDisableTime = null;
	        this.beforeVel = new Vector3$1();
	        this.beforeAngVel = new Vector3$1();
	        /** Necessary for super speed. */
	        this.lastContactNormal = new Vector3$1();
	        this.slidingTimeout = 0;
	        this.endPadColliderTimeout = 0;
	        this.inFinishState = false;
	        this.finishCameraAnimationStart = null;
	        this.outOfBoundsFrame = null;
	        this.outOfBoundsCameraPosition = null;
	        this.respawnFrame = 0;
	        this.oldUp = new Vector3$1(0, 0, 1);
	        this.currentUp = new Vector3$1(0, 0, 1);
	        /** The last time the orientation was changed (by a gravity modifier) */
	        this.orientationChangeTime = -Infinity;
	        /** The old camera orientation quat */
	        this.oldOrientationQuat = new Quaternion$1();
	        /** The new target camera orientation quat */
	        this.orientationQuat = new Quaternion$1();
	        this.heldPowerUp = null;
	        this.blastAmount = 0;
	        this.reconciliationPosition = new Vector3$1();
	        this.interpolatedPosition = new Vector3$1();
	        this.interpolatedOrientation = new Quaternion$1();
	        this.interpolationRemaining = 0;
	        this.interpolationStrength = 1;
	        this.teleportStates = [];
	        this.teleportSounds = new DefaultMap(() => []);
	        this.id = id;
	        this.checkpointState = new CheckpointState(game, checkpointStateId, this);
	    }
	    get speedFac() {
	        return DEFAULT_RADIUS / this.radius;
	    }
	    async init() {
	        var _a;
	        this.group = new Group(true);
	        this.innerGroup = new Group();
	        this.group.add(this.innerGroup);
	        let mission = this.game.mission;
	        if (mission.misFile.marbleAttributes["jumpImpulse"] !== undefined)
	            this.jumpImpulse = MisParser$1.parseNumber(mission.misFile.marbleAttributes["jumpImpulse"]);
	        if (mission.misFile.marbleAttributes["bounceRestitution"] !== undefined)
	            this.bounceRestitution = MisParser$1.parseNumber(mission.misFile.marbleAttributes["bounceRestitution"]);
	        // Get the correct texture
	        let marbleTexture;
	        let customTextureBlob = await StorageManager$1.databaseGet('keyvalue', 'marbleTexture');
	        if (customTextureBlob) {
	            try {
	                let url = ResourceManager$1.getUrlToBlob(customTextureBlob);
	                marbleTexture = await ResourceManager$1.getTexture(url, '');
	            }
	            catch (e) {
	                console.error("Failed to load custom marble texture:", e);
	            }
	        }
	        else {
	            marbleTexture = await ResourceManager$1.getTexture("shapes/balls/base.marble.png");
	        }
	        let has2To1Texture = marbleTexture.image.width === marbleTexture.image.height * 2;
	        if (this.isReflective()) {
	            this.cubeMap = new CubeTexture$1(mainRenderer$1, 128);
	            this.cubeCamera = new CubeCamera(0.025, this.game.renderer.camera.far);
	        }
	        const addMarbleReflectivity = (m) => {
	            m.envMap = this.cubeMap;
	            m.envMapZUp = false;
	            m.reflectivity = 0.7;
	            m.useFresnel = true;
	            m.useAccurateReflectionRay = true;
	        };
	        // Create the 3D object
	        if (has2To1Texture || (mission.modification === 'ultra' && !customTextureBlob)) {
	            let ballShape = new Shape$1();
	            ballShape.shareMaterials = false;
	            ballShape.dtsPath = 'shapes/balls/pack1/pack1marble.dts';
	            ballShape.castShadows = true;
	            ballShape.materialPostprocessor = m => {
	                m.normalizeNormals = true; // We do this so that the marble doesn't get darker the larger it gets
	                m.flipY = true;
	                if (this.isReflective())
	                    addMarbleReflectivity(m);
	            };
	            if (customTextureBlob)
	                ballShape.matNamesOverride['base.marble'] = marbleTexture;
	            await ballShape.init(this.game);
	            this.innerGroup.add(ballShape.group);
	            this.ballShape = ballShape;
	        }
	        let geometry = Geometry$1.createSphereGeometry(1, 32, 16);
	        let sphereMaterial = new Material$1();
	        sphereMaterial.diffuseMap = marbleTexture;
	        sphereMaterial.normalizeNormals = true;
	        sphereMaterial.flipY = true;
	        if (this.isReflective())
	            addMarbleReflectivity(sphereMaterial);
	        // Create the sphere's mesh
	        let sphere = new Mesh$1(geometry, [sphereMaterial]);
	        sphere.castShadows = true;
	        this.sphere = sphere;
	        this.innerGroup.add(sphere);
	        // Create the physics stuff
	        this.body = new RigidBody();
	        this.body.userData = this;
	        this.body.evaluationOrder = this.id + 1000000; // Make sure this body's handlers are called after all the other ones (interiors, shapes, etc)
	        let colShape = new BallCollisionShape(0); // We'll update the radius later
	        colShape.restitution = this.bounceRestitution;
	        this.shape = colShape;
	        this.body.addCollisionShape(colShape);
	        let largeAuxShape = new BallCollisionShape(0);
	        largeAuxShape.collisionDetectionMask = 0b10;
	        largeAuxShape.collisionResponseMask = 0;
	        this.body.addCollisionShape(largeAuxShape);
	        let smallAuxShape = new BallCollisionShape(0);
	        smallAuxShape.collisionDetectionMask = 0b100;
	        smallAuxShape.collisionResponseMask = 0;
	        this.body.addCollisionShape(smallAuxShape);
	        colShape.broadphaseShape = largeAuxShape;
	        smallAuxShape.broadphaseShape = largeAuxShape;
	        this.largeAuxShape = largeAuxShape;
	        this.smallAuxShape = smallAuxShape;
	        this.body.onBeforeIntegrate = this.onBeforeIntegrate.bind(this);
	        this.body.onAfterIntegrate = this.onAfterIntegrate.bind(this);
	        this.body.onBeforeCollisionResponse = this.onBeforeCollisionResponse.bind(this);
	        this.body.onAfterCollisionResponse = this.onAfterCollisionResponse.bind(this);
	        // Set the marble's default orientation to be close to actual MBP
	        this.body.orientation.setFromEuler(new Euler$1(Math.PI / 2, Math.PI * 7 / 6, 0));
	        this.forcefield = new Shape$1();
	        this.forcefield.dtsPath = "shapes/images/glow_bounce.dts";
	        this.forcefield.shareId = this.id;
	        await this.forcefield.init(this.game);
	        this.forcefield.setOpacity(0);
	        this.forcefield.showSequences = false; // Hide the weird default animation it does
	        this.innerGroup.add(this.forcefield.group);
	        this.helicopter = new Shape$1();
	        // Easter egg: Due to an iconic bug where the helicopter would instead look like a glow bounce, this can now happen 0.1% of the time.
	        this.helicopter.dtsPath = (Math.random() < 1 / 1000) ? "shapes/images/glow_bounce.dts" : "shapes/images/helicopter.dts";
	        this.helicopter.castShadows = true;
	        this.helicopter.shareId = this.id;
	        await this.helicopter.init(this.game);
	        this.helicopter.setOpacity(0);
	        this.group.add(this.helicopter.group);
	        // Load the necessary rolling sounds
	        let toLoad = ["jump.wav", "bouncehard1.wav", "bouncehard2.wav", "bouncehard3.wav", "bouncehard4.wav", "rolling_hard.wav", "sliding.wav"];
	        if (mission.hasBlast)
	            toLoad.push("blast.wav");
	        await AudioManager$1.loadBuffers(toLoad);
	        this.rollingSound = AudioManager$1.createAudioSource('rolling_hard.wav', undefined, this.body.position);
	        this.rollingSound.play();
	        this.rollingSound.gain.gain.value = 0;
	        this.rollingSound.setLoop(true);
	        // Check if we need to prep a Mega Marble sound
	        if (mission.allElements.some(x => { var _a; return x._type === MissionElementType$1.Item && ((_a = x.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'megamarbleitem'; })) {
	            this.rollingMegaMarbleSound = AudioManager$1.createAudioSource('mega_roll.wav', undefined, this.body.position);
	            this.rollingMegaMarbleSound.gain.gain.value = 0;
	            this.rollingMegaMarbleSound.setLoop(true);
	        }
	        this.slidingSound = AudioManager$1.createAudioSource('sliding.wav', undefined, this.body.position);
	        this.slidingSound.play();
	        this.slidingSound.gain.gain.value = 0;
	        this.slidingSound.setLoop(true);
	        await Promise.all([this.rollingSound.promise, this.slidingSound.promise, (_a = this.rollingMegaMarbleSound) === null || _a === void 0 ? void 0 : _a.promise]);
	    }
	    /** Returns true iff the marble should use special reflective shaders. */
	    isReflective() {
	        return (StorageManager$1.data.settings.marbleReflectivity === 2 || (StorageManager$1.data.settings.marbleReflectivity === 0 && this.game.mission.modification === 'ultra')) && !Util$1.isIOS();
	        // On some iOS devices, the reflective marble is invisible. That implies a shader compilation error but I sadly cannot check the console on there so we're just disabling them for all iOS devices.
	    }
	    addToGame() {
	        let { game } = this;
	        let { simulator, renderer } = game;
	        renderer.scene.add(this.group);
	        simulator.world.add(this.body);
	        this.addedToGame = true;
	    }
	    getState() {
	        var _a, _b, _c;
	        return {
	            entityType: 'marble',
	            position: this.body.position.clone(),
	            orientation: this.body.orientation.clone(),
	            linearVelocity: this.body.linearVelocity.clone(),
	            angularVelocity: this.body.angularVelocity.clone(),
	            extras: {
	                heldPowerUp: (_a = this.heldPowerUp) === null || _a === void 0 ? void 0 : _a.id,
	                helicopterEnableFrame: this.helicopterIsActive() ? this.helicopterEnableFrame : undefined,
	                superBounceEnableFrame: this.superBounceIsActive() ? this.superBounceEnableFrame : undefined,
	                shockAbsorberEnableFrame: this.shockAbsorberIsActive() ? this.shockAbsorberEnableFrame : undefined,
	                megaMarbleEnableFrame: this.megaMarbleIsActive() ? this.megaMarbleEnableFrame : undefined,
	                orientationQuat: this.orientationQuat.equals(new Quaternion$1()) ? undefined : this.orientationQuat.clone(),
	                respawnFrame: this.respawnFrame || undefined,
	                outOfBoundsFrame: (_b = this.outOfBoundsFrame) !== null && _b !== void 0 ? _b : undefined,
	                teleportStates: this.teleportStates.length ? this.teleportStates.map(x => ({
	                    trigger: x.trigger.id,
	                    entryFrame: x.entryFrame,
	                    exitFrame: x.exitFrame
	                })) : undefined,
	                teleportEnableTime: (_c = this.teleportEnableTime) !== null && _c !== void 0 ? _c : undefined,
	                teleportDisableTime: this.teleportDisableTime !== null && this.game.state.time - this.teleportDisableTime < TELEPORT_FADE_DURATION ? this.teleportDisableTime : undefined,
	                blastAmount: this.blastAmount || undefined,
	                inFinishState: this.inFinishState || undefined
	            }
	        };
	    }
	    getInitialState() {
	        let { position } = this.getStartPositionAndOrientation();
	        return {
	            entityType: 'marble',
	            position: position,
	            orientation: this.body.orientation.clone(),
	            linearVelocity: new Vector3$1(),
	            angularVelocity: new Vector3$1(),
	            extras: {}
	        };
	    }
	    loadState(state, { remote }) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
	        this.body.position.fromObject(state.position);
	        this.body.orientation.fromObject(state.orientation);
	        this.body.linearVelocity.fromObject(state.linearVelocity);
	        this.body.angularVelocity.fromObject(state.angularVelocity);
	        if (remote) {
	            this.body.syncShapes();
	            this.body.updateCollisions();
	            this.internalStateNeedsStore = true;
	        }
	        this.heldPowerUp = this.game.getEntityById(state.extras.heldPowerUp);
	        this.helicopterEnableFrame = (_a = state.extras.helicopterEnableFrame) !== null && _a !== void 0 ? _a : -Infinity;
	        this.superBounceEnableFrame = (_b = state.extras.superBounceEnableFrame) !== null && _b !== void 0 ? _b : -Infinity;
	        this.shockAbsorberEnableFrame = (_c = state.extras.shockAbsorberEnableFrame) !== null && _c !== void 0 ? _c : -Infinity;
	        this.megaMarbleEnableFrame = (_d = state.extras.megaMarbleEnableFrame) !== null && _d !== void 0 ? _d : -Infinity;
	        let orientationQuat = state.extras.orientationQuat ?
	            new Quaternion$1().fromObject(state.extras.orientationQuat)
	            : new Quaternion$1();
	        let up = new Vector3$1(0, 0, 1).applyQuaternion(orientationQuat).normalize();
	        let different = !this.orientationQuat.equals(orientationQuat);
	        if (different) {
	            // Start an animation
	            let currentQuat = this.getInterpolatedOrientationQuat();
	            this.oldOrientationQuat.copy(currentQuat);
	            this.orientationChangeTime = this.game.state.time;
	        }
	        this.orientationQuat.copy(orientationQuat);
	        this.currentUp.copy(up);
	        let gravityStrength = this.body.gravity.length();
	        this.body.gravity.copy(up).multiplyScalar(-1 * gravityStrength);
	        let newRespawnFrame = (_e = state.extras.respawnFrame) !== null && _e !== void 0 ? _e : 0;
	        if (newRespawnFrame > this.respawnFrame) {
	            this.game.simulator.executeNonDuplicatableEvent(() => {
	                AudioManager$1.play('spawn.wav', undefined, undefined, this.body.position);
	            }, `${this.id}respawnSound`, true);
	        }
	        this.respawnFrame = newRespawnFrame;
	        if (this.outOfBoundsFrame === null && state.extras.outOfBoundsFrame !== undefined)
	            this.goOutOfBounds(state.extras.outOfBoundsFrame);
	        this.outOfBoundsFrame = (_f = state.extras.outOfBoundsFrame) !== null && _f !== void 0 ? _f : null;
	        this.teleportStates = ((_g = state.extras.teleportStates) !== null && _g !== void 0 ? _g : []).map(x => ({
	            trigger: this.game.getEntityById(x.trigger),
	            entryFrame: x.entryFrame,
	            exitFrame: x.exitFrame
	        }));
	        this.teleportEnableTime = (_h = state.extras.teleportEnableTime) !== null && _h !== void 0 ? _h : null;
	        this.teleportDisableTime = (_j = state.extras.teleportDisableTime) !== null && _j !== void 0 ? _j : null;
	        this.blastAmount = state.extras.blastAmount || 0;
	        this.inFinishState = !!state.extras.inFinishState;
	    }
	    getInternalState() {
	        return {
	            collisions: this.body.collisions.slice(),
	            inContactCcd: this.body.inContactCcd,
	            lastContactNormal: this.lastContactNormal.clone(),
	            slidingTimeout: this.slidingTimeout,
	            oldOrientationQuat: this.oldOrientationQuat.clone(),
	            orientationQuat: this.orientationQuat.clone(),
	            orientationChangeTime: this.orientationChangeTime,
	            endPadColliderTimeout: this.endPadColliderTimeout
	        };
	    }
	    loadInternalState(state) {
	        this.body.updateCollisions(state.collisions);
	        this.body.inContactCcd = state.inContactCcd;
	        this.lastContactNormal.copy(state.lastContactNormal);
	        this.slidingTimeout = state.slidingTimeout;
	        this.orientationQuat.copy(state.orientationQuat);
	        this.oldOrientationQuat.copy(state.oldOrientationQuat);
	        this.orientationChangeTime = state.orientationChangeTime;
	        this.endPadColliderTimeout = state.endPadColliderTimeout;
	    }
	    update() {
	        var _a, _b, _c, _d, _e, _f;
	        if (!this.addedToGame)
	            return;
	        // Always:
	        this.stateNeedsStore = true;
	        this.internalStateNeedsStore = true;
	        if (this.controllingPlayer)
	            this.currentControlState = this.controllingPlayer.controlState;
	        if (this.outOfBoundsFrame !== null &&
	            (this.currentControlState.using || this.game.state.frame - this.outOfBoundsFrame >= 2 * GAME_UPDATE_RATE) &&
	            !(this.game.finishState.finished && this.game.finishState.isLegal)) {
	            // Respawn the marble two seconds after having gone out of bounds
	            if (this.game.type === 'singleplayer' && !this.checkpointState.currentCheckpoint)
	                this.game.state.restartFrames.push(this.game.state.frame + 1);
	            else
	                this.respawn(false);
	        }
	        let reconciling = this.game.simulator.isReconciling;
	        if (this.shockAbsorberIsActive()) {
	            // Show the shock absorber (takes precedence over super bounce)
	            this.forcefield.setOpacity(1);
	            this.shape.restitution = 0.01; // Yep it's not actually zero
	            if (!this.shockAbsorberSound && !reconciling) {
	                this.shockAbsorberSound = AudioManager$1.createAudioSource('superbounceactive.wav', undefined, this.body.position);
	                this.shockAbsorberSound.setLoop(true);
	                this.shockAbsorberSound.play();
	            }
	        }
	        else if (this.superBounceIsActive()) {
	            // Show the super bounce
	            this.forcefield.setOpacity(1);
	            this.shape.restitution = 0.9;
	            if (!reconciling) {
	                (_a = this.shockAbsorberSound) === null || _a === void 0 ? void 0 : _a.stop();
	                this.shockAbsorberSound = null;
	            }
	        }
	        else {
	            // Stop both shock absorber and super bounce
	            this.forcefield.setOpacity(0);
	            this.shape.restitution = this.bounceRestitution;
	            if (!reconciling) {
	                (_b = this.shockAbsorberSound) === null || _b === void 0 ? void 0 : _b.stop();
	                this.shockAbsorberSound = null;
	                (_c = this.superBounceSound) === null || _c === void 0 ? void 0 : _c.stop();
	                this.superBounceSound = null;
	            }
	        }
	        if (this.superBounceIsActive() && !this.superBounceSound && !reconciling) {
	            // Play the super bounce sound
	            this.superBounceSound = AudioManager$1.createAudioSource('forcefield.wav', undefined, this.body.position);
	            this.superBounceSound.setLoop(true);
	            this.superBounceSound.play();
	        }
	        if (this.helicopterIsActive()) {
	            // Show the helicopter
	            this.helicopter.setOpacity(1);
	            this.helicopter.setTransform(new Vector3$1(0, 0, this.radius - DEFAULT_RADIUS).applyQuaternion(this.orientationQuat), this.orientationQuat, new Vector3$1(1, 1, 1));
	            this.setGravityIntensity(this.game.mission.getDefaultGravity() * 0.25);
	            if (!this.helicopterSound && !reconciling) {
	                this.helicopterSound = AudioManager$1.createAudioSource('use_gyrocopter.wav', undefined, this.body.position);
	                this.helicopterSound.setLoop(true);
	                this.helicopterSound.play();
	            }
	        }
	        else {
	            // Stop the helicopter
	            this.helicopter.setOpacity(0);
	            this.setGravityIntensity(this.game.mission.getDefaultGravity() * 1);
	            if (!reconciling) {
	                (_d = this.helicopterSound) === null || _d === void 0 ? void 0 : _d.stop();
	                this.helicopterSound = null;
	            }
	        }
	        if (this.megaMarbleIsActive()) {
	            this.setRadius(MEGA_MARBLE_RADIUS);
	            if (!reconciling) {
	                this.rollingSound.stop();
	                (_e = this.rollingMegaMarbleSound) === null || _e === void 0 ? void 0 : _e.play();
	            }
	        }
	        else {
	            this.setRadius(this.game.mission.hasUltraMarble ? ULTRA_RADIUS : DEFAULT_RADIUS);
	            if (!reconciling) {
	                this.rollingSound.play();
	                (_f = this.rollingMegaMarbleSound) === null || _f === void 0 ? void 0 : _f.stop();
	            }
	        }
	        this.slidingTimeout--;
	        // Handle teleporting
	        for (let teleportState of this.teleportStates) {
	            if (teleportState.entryFrame === null)
	                continue;
	            let delayInFrames = teleportState.trigger.delay * GAME_UPDATE_RATE / 1000;
	            if (this.game.state.frame - teleportState.entryFrame >= delayInFrames) {
	                // Execute the teleport
	                teleportState.trigger.executeTeleport(this);
	                continue;
	            }
	            // There's a little delay after exiting before the teleporter gets cancelled
	            if (teleportState.exitFrame !== null && this.game.state.frame - teleportState.exitFrame > 0.05 * GAME_UPDATE_RATE) {
	                // Cancel the teleport
	                teleportState.entryFrame = null;
	                teleportState.exitFrame = null;
	                return;
	            }
	        }
	        // Increase blast meter over time
	        if (this.game.mission.hasBlast && this.blastAmount < 1)
	            this.blastAmount = Util$1.clamp(this.blastAmount + 1000 / BLAST_CHARGE_TIME / GAME_UPDATE_RATE, 0, 1);
	        if (this.inFinishState)
	            this.body.gravity.multiplyScalar(0);
	        if (this.endPadColliderTimeout > 0)
	            this.endPadColliderTimeout--;
	        if (!reconciling && this.inFinishState && this.finishCameraAnimationStart === null) {
	            this.finishCameraAnimationStart = this.game.state.time;
	            this.finishYaw = this.currentControlState.yaw;
	            this.finishPitch = this.currentControlState.pitch;
	        }
	        Util$1.filterInPlace(this.teleportStates, x => x.entryFrame !== null || x.exitFrame !== null);
	    }
	    findBestCollision(withRespectTo) {
	        let bestCollision;
	        let bestCollisionValue = -Infinity;
	        for (let collision of this.body.collisions) {
	            if (collision.s1 !== this.shape && collision.s2 !== this.shape)
	                continue; // Could also be an aux collider that caused the collision but we don't wanna count that here
	            let otherShape = collision.s1 === this.shape ? collision.s2 : collision.s1;
	            let normal = collision.s1 === this.shape ? collision.normal : collision.normal.clone().negate();
	            let value = withRespectTo(collision, normal, otherShape);
	            if (value > bestCollisionValue) {
	                bestCollision = collision;
	                bestCollisionValue = value;
	            }
	        }
	        if (!bestCollision)
	            return null;
	        let contactNormal = bestCollision.normal;
	        let contactShape = bestCollision.s2;
	        if (bestCollision.s1 !== this.shape) {
	            contactNormal = contactNormal.clone().negate();
	            contactShape = bestCollision.s1;
	        }
	        // How much the current surface is pointing up
	        let contactNormalUpDot = Math.abs(contactNormal.dot(this.currentUp));
	        return { collision: bestCollision, contactNormal, contactShape, contactNormalUpDot };
	    }
	    onBeforeIntegrate(dt) {
	        var _a;
	        let controlState = this.currentControlState;
	        let reconciling = this.game.simulator.isReconciling;
	        let movementVec = new Vector3$1(controlState.movement.x, controlState.movement.y, 0);
	        let inputStrength = movementVec.length();
	        // Rotate the vector accordingly
	        movementVec.multiplyScalar(MARBLE_ROLL_FORCE * 5 * dt);
	        movementVec.applyAxisAngle(new Vector3$1(0, 0, 1), controlState.yaw);
	        let quat = this.orientationQuat;
	        movementVec.applyQuaternion(quat);
	        // The axis of rotation (for angular velocity) is the cross product of the current up vector and the movement vector, since the axis of rotation is perpendicular to both.
	        let movementRotationAxis = this.currentUp.clone().cross(movementVec);
	        let bestCollision = this.findBestCollision((_, normal) => normal.dot(this.currentUp));
	        if (bestCollision) {
	            let { collision, contactNormal, contactNormalUpDot } = bestCollision;
	            // The rotation necessary to get from the up vector to the contact normal.
	            let contactNormalRotation = new Quaternion$1().setFromUnitVectors(this.currentUp, contactNormal);
	            movementRotationAxis.applyQuaternion(contactNormalRotation);
	            // Weaken the marble's angular power based on the friction and steepness of the surface
	            let dot = -movementVec.clone().normalize().dot(contactNormal);
	            let penalty = Math.max(0, dot - Math.max(0, (collision.s2Friction - 1.0)));
	            movementRotationAxis.multiplyScalar(1 - penalty);
	            // Apply angular velocity changes
	            let angVel = this.body.angularVelocity;
	            // Subtract the movement axis so it doesn't get slowed down
	            let direction = movementRotationAxis.clone().normalize();
	            let dot2 = Math.max(0, angVel.dot(direction));
	            angVel.addScaledVector(direction, -dot2);
	            // Subtract the "surface rotation axis", this ensures we can roll down hills quickly
	            let surfaceRotationAxis = this.currentUp.clone().cross(contactNormal);
	            let dot3 = Math.max(angVel.dot(surfaceRotationAxis), 0);
	            angVel.addScaledVector(surfaceRotationAxis, -dot3);
	            angVel.multiplyScalar(0.02 ** (Math.min(1, collision.friction) * dt)); // Handle velocity slowdown
	            // Add them back
	            angVel.addScaledVector(surfaceRotationAxis, dot3);
	            angVel.addScaledVector(direction, dot2);
	            if (angVel.length() > 300 * this.speedFac)
	                angVel.multiplyScalar(300 * this.speedFac / angVel.length()); // Absolute max angular speed
	            if (dot2 + movementRotationAxis.length() > 12 * Math.PI * 2 * inputStrength / contactNormalUpDot * this.speedFac) {
	                // Cap the rolling velocity
	                let newLength = Math.max(0, 12 * Math.PI * 2 * inputStrength / contactNormalUpDot * this.speedFac - dot2);
	                movementRotationAxis.normalize().multiplyScalar(newLength);
	            }
	        }
	        else {
	            // Handle airborne movement
	            // Angular acceleration isn't quite as speedy
	            movementRotationAxis.multiplyScalar(1 / 2);
	            let airMovementVector = movementVec.clone();
	            let airVelocity = this.helicopterIsActive() ? 5 : 3.2; // Change air velocity for the helicopter
	            if (this.inFinishState)
	                airVelocity = 0;
	            airMovementVector.multiplyScalar(airVelocity * dt);
	            this.body.linearVelocity.add(airMovementVector);
	            if (!reconciling) {
	                this.slidingSound.gain.gain.value = 0;
	                this.rollingSound.gain.gain.linearRampToValueAtTime(0, AudioManager$1.context.currentTime + 0.02);
	                (_a = this.rollingMegaMarbleSound) === null || _a === void 0 ? void 0 : _a.gain.gain.linearRampToValueAtTime(0, AudioManager$1.context.currentTime + 0.02);
	            }
	        }
	        movementRotationAxis.multiplyScalar(this.speedFac);
	        // Apply angular acceleration, but make sure the angular velocity doesn't exceed some maximum
	        Util$1.addToVectorCapped(this.body.angularVelocity, movementRotationAxis, 120 * this.speedFac);
	        if (this.inFinishState)
	            this.body.linearVelocity.multiplyScalar(dt / (1 / GAME_UPDATE_RATE) * 0.9);
	        if (controlState.using && this.heldPowerUp) {
	            this.heldPowerUp.use(this, 0);
	            this.heldPowerUp.useCosmetically(this);
	            this.unequipPowerUp();
	        }
	        if (controlState.blasting)
	            this.useBlast();
	    }
	    onAfterIntegrate() {
	        // We'll need these for collision response lata
	        this.beforeVel.copy(this.body.linearVelocity);
	        this.beforeAngVel.copy(this.body.angularVelocity);
	        if (this.game.state.frame - this.game.state.lastRestartFrame < 3.5 * GAME_UPDATE_RATE) {
	            // Lock the marble to the space above the start pad
	            let { position: startPosition } = this.getStartPositionAndOrientation();
	            let position = this.body.position;
	            position.x = startPosition.x;
	            position.y = startPosition.y;
	            let vel = this.body.linearVelocity;
	            vel.x = vel.y = 0;
	            let angVel = this.body.angularVelocity;
	            // Cap the angular velocity so it doesn't go haywire
	            if (angVel.length() > 60)
	                angVel.normalize().multiplyScalar(60);
	            this.shape.friction = 0;
	        }
	        else {
	            this.shape.friction = 1;
	        }
	    }
	    onBeforeCollisionResponse() {
	        // Create bounce particles
	        let mostPowerfulCollision = this.findBestCollision((_, normal, otherShape) => {
	            return -normal.dot(this.body.linearVelocity.clone().sub(otherShape.body.linearVelocity));
	        });
	        if (!mostPowerfulCollision || mostPowerfulCollision.collision.s1 !== this.shape)
	            return; // We don't want marble-marble collisions to be processed twice, once by each marble, but we let one marble do it for both
	        let impactVelocity = -mostPowerfulCollision.contactNormal.dot(this.body.linearVelocity.clone().sub(mostPowerfulCollision.contactShape.body.linearVelocity));
	        if (impactVelocity > 6)
	            this.showBounceParticles();
	        // Handle bounce sound
	        let volume = Util$1.clamp((impactVelocity / 12) ** 1.5, 0, 1);
	        if (impactVelocity > 1) {
	            // Play a collision impact sound
	            this.playBounceSound(volume);
	            //if (this.level.replay.canStore) this.level.replay.bounceTimes.push({ tickIndex: this.level.replay.currentTickIndex, volume: volume, showParticles: impactVelocity > 6 });
	        }
	        // Check for marble-marble collisions
	        for (let collision of this.body.collisions) {
	            let shapes = [collision.s1, collision.s2];
	            if (!shapes.includes(this.shape))
	                continue;
	            if (shapes[0] !== this.shape)
	                shapes.reverse();
	            if (!(shapes[1] instanceof BallCollisionShape))
	                continue;
	            if (!(shapes[1].body.userData instanceof Marble$1))
	                continue;
	            let otherMarble = shapes[1].body.userData;
	            this.onMarbleMarbleCollision(otherMarble, collision);
	        }
	    }
	    onAfterCollisionResponse() {
	        var _a, _b, _c;
	        let bestCollision = this.findBestCollision((_, normal) => normal.dot(this.currentUp));
	        if (!bestCollision)
	            return;
	        let { collision, contactNormal, contactShape, contactNormalUpDot } = bestCollision;
	        this.lastContactNormal.copy(contactNormal);
	        let lastSurfaceRelativeVelocity = this.beforeVel.clone().sub(contactShape.body.linearVelocity);
	        let surfaceRelativeVelocity = this.body.linearVelocity.clone().sub(contactShape.body.linearVelocity);
	        let maxDotSlide = 0.5; // 30°
	        let reconciling = this.game.simulator.isReconciling;
	        // Implements sliding: If we hit the surface at an angle below 45°, and have movement keys pressed, we don't bounce.
	        let dot0 = -contactNormal.dot(lastSurfaceRelativeVelocity.clone().normalize());
	        let slidingEligible = contactNormalUpDot > 0.1; // Kinda arbitrary rn, it's about 84°, definitely makes sure we don't slide on walls
	        if (slidingEligible && this.slidingTimeout <= 0 && dot0 > 0.001 && dot0 <= maxDotSlide && this.currentControlState.movement.length() > 0) {
	            let dot = contactNormal.dot(surfaceRelativeVelocity);
	            let linearVelocity = this.body.linearVelocity;
	            let originalLength = linearVelocity.length();
	            linearVelocity.addScaledVector(contactNormal, -dot); // Remove all velocity in the direction of the surface normal
	            let newLength = linearVelocity.length();
	            let diff = originalLength - newLength;
	            linearVelocity.normalize().multiplyScalar(newLength + diff * 2); // Give a small speedboost
	        }
	        // If we're using a shock absorber or we're on a low-restitution surface, give the marble a velocity boost on contact based on its angular velocity.
	        outer: if (collision.restitution < 0.5) {
	            let dot = -this.beforeVel.dot(contactNormal);
	            if (dot < 0)
	                break outer;
	            let boost = this.beforeAngVel.clone().cross(contactNormal).multiplyScalar(2 * (0.5 - collision.restitution) * dot / 300 / 0.98); // 0.98 fac because shock absorber used to have 0 rest but now 0.01
	            this.body.linearVelocity.add(boost);
	        }
	        // Create a certain velocity boost on collisions with walls based on angular velocity. This assists in making wall-hits feel more natural.
	        let angularBoost = this.body.angularVelocity.clone().cross(contactNormal).multiplyScalar((1 - Math.abs(contactNormalUpDot)) * contactNormal.dot(this.body.linearVelocity) / (Math.PI * 2) / 15);
	        if (angularBoost.length() >= 0.01) {
	            // Remove a bit of the current velocity so that the response isn't too extreme
	            let currentVelocity = this.body.linearVelocity;
	            let ratio = angularBoost.length() / currentVelocity.length();
	            currentVelocity.multiplyScalar(1 / (1 + ratio * 0.5)).add(angularBoost);
	        }
	        // Handle jumping
	        if (this.currentControlState.jumping && contactNormalUpDot > 1e-6) {
	            this.setLinearVelocityInDirection(contactNormal, this.jumpImpulse + contactShape.body.linearVelocity.dot(contactNormal), true, () => {
	                this.playJumpSound();
	            });
	        }
	        // Handle rolling and sliding sounds
	        if (!reconciling) {
	            if (contactNormal.dot(surfaceRelativeVelocity) < 0.01) {
	                let predictedMovement = this.body.angularVelocity.clone().cross(this.currentUp).multiplyScalar(1 / Math.PI / 2);
	                // The expected movement based on the current angular velocity. If actual movement differs too much, we consider the marble to be "sliding".
	                if (predictedMovement.dot(surfaceRelativeVelocity) < -0.00001 || (predictedMovement.length() > 0.5 && predictedMovement.length() > surfaceRelativeVelocity.length() * 1.5)) {
	                    this.slidingSound.gain.gain.value = 0.6;
	                    this.rollingSound.gain.gain.value = 0;
	                    if (this.rollingMegaMarbleSound)
	                        this.rollingMegaMarbleSound.gain.gain.value = 0;
	                }
	                else {
	                    this.slidingSound.gain.gain.value = 0;
	                    let pitch = Util$1.clamp(surfaceRelativeVelocity.length() / 15, 0, 1) * 0.75 + 0.75;
	                    this.rollingSound.gain.gain.linearRampToValueAtTime(Util$1.clamp(pitch - 0.75, 0, 1), AudioManager$1.context.currentTime + 0.02);
	                    (_a = this.rollingMegaMarbleSound) === null || _a === void 0 ? void 0 : _a.gain.gain.linearRampToValueAtTime(Util$1.clamp(pitch - 0.75, 0, 1), AudioManager$1.context.currentTime + 0.02);
	                    this.rollingSound.setPlaybackRate(pitch);
	                    (_b = this.rollingMegaMarbleSound) === null || _b === void 0 ? void 0 : _b.setPlaybackRate(pitch);
	                }
	            }
	            else {
	                this.slidingSound.gain.gain.value = 0;
	                this.rollingSound.gain.gain.linearRampToValueAtTime(0, AudioManager$1.context.currentTime + 0.02);
	                (_c = this.rollingMegaMarbleSound) === null || _c === void 0 ? void 0 : _c.gain.gain.linearRampToValueAtTime(0, AudioManager$1.context.currentTime + 0.02);
	            }
	        }
	    }
	    postUpdate() {
	        if (!this.game.simulator.isReconciling) {
	            if (this.interpolationRemaining-- <= 0) {
	                this.interpolatedPosition.copy(this.body.position);
	                this.interpolatedOrientation.copy(this.body.orientation);
	            }
	            else {
	                this.interpolatedPosition.addScaledVector(this.body.linearVelocity, 1 / GAME_UPDATE_RATE);
	                this.interpolatedPosition.lerp(this.body.position, this.interpolationStrength);
	                this.interpolatedOrientation.slerp(this.body.orientation, this.interpolationStrength);
	            }
	            this.calculatePredictiveTransforms();
	        }
	    }
	    onMarbleMarbleCollision(otherMarble, collision) {
	        this.affect(otherMarble);
	        // Set restitution for marble-marble collisions
	        collision.restitution = 1;
	        // Set custom collision code for mega marble goodness
	        if (this.megaMarbleIsActive() !== otherMarble.megaMarbleIsActive()) {
	            collision.customVelocitySolver = () => {
	                // https://github.com/MBU-Team/OpenMBU/blob/96061f8d1bb03ede1a7119c139927402f77692f0/engine/source/game/marble/marblephysics.cpp#L379
	                let ourMass = collision.s1.mass;
	                let theirMass = collision.s2.mass;
	                let bounce = 1;
	                let dp = collision.s1.body.linearVelocity.clone().multiplyScalar(ourMass).addScaledVector(collision.s2.body.linearVelocity, -theirMass);
	                let normP = collision.normal.clone().multiplyScalar(dp.dot(collision.normal));
	                normP.multiplyScalar(bounce + 1);
	                collision.s1.body.linearVelocity.addScaledVector(normP, -1 / ourMass);
	                collision.s2.body.linearVelocity.addScaledVector(normP, 1 / theirMass);
	            };
	        }
	    }
	    /** Get the current interpolated orientation quaternion. */
	    getInterpolatedOrientationQuat() {
	        let completion = Util$1.clamp((this.game.state.time - this.orientationChangeTime) / 0.3, 0, 1);
	        return this.oldOrientationQuat.clone().slerp(this.orientationQuat, completion);
	    }
	    setGravityIntensity(intensity) {
	        let gravityVector = this.currentUp.clone().multiplyScalar(-1 * intensity);
	        this.body.gravity.copy(gravityVector); // todo temp whatever
	    }
	    /** Sets the current up vector and gravity with it. */
	    setUp(newUp, instant = false) {
	        let time = this.game.state.time;
	        newUp.normalize(); // We never know 👀
	        this.currentUp.copy(newUp);
	        let gravityStrength = this.body.gravity.length();
	        this.body.gravity.copy(newUp).multiplyScalar(-1 * gravityStrength);
	        let currentQuat = this.getInterpolatedOrientationQuat();
	        let oldUp = this.oldUp = new Vector3$1(0, 0, 1);
	        oldUp.applyQuaternion(currentQuat);
	        let quatChange = new Quaternion$1();
	        let dot = newUp.dot(oldUp);
	        if (dot <= -(1 - 1e-15) /* && !(this.replay.version < 3)*/) { // TODO If the old and new up are exact opposites, there are infinitely many possible rotations we could do. So choose the one that maintains the current look vector the best. Replay check so we don't break old stuff.
	            let lookVector = new Vector3$1(0, 0, 1).applyQuaternion(this.game.renderer.camera.orientation);
	            let intermediateVector = oldUp.clone().cross(lookVector).normalize();
	            // First rotation to the intermediate vector, then rotate from there to the new up
	            quatChange.setFromUnitVectors(oldUp, intermediateVector);
	            quatChange.multiplyQuaternions(new Quaternion$1().setFromUnitVectors(intermediateVector, newUp), quatChange);
	        }
	        else {
	            // Instead of calculating the new quat from nothing, calculate it from the last one to guarantee the shortest possible rotation.
	            quatChange.setFromUnitVectors(oldUp, newUp);
	        }
	        this.orientationQuat = quatChange.multiply(currentQuat);
	        this.oldOrientationQuat = currentQuat;
	        this.orientationChangeTime = instant ? -Infinity : time;
	    }
	    playJumpSound() {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(['jump.wav'], undefined, undefined, this.body.position);
	        }, `${this.id}jump`);
	    }
	    playBounceSound(volume) {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            let prefix = (this.radius === MEGA_MARBLE_RADIUS) ? 'mega_' : '';
	            AudioManager$1.play(['bouncehard1.wav', 'bouncehard2.wav', 'bouncehard3.wav', 'bouncehard4.wav'].map(x => prefix + x), volume, undefined, this.body.position.clone());
	        }, `${this.id}bounceSound`);
	    }
	    showBounceParticles() {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            this.game.renderer.particles.createEmitter(bounceParticleOptions, this.body.position, null, new Vector3$1(1, 1, 1).addScaledVector(this.currentUp.clone().abs(), -0.8));
	        }, `${this.id}bounceParticles`);
	    }
	    /** Sets linear velocity in a specific direction, but capped. Used for things like jumping and bumpers. */
	    setLinearVelocityInDirection(direction, magnitude, onlyIncrease, onIncrease = () => { }) {
	        let unitVelocity = this.body.linearVelocity.clone().normalize();
	        let dot = unitVelocity.dot(direction);
	        let directionalSpeed = dot * this.body.linearVelocity.length();
	        if (directionalSpeed < magnitude || !onlyIncrease) {
	            let velocity = this.body.linearVelocity;
	            velocity.addScaledVector(direction, -directionalSpeed);
	            velocity.addScaledVector(direction, magnitude);
	            if (directionalSpeed < magnitude)
	                onIncrease();
	        }
	    }
	    /** Predicts the position of the marble in the next physics tick to allow for smooth, interpolated rendering. */
	    calculatePredictiveTransforms() {
	        var _a;
	        let pos = this.body.position;
	        let orientation = this.body.orientation;
	        let linVel = this.body.linearVelocity;
	        let angVel = this.body.angularVelocity;
	        // Naive: Just assume the marble moves as if nothing was in its way and it continued with its current velocity.
	        let predictedPosition = pos.clone().addScaledVector(linVel, 1 / GAME_UPDATE_RATE).addScaledVector(this.body.gravity, 1 / GAME_UPDATE_RATE ** 2 / 2);
	        let movementDiff = predictedPosition.clone().sub(pos);
	        let dRotation = angVel.clone().multiplyScalar(1 / GAME_UPDATE_RATE);
	        let dRotationLength = dRotation.length();
	        let dq = new Quaternion$1().setFromAxisAngle(dRotation.normalize(), dRotationLength);
	        let predictedOrientation = dq.multiply(orientation);
	        // See if we hit something, do this to prevent clipping through things
	        let hits = this.game.simulator.world.castShape(this.shape, movementDiff, 1);
	        let hit = hits.find(x => !this.body.collisions.some(y => y.s2 === x.shape)); // Filter out hits with shapes we're already touching
	        let lambda = (_a = hit === null || hit === void 0 ? void 0 : hit.lambda) !== null && _a !== void 0 ? _a : 1;
	        this.predictedPosition.lerpVectors(pos, predictedPosition, lambda);
	        this.predictedOrientation.copy(orientation).slerp(predictedOrientation, lambda);
	    }
	    render() {
	        let time = this.game.state.time;
	        // todo: Position based on current and predicted position and orientation
	        //this.group.position.copy(this.body.position).lerp(this.predictedPosition, this.game.state.subtickCompletion);
	        //this.innerGroup.orientation.copy(this.body.orientation).slerp(this.predictedOrientation, this.game.state.subtickCompletion)
	        this.group.position.copy(this.interpolatedPosition);
	        this.innerGroup.orientation.copy(this.interpolatedOrientation);
	        this.group.recomputeTransform();
	        this.innerGroup.recomputeTransform();
	        this.forcefield.render();
	        if (this.helicopterIsActive())
	            this.helicopter.render();
	        // Update the teleporting look:
	        let teleportFadeCompletion = 0;
	        if (this.teleportEnableTime !== null)
	            teleportFadeCompletion = Util$1.clamp((time - this.teleportEnableTime) / TELEPORT_FADE_DURATION, 0, 1);
	        if (this.teleportDisableTime !== null)
	            teleportFadeCompletion = Util$1.clamp(1 - (time - this.teleportDisableTime) / TELEPORT_FADE_DURATION, 0, 1);
	        if (teleportFadeCompletion > 0) {
	            this.sphere.opacity = Util$1.lerp(1, 0.25, teleportFadeCompletion);
	        }
	        else {
	            this.sphere.opacity = Number(!this.ballShape);
	        }
	    }
	    renderReflection() {
	        if (!this.isReflective())
	            return;
	        this.cubeCamera.position.copy(this.group.position);
	        this.cubeMap.render(this.game.renderer.scene, this.cubeCamera, 4);
	    }
	    enableSuperBounce() {
	        this.superBounceEnableFrame = this.game.state.frame;
	    }
	    enableShockAbsorber() {
	        this.shockAbsorberEnableFrame = this.game.state.frame;
	    }
	    enableHelicopter() {
	        this.helicopterEnableFrame = this.game.state.frame;
	    }
	    enableMegaMarble() {
	        if (!this.megaMarbleIsActive())
	            this.body.linearVelocity.addScaledVector(this.currentUp, 6); // There's a small yeet upwards
	        this.megaMarbleEnableFrame = this.game.state.frame;
	    }
	    superBounceIsActive() {
	        return this.game.state.frame - this.superBounceEnableFrame < 5 * GAME_UPDATE_RATE;
	    }
	    shockAbsorberIsActive() {
	        return this.game.state.frame - this.shockAbsorberEnableFrame < 5 * GAME_UPDATE_RATE;
	    }
	    helicopterIsActive() {
	        return this.game.state.frame - this.helicopterEnableFrame < 5 * GAME_UPDATE_RATE;
	    }
	    megaMarbleIsActive() {
	        return this.game.state.frame - this.megaMarbleEnableFrame < 10 * GAME_UPDATE_RATE;
	    }
	    enableTeleportingLook() {
	        let completion = (this.teleportDisableTime !== null) ? Util$1.clamp((this.game.state.time - this.teleportDisableTime) / TELEPORT_FADE_DURATION, 0, 1) : 1;
	        this.teleportEnableTime = this.game.state.time - TELEPORT_FADE_DURATION * (1 - completion);
	        this.teleportDisableTime = null;
	    }
	    disableTeleportingLook() {
	        var _a;
	        let completion = (_a = Util$1.clamp((this.game.state.time - this.teleportEnableTime) / TELEPORT_FADE_DURATION, 0, 1)) !== null && _a !== void 0 ? _a : 1;
	        this.teleportDisableTime = this.game.state.time - TELEPORT_FADE_DURATION * (1 - completion);
	        this.teleportEnableTime = null;
	    }
	    pickUpPowerUp(powerUp) {
	        if (!powerUp)
	            return false;
	        if (this.heldPowerUp && powerUp.constructor === this.heldPowerUp.constructor)
	            return false;
	        this.heldPowerUp = powerUp;
	        G$1.menu.hud.setPowerupButtonState(true);
	        return true;
	    }
	    unequipPowerUp() {
	        if (!this.heldPowerUp) {
	            G$1.menu.hud.setPowerupButtonState(false);
	            return;
	        }
	        this.heldPowerUp = null;
	        G$1.menu.hud.setPowerupButtonState(false);
	    }
	    goOutOfBounds(frame = this.game.state.frame) {
	        if (this.outOfBoundsFrame !== null || this.inFinishState)
	            return;
	        // I guess this is fine?
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            this.game.renderer.updateCamera(); // Update the camera at the point of OOB-ing
	            this.outOfBoundsCameraPosition = this.game.renderer.camera.position.clone();
	            AudioManager$1.play('whoosh.wav', undefined, undefined, this.body.position.clone());
	        }, `${this.id}whoosh`, true);
	        G$1.menu.hud.setPowerupButtonState(true);
	        this.outOfBoundsFrame = frame;
	    }
	    enableFinishState() {
	        if (this.inFinishState)
	            return;
	        this.inFinishState = true;
	    }
	    useBlast() {
	        if (this.blastAmount < 0.2 || !this.game.mission.hasBlast)
	            return;
	        let impulse = this.currentUp.clone().multiplyScalar(Math.max(Math.sqrt(this.blastAmount), this.blastAmount) * 10);
	        this.body.linearVelocity.add(impulse);
	        for (let marble of this.game.marbles) {
	            if (marble === this)
	                continue;
	            let knockbackStrength = this.blastAmount * (this.blastAmount > 1 ? 10 : 5);
	            if (this.body.position.distanceTo(marble.body.position) < knockbackStrength) {
	                let dir = marble.body.position.clone().sub(this.body.position);
	                dir.normalize().multiplyScalar(knockbackStrength);
	                marble.body.linearVelocity.add(dir);
	                this.affect(marble);
	            }
	        }
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play('blast.wav', undefined, undefined, this.body.position);
	            this.game.renderer.particles.createEmitter((this.blastAmount > 1) ? blastMaxParticleOptions : blastParticleOptions, null, () => this.body.position.clone().addScaledVector(this.currentUp, -this.radius * 0.4), new Vector3$1(1, 1, 1).addScaledVector(this.currentUp.clone().abs(), -0.8));
	        }, `${this.id}blast`);
	        this.blastAmount = 0;
	    }
	    getTeleportState(trigger) {
	        let existing = this.teleportStates.find(x => x.trigger === trigger);
	        if (existing)
	            return existing;
	        this.teleportStates.push({
	            trigger: trigger,
	            entryFrame: null,
	            exitFrame: null
	        });
	        return Util$1.last(this.teleportStates);
	    }
	    /** Updates the radius of the marble both visually and physically. */
	    setRadius(radius) {
	        var _a;
	        if (this.radius === radius)
	            return;
	        this.radius = radius;
	        this.sphere.scale.setScalar(radius);
	        this.sphere.recomputeTransform();
	        (_a = this.ballShape) === null || _a === void 0 ? void 0 : _a.setTransform(new Vector3$1(), new Quaternion$1(), new Vector3$1().setScalar(radius / DEFAULT_RADIUS));
	        this.shape.radius = radius;
	        this.shape.updateInertiaTensor();
	        this.largeAuxShape.radius = 2 * radius;
	        this.smallAuxShape.radius = radius;
	        this.shape.mass = radius === MEGA_MARBLE_RADIUS ? 5 : 1;
	        this.shape.updateInertiaTensor();
	        this.body.syncShapes();
	        this.forcefield.group.scale.setScalar(this.radius / DEFAULT_RADIUS);
	        this.forcefield.group.recomputeTransform();
	    }
	    restart(frame) {
	        super.restart(frame);
	        if (!this.addedToGame)
	            this.addToGame();
	        this.slidingTimeout = 0;
	        this.lastContactNormal.set(0, 0, 0);
	        this.finishCameraAnimationStart = null;
	        this.setUp(new Vector3$1(0, 0, 1), true);
	        this.cancelInterpolation();
	        if (this.controllingPlayer) {
	            let { euler } = this.getStartPositionAndOrientation();
	            this.controllingPlayer.yaw = DEFAULT_YAW + euler.z;
	            this.controllingPlayer.pitch = DEFAULT_PITCH;
	        }
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play('spawn.wav', undefined, undefined, this.body.position);
	        }, `${this.id}respawnSound`, true);
	        G$1.menu.hud.displayHelp(() => {
	            var _a;
	            if (this.controllingPlayer !== this.game.localPlayer)
	                return null;
	            return (_a = this.game.mission.missionInfo.starthelptext) !== null && _a !== void 0 ? _a : null;
	        }, this.game.state.frame, false);
	    }
	    respawn(ignoreCheckpointState) {
	        if (this.checkpointState.currentCheckpoint && !ignoreCheckpointState) {
	            // There's a checkpoint, so load its state instead
	            this.checkpointState.load();
	            return;
	        }
	        // Unpickup all gems picked up by this marble
	        for (let gem of this.game.shapes) {
	            if (!(gem instanceof Gem$1))
	                continue;
	            if (gem.pickedUpBy === this) {
	                gem.pickDown();
	                this.affect(gem);
	            }
	        }
	        this.restart(this.game.state.frame);
	    }
	    /** Gets the position and orientation of the player spawn point. */
	    getStartPositionAndOrientation() {
	        let { game } = this;
	        // The player is spawned at the last start pad in the mission file.
	        let startPad = Util$1.findLast(game.shapes, (shape) => shape instanceof StartPad$1);
	        let position;
	        let euler = new Euler$1();
	        if (startPad) {
	            // If there's a start pad, start there
	            position = startPad.worldPosition.clone().add(new Vector3$1(0, 0, 3));
	            euler.setFromQuaternion(startPad.worldOrientation, "ZXY");
	        }
	        else {
	            // Search for spawn points used for multiplayer
	            let spawnPoints = game.mission.allElements.find(x => x._name === "SpawnPoints");
	            if (spawnPoints) {
	                let first = spawnPoints.elements[0];
	                position = MisUtils.parseVector3(first.position);
	            }
	            else {
	                // If there isn't anything, start at this weird point
	                position = new Vector3$1(0, 0, 300);
	            }
	        }
	        return { position, euler };
	    }
	    stop() {
	        var _a, _b, _c, _d, _e;
	        (_a = this.rollingSound) === null || _a === void 0 ? void 0 : _a.stop();
	        (_b = this.slidingSound) === null || _b === void 0 ? void 0 : _b.stop();
	        (_c = this.helicopterSound) === null || _c === void 0 ? void 0 : _c.stop();
	        (_d = this.shockAbsorberSound) === null || _d === void 0 ? void 0 : _d.stop();
	        (_e = this.superBounceSound) === null || _e === void 0 ? void 0 : _e.stop();
	    }
	    dispose() {
	        var _a;
	        (_a = this.cubeMap) === null || _a === void 0 ? void 0 : _a.dispose();
	    }
	    beforeReconciliation() {
	        this.reconciliationPosition.copy(this.body.position);
	    }
	    afterReconciliation() {
	        let frames = this.game.state.frameGap * 2;
	        frames = Math.max(frames, 20); // 20 is totally fine as lower bound, still looks good
	        if (this.interpolationRemaining > frames)
	            return;
	        if (this.reconciliationPosition.distanceTo(this.body.position) === 0)
	            return;
	        this.interpolationRemaining = frames;
	        this.interpolationStrength = 1 - Math.pow(1 - 0.99, 1 / this.interpolationRemaining);
	    }
	    cancelInterpolation() {
	        this.interpolationRemaining = 0;
	        this.reconciliationPosition.copy(this.body.position);
	    }
	    static getPassiveControlState() {
	        return {
	            movement: new Vector2(),
	            yaw: DEFAULT_YAW,
	            pitch: DEFAULT_PITCH,
	            jumping: false,
	            using: false,
	            blasting: false
	        };
	    }
	}

	class Balloon extends Entity {
	    constructor(game, id) {
	        super(game);
	        this.id = id;
	        this.body = new RigidBody();
	        this.body.evaluationOrder = this.id;
	        this.body.gravity.set(0, 0, -5);
	        this.shape = new BallCollisionShape(1);
	        this.shape.mass = 0.2;
	        this.shape.restitution = 0.5;
	        this.body.addCollisionShape(this.shape);
	        let material = new Material$1();
	        material.transparent = true;
	        material.opacity = 0.75;
	        this.mesh = new Mesh$1(Geometry$1.createSphereGeometry(1, 64, 64), [material]);
	        game.renderer.scene.add(this.mesh);
	        game.simulator.world.add(this.body);
	        this.body.position.set(0, -13.5, 0);
	    }
	    async init() {
	        let tex = await ResourceManager$1.getTexture("interiors/edge_warm2.jpg");
	        this.mesh.materials[0].diffuseMap = tex;
	    }
	    update() {
	        this.stateNeedsStore = true;
	        this.body.angularVelocity.multiplyScalar(0.995);
	        for (let collision of this.body.collisions) {
	            let shapes = [collision.s1, collision.s2];
	            if (!shapes.includes(this.shape))
	                continue;
	            if (shapes[0] !== this.shape)
	                shapes.reverse();
	            if (!(shapes[1] instanceof BallCollisionShape))
	                continue;
	            if (!(shapes[1].body.userData instanceof Marble$1))
	                continue;
	            let marble = shapes[1].body.userData;
	            this.affect(marble);
	            marble.affect(this);
	        }
	    }
	    render() {
	        this.mesh.position.copy(this.body.position);
	        this.mesh.orientation.copy(this.body.orientation);
	        this.mesh.recomputeTransform();
	    }
	    getState() {
	        return {
	            entityType: 'balloon',
	            position: this.body.position.clone(),
	            orientation: this.body.orientation.clone(),
	            linearVelocity: this.body.linearVelocity.clone(),
	            angularVelocity: this.body.angularVelocity.clone()
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'balloon',
	            position: this.body.position.clone(),
	            orientation: this.body.orientation.clone(),
	            linearVelocity: this.body.linearVelocity.clone(),
	            angularVelocity: this.body.angularVelocity.clone()
	        };
	    }
	    loadState(state) {
	        this.body.position.fromObject(state.position);
	        this.body.orientation.fromObject(state.orientation);
	        this.body.linearVelocity.fromObject(state.linearVelocity);
	        this.body.angularVelocity.fromObject(state.angularVelocity);
	    }
	}
	//# sourceMappingURL=balloon.js.map

	const READY_TIME = 0.5;
	const SET_TIME = 2.0;
	const GO_TIME$1 = 3.5;
	class GameState {
	    constructor(game) {
	        this.id = 0;
	        this.frame = -1;
	        this.maxFrame = -1;
	        this.restartFrames = [];
	        this.subframeCompletion = 0;
	        this.stateHistory = new DefaultMap(() => []);
	        this.internalStateHistory = new DefaultMap(() => []);
	        this.affectionGraph = [];
	        this.nextUpdateId = 0;
	        this.nextAffectionEdgeId = 0;
	        this.game = game;
	    }
	    get lastRestartFrame() {
	        let restartFrame = -Infinity;
	        for (let i = 0; i < this.restartFrames.length; i++) {
	            if (this.restartFrames[i] > this.frame)
	                break;
	            restartFrame = this.restartFrames[i];
	        }
	        return restartFrame;
	    }
	    get time() {
	        return (this.frame + this.subframeCompletion) / GAME_UPDATE_RATE;
	    }
	    recordEntityInteraction(e1, e2) {
	        this.affectionGraph.push({
	            id: this.nextAffectionEdgeId++,
	            from: e1,
	            to: e2,
	            frame: this.frame
	        });
	        const propagate = (e) => {
	            let keepGoing = false;
	            for (let player of e1.affectedBy) {
	                if (!e.affectedBy.has(player)) {
	                    e.affectedBy.add(player);
	                    keepGoing = true;
	                }
	            }
	            if (keepGoing)
	                for (let edge of this.affectionGraph)
	                    if (edge.from === e)
	                        propagate(edge.to);
	        };
	        propagate(e2);
	    }
	    restart(frame) {
	        let { game } = this;
	        for (let entity of game.entities) {
	            if (!entity.restartable)
	                continue;
	            entity.restart(frame);
	        }
	        G$1.menu.finishScreen.hide();
	        if (!Util$1.isTouchDevice)
	            Util$1.requestPointerLock(); // Oof honestly I don't think this will trigger, maybe find a hack to trigger it through some custom event shit
	    }
	    saveStates() {
	        var _a, _b;
	        for (let i = 0; i < this.game.entities.length; i++) {
	            let entity = this.game.entities[i];
	            if (entity.stateNeedsStore) {
	                let arr = this.stateHistory.get(entity.id);
	                if (((_a = Util$1.last(arr)) === null || _a === void 0 ? void 0 : _a.frame) === this.frame)
	                    arr.pop();
	                let stateUpdate = {
	                    updateId: this.nextUpdateId++,
	                    entityId: entity.id,
	                    frame: this.frame,
	                    state: entity.getState()
	                };
	                arr.push(stateUpdate);
	                entity.stateNeedsStore = false;
	            }
	            if (entity.internalStateNeedsStore) {
	                let arr = this.internalStateHistory.get(entity.id);
	                if (((_b = Util$1.last(arr)) === null || _b === void 0 ? void 0 : _b.frame) === this.frame)
	                    arr.pop();
	                arr.push({
	                    frame: (arr.length === 0) ? -1 : this.frame,
	                    state: entity.getInternalState()
	                });
	                entity.internalStateNeedsStore = false;
	            }
	        }
	    }
	    getLastEntityUpdate(entity, upToFrame) {
	        let history = this.stateHistory.get(entity.id);
	        let update = history && Util$1.findLast(history, x => x.frame <= upToFrame);
	        if (!update)
	            update = this.createInitialUpdate(entity);
	        if (entity.restartable && update.frame < this.lastRestartFrame) {
	            update = this.createInitialUpdate(entity);
	            update.frame = this.lastRestartFrame;
	        }
	        return update;
	    }
	    rollBackToFrame(target) {
	        if (target === this.frame)
	            return;
	        this.frame = target;
	        while (this.affectionGraph.length > 0 && Util$1.last(this.affectionGraph).frame > target)
	            this.affectionGraph.pop();
	        let helpMessages = G$1.menu.hud.alerts;
	        while (helpMessages.length > 0 && Util$1.last(helpMessages).frame > target)
	            helpMessages.pop();
	        let alerts = G$1.menu.hud.alerts;
	        while (alerts.length > 0 && Util$1.last(alerts).frame > target)
	            alerts.pop();
	        for (let [entityId, history] of this.internalStateHistory) {
	            let popped = false;
	            while (history.length > 0 && Util$1.last(history).frame > target) {
	                history.pop();
	                popped = true;
	            }
	            if (!popped)
	                continue;
	            let entity = this.game.getEntityById(entityId);
	            let last = Util$1.last(history);
	            entity.loadInternalState(last.state, last.frame);
	        }
	        for (let [entityId] of this.stateHistory) {
	            this.rollBackEntityToFrame(this.game.getEntityById(entityId), target);
	        }
	        this.saveStates();
	    }
	    rollBackEntityToFrame(entity, frame) {
	        var _a;
	        let history = this.stateHistory.get(entity.id);
	        let popped = false;
	        while (Util$1.last(history) && Util$1.last(history).frame > frame) {
	            history.pop();
	            popped = true;
	        }
	        if (!popped)
	            return;
	        let update = this.getLastEntityUpdate(entity, frame);
	        let state = (_a = update.state) !== null && _a !== void 0 ? _a : entity.getInitialState();
	        if (!state)
	            return;
	        entity.loadState(state, {
	            frame: update.frame,
	            remote: false
	        });
	    }
	    createInitialUpdate(entity) {
	        return {
	            updateId: -1,
	            entityId: entity.id,
	            frame: 0,
	            state: null
	        };
	    }
	}
	//# sourceMappingURL=game_state.js.map

	const MAX_TIME = 999 * 60 + 59 + 0.999; // 999:59.99, should be large enough
	class Clock extends Entity {
	    constructor(game, id) {
	        super(game);
	        this.restartable = true;
	        this.time = 0;
	        this.elapsedTime = 0;
	        this.timeTravelBonus = 0;
	        this.updateOrder = -1;
	        this.timeTravelSound = null;
	        this.alarmSound = null;
	        this.id = id;
	    }
	    update() {
	        var _a, _b, _c;
	        this.advanceTime(this.game.state.frame);
	        this.internalStateNeedsStore = true;
	        if (this.game.simulator.isReconciling)
	            return;
	        let timeSinceRestart = (this.game.state.frame - this.game.state.lastRestartFrame) / GAME_UPDATE_RATE;
	        if (timeSinceRestart === READY_TIME)
	            AudioManager$1.play('ready.wav');
	        if (timeSinceRestart === SET_TIME)
	            AudioManager$1.play('set.wav');
	        if (timeSinceRestart === GO_TIME$1)
	            AudioManager$1.play('go.wav');
	        if (this.timeTravelBonus > 0 && !this.timeTravelSound && !this.game.finishState.finished) {
	            this.timeTravelSound = AudioManager$1.createAudioSource('timetravelactive.wav');
	            this.timeTravelSound.setLoop(true);
	            this.timeTravelSound.play();
	        }
	        else if (this.timeTravelBonus === 0 || this.game.finishState.finished) {
	            (_a = this.timeTravelSound) === null || _a === void 0 ? void 0 : _a.stop();
	            this.timeTravelSound = null;
	        }
	        // Handle alarm warnings (that the user is about to exceed the par time)
	        if (isFinite(this.game.mission.qualifyTime) && G$1.modification === 'platinum') {
	            let alarmStart = this.game.mission.computeAlarmStartTime();
	            if (this.time > 0 && 1000 * this.time >= alarmStart && !this.game.finishState.finished) {
	                if (1000 * this.time < this.game.mission.qualifyTime && !this.alarmSound) {
	                    // Start the alarm
	                    this.alarmSound = AudioManager$1.createAudioSource('alarm.wav');
	                    this.alarmSound.setLoop(true);
	                    this.alarmSound.play();
	                    G$1.menu.hud.displayHelp(() => `You have ${(this.game.mission.qualifyTime - alarmStart) / 1000} seconds remaining.`, this.game.state.frame, true);
	                }
	                if (1000 * this.time >= this.game.mission.qualifyTime && this.alarmSound) {
	                    // Stop the alarm
	                    (_b = this.alarmSound) === null || _b === void 0 ? void 0 : _b.stop();
	                    this.alarmSound = null;
	                    G$1.menu.hud.displayHelp(() => "The clock has passed the Par Time.", this.game.state.frame, true);
	                    AudioManager$1.play('alarm_timeout.wav');
	                }
	            }
	            else {
	                (_c = this.alarmSound) === null || _c === void 0 ? void 0 : _c.stop();
	                this.alarmSound = null;
	            }
	        }
	    }
	    advanceTime(currentFrame) {
	        if (this.game.state.lastRestartFrame === -Infinity || currentFrame - this.game.state.lastRestartFrame < GO_TIME$1 * GAME_UPDATE_RATE)
	            return;
	        if (this.timeTravelBonus > 0) {
	            // Subtract remaining time travel time
	            this.timeTravelBonus -= 1 / GAME_UPDATE_RATE;
	        }
	        else {
	            // Increase the gameplay time
	            this.time += 1 / GAME_UPDATE_RATE;
	        }
	        if (this.timeTravelBonus < 0) {
	            // If we slightly undershot the zero mark of the remaining time travel bonus, add the "lost time" back onto the gameplay clock:
	            this.time += -this.timeTravelBonus;
	            this.timeTravelBonus = 0;
	        }
	        this.elapsedTime += 1 / GAME_UPDATE_RATE; // Siempre
	    }
	    addTimeTravelBonus(bonus, timeToRevert) {
	        if (this.game.finishState.finished)
	            return;
	        if (this.timeTravelBonus === 0) {
	            this.time -= timeToRevert;
	            if (this.time < 0)
	                this.time = 0;
	            bonus -= timeToRevert;
	        }
	        this.timeTravelBonus += bonus;
	        if (this.timeTravelBonus < 0) {
	            this.time -= this.timeTravelBonus;
	            this.timeTravelBonus = 0;
	        }
	        this.stateNeedsStore = true;
	    }
	    render() {
	        var _a;
	        let timeToDisplay = (_a = this.game.finishState.time) !== null && _a !== void 0 ? _a : this.time; // fixme not visually smoothed
	        timeToDisplay = Math.min(timeToDisplay, MAX_TIME);
	        G$1.menu.hud.displayTime(timeToDisplay, this.determineClockColor(timeToDisplay));
	    }
	    determineClockColor(timeToDisplay) {
	        let { game } = this;
	        if (G$1.modification === 'gold')
	            return;
	        if (this.game.finishState.finished)
	            return 'green'; // Even if not qualified
	        if (this.time === 0 || game.clock.timeTravelBonus > 0)
	            return 'green';
	        if (1000 * timeToDisplay >= game.mission.qualifyTime)
	            return 'red';
	        if (isFinite(game.mission.qualifyTime) && G$1.modification === 'platinum') {
	            // Create the flashing effect
	            let alarmStart = game.mission.computeAlarmStartTime();
	            let elapsed = 1000 * timeToDisplay - alarmStart;
	            if (elapsed < 0)
	                return;
	            if (Math.floor(elapsed / 1000) % 2 === 0)
	                return 'red';
	        }
	        return; // Default yellow
	    }
	    getState() {
	        return {
	            entityType: 'clock',
	            time: this.time,
	            elapsedTime: this.elapsedTime,
	            timeTravelBonus: this.timeTravelBonus
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'clock',
	            time: 0,
	            elapsedTime: 0,
	            timeTravelBonus: 0
	        };
	    }
	    loadState(state, meta) {
	        this.time = state.time;
	        this.elapsedTime = state.elapsedTime;
	        this.timeTravelBonus = state.timeTravelBonus;
	        // Catch up to the now
	        for (let frame = meta.frame + 1; frame <= this.game.state.frame; frame++) {
	            this.advanceTime(frame);
	        }
	    }
	    getInternalState() {
	        return {
	            time: this.time,
	            elapsedTime: this.elapsedTime,
	            timeTravelBonus: this.timeTravelBonus
	        };
	    }
	    loadInternalState(state) {
	        this.time = state.time;
	        this.elapsedTime = state.elapsedTime;
	        this.timeTravelBonus = state.timeTravelBonus;
	    }
	    reset() { }
	    stop() { }
	}
	//# sourceMappingURL=clock.js.map

	/** The finish pad. */
	class EndPad$1 extends Shape$1 {
	    /** @param isMain Whether or not this pad is the main pad, meaning it has to be touched for the level to end. All other pads are purely cosmetic. */
	    constructor(isMain) {
	        super();
	        this.dtsPath = "shapes/pads/endarea.dts";
	        this.fireworks = [];
	        this.sounds = ['firewrks.wav'];
	        if (!isMain)
	            return;
	        // Create the finish area collision geometry
	        let height = 4.8;
	        let radius = 1.7;
	        let transform = new Matrix4();
	        transform.compose(new Vector3$1(0, 0, height / 2 + 0.2), new Quaternion$1().setFromEuler(new Euler$1(-Math.PI / 2, 0, 0)), new Vector3$1(1, 1, 1));
	        this.addCollider((scale) => {
	            // Create the finish area collision geometry
	            // Scaling note: The actual height of the cylinder (here: the y scaling) doesn't change, it's always the same.
	            let finishArea = Util$1.createCylinderConvexHull(radius, height / 2, 64, new Vector3$1(scale.x, 1, scale.y));
	            finishArea.margin = 0.005; // OIMO had a margin of 0.005 on every shape. We somewhat try to correct for that by adding it back here.
	            return finishArea;
	        }, transform, (t, dt, marble) => {
	            // These checks are to make sure touchFinish is only called once per contact with the collider. For it to be called again, the marble must leave the area again.
	            let exit = marble.endPadColliderTimeout > 0;
	            marble.endPadColliderTimeout = 2;
	            if (exit)
	                return;
	            this.game.finishState.tryFinish(marble, t);
	        });
	    }
	    /** Starts the finish celebration firework at a given time. */
	    spawnFirework() {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            let firework = new Firework(this.game, this.worldPosition, this.game.state.time);
	            this.fireworks.push(firework);
	            AudioManager$1.play(this.sounds[0]); // Play it for everyone!
	        }, `${this.id}firework`, true);
	    }
	    update(onlyVisual) {
	        if (onlyVisual)
	            return;
	        super.update(onlyVisual);
	        // Tick the firework
	        for (let firework of this.fireworks.slice()) {
	            firework.tick(this.game.state.time);
	            if (this.game.state.time - firework.spawnTime >= 10)
	                Util$1.removeFromArray(this.fireworks, firework); // We can safely remove the firework
	        }
	    }
	}
	/** The ambient smoke coming up from the finish pad. */
	const fireworkSmoke = {
	    ejectionPeriod: 100,
	    ambientVelocity: new Vector3$1(0, 0, 1),
	    ejectionVelocity: 0,
	    velocityVariance: 0,
	    emitterLifetime: 4000,
	    spawnOffset() {
	        let randomPointInCircle = Util$1.randomPointInUnitCircle();
	        return new Vector3$1(randomPointInCircle.x * 1.6, randomPointInCircle.y * 1.6, Math.random() * 0.4 - 0.5);
	    },
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/saturn.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 0,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 2000,
	        lifetimeVariance: 200,
	        dragCoefficient: 0.5,
	        acceleration: 0,
	        colors: [{ r: 1, g: 1, b: 0, a: 0 }, { r: 1, g: 0, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 0 }],
	        sizes: [0.1, 0.2, 0.3],
	        times: [0, 0.2, 1]
	    }
	};
	/** The trail of the red rockets. */
	const redTrail = {
	    ejectionPeriod: 30,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 0,
	    velocityVariance: 0,
	    emitterLifetime: 10000,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 0,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 600,
	        lifetimeVariance: 100,
	        dragCoefficient: 0,
	        acceleration: 0,
	        colors: [{ r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 0 }],
	        sizes: [0.1, 0.05, 0.01],
	        times: [0, 0.5, 1]
	    }
	};
	/** The trail of the blue rockets. */
	const blueTrail = {
	    ejectionPeriod: 30,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 0,
	    velocityVariance: 0,
	    emitterLifetime: 10000,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 0,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 600,
	        lifetimeVariance: 100,
	        dragCoefficient: 0,
	        acceleration: 0,
	        colors: [{ r: 0, g: 0, b: 1, a: 1 }, { r: 0.5, g: 0.5, b: 1, a: 1 }, { r: 1, g: 1, b: 1, a: 0 }],
	        sizes: [0.1, 0.05, 0.01],
	        times: [0, 0.5, 1]
	    }
	};
	/** The explosion effect of the red rockets. */
	const redSpark = {
	    ejectionPeriod: 1,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 0.8,
	    velocityVariance: 0.25,
	    emitterLifetime: 10,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/star.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 500,
	        lifetimeVariance: 50,
	        dragCoefficient: 0.5,
	        acceleration: 0,
	        colors: [{ r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 1, b: 0, a: 1 }, { r: 1, g: 0, b: 0, a: 0 }],
	        sizes: [0.2, 0.2, 0.2],
	        times: [0, 0.5, 1]
	    }
	};
	/** The explosion effect of the blue rockets. */
	const blueSpark = {
	    ejectionPeriod: 1,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 0.5,
	    velocityVariance: 0.25,
	    emitterLifetime: 10,
	    inheritedVelFactor: 0,
	    particleOptions: {
	        texture: 'particles/bubble.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 2000,
	        lifetimeVariance: 200,
	        dragCoefficient: 0,
	        acceleration: 0,
	        colors: [{ r: 0, g: 0, b: 1, a: 1 }, { r: 0.5, g: 0.5, b: 1, a: 1 }, { r: 1, g: 1, b: 1, a: 0 }],
	        sizes: [0.2, 0.2, 0.2],
	        times: [0, 0.5, 1]
	    }
	};
	/** Handles the firework animation that plays on the finish pad upon level completion. */
	class Firework extends Scheduler$1 {
	    constructor(game, pos, spawnTime) {
	        super();
	        this.trails = [];
	        /** The fireworks are spawned in waves, this controls how many are left. */
	        this.wavesLeft = 4;
	        this.particleManager = game.renderer.particles;
	        this.pos = pos;
	        this.spawnTime = spawnTime;
	        this.particleManager.createEmitter(fireworkSmoke, this.pos); // Start the smoke
	        this.doWave(this.spawnTime); // Start the first wave
	    }
	    tick(time) {
	        this.tickSchedule(time);
	        // Update the trails
	        for (let trail of this.trails.slice()) {
	            let completion = Util$1.clamp((time - trail.spawnTime) / trail.lifetime, 0, 1);
	            completion = 1 - (1 - completion) ** 2; // ease-out
	            // Make the trail travel along an arc (parabola, whatever)
	            let pos = this.pos.clone().multiplyScalar(1 - completion).add(trail.targetPos.clone().multiplyScalar(completion));
	            pos.sub(new Vector3$1(0, 0, 1).multiplyScalar(completion ** 2));
	            trail.smokeEmitter.setPos(pos, time);
	            if (completion === 1) {
	                // The trail has reached its end, remove the emitter and spawn the explosion.
	                this.particleManager.removeEmitter(trail.smokeEmitter);
	                Util$1.removeFromArray(this.trails, trail);
	                this.particleManager.createEmitter(trail.type === 'red' ? redSpark : blueSpark, pos);
	            }
	        }
	    }
	    /** Spawns a bunch of trails going in random directions. */
	    doWave(time) {
	        let count = Math.floor(17 + Math.random() * 10);
	        for (let i = 0; i < count; i++)
	            this.spawnTrail(time);
	        this.wavesLeft--;
	        if (this.wavesLeft > 0) {
	            let nextWaveTime = time + 0.5 + 1 * Math.random();
	            this.schedule(nextWaveTime, () => this.doWave(nextWaveTime));
	        }
	    }
	    /** Spawns a red or blue trail going in a random direction with a random speed. */
	    spawnTrail(time) {
	        let type = (Math.random() < 0.5) ? 'red' : 'blue';
	        let lifetime = 0.25 + 2 * Math.random();
	        let distanceFac = 0.5 + lifetime / 5; // Make sure the firework doesn't travel a great distance way too quickly
	        let emitter = this.particleManager.createEmitter(type === 'red' ? redTrail : blueTrail, this.pos);
	        let randomPointInCircle = Util$1.randomPointInUnitCircle();
	        let targetPos = new Vector3$1(randomPointInCircle.x * 3, randomPointInCircle.y * 3, 1 + Math.sqrt(Math.random()) * 3).multiplyScalar(distanceFac).add(this.pos);
	        let trail = {
	            type: type,
	            smokeEmitter: emitter,
	            targetPos: targetPos,
	            spawnTime: time,
	            lifetime: lifetime
	        };
	        this.trails.push(trail);
	    }
	}

	class FinishState extends Entity {
	    constructor(game, id) {
	        super(game);
	        this.restartable = true;
	        this.finished = false;
	        this.frame = null;
	        this.time = null;
	        this.elapsedTime = null;
	        this.isLegal = true;
	        this.id = id;
	    }
	    tryFinish(marble, t = 1) {
	        if (this.finished)
	            return;
	        let endPad = Util$1.findLast(this.game.shapes, (shape) => shape instanceof EndPad$1);
	        let gemCount = this.game.shapes.filter(x => x instanceof Gem$1 && x.pickedUpBy).length;
	        if (gemCount < this.game.totalGems) {
	            this.game.simulator.executeNonDuplicatableEvent(() => {
	                AudioManager$1.play('missinggems.wav', undefined, undefined, endPad === null || endPad === void 0 ? void 0 : endPad.worldPosition);
	            }, `${this.id}sound`, true);
	            G$1.menu.hud.displayAlert(() => {
	                if (this.game.localPlayer.controlledMarble !== marble)
	                    return null;
	                return (G$1.modification === 'gold') ? "You can't finish without all the gems!!" : "You may not finish without all the diamonds!";
	            }, this.game.state.frame);
	        }
	        else {
	            // Check if the player is OOB, but still allow finishing with less than half a second of having been OOB
	            let finishIsLegal = marble.outOfBoundsFrame === null || this.game.state.frame - marble.outOfBoundsFrame < 0.5 * GAME_UPDATE_RATE;
	            let toSubtract = (1 - t) / GAME_UPDATE_RATE;
	            this.finished = true;
	            this.frame = this.game.state.frame;
	            this.time = Util$1.clamp(this.game.clock.time - toSubtract, 0, MAX_TIME);
	            this.elapsedTime = Util$1.clamp(this.game.clock.elapsedTime - toSubtract, 0, MAX_TIME);
	            this.isLegal = finishIsLegal;
	            this.stateNeedsStore = true;
	            marble.enableFinishState();
	            marble.affect(this);
	            this.affect(marble);
	            this.game.clock.affect(this);
	            this.affect(this.game.clock);
	            for (let gem of this.game.shapes.filter(x => x instanceof Gem$1)) {
	                gem.affect(this);
	                this.affect(gem); // Because we require the gem to be picked up for our state to be how it is
	            }
	            if (!finishIsLegal) {
	                // Todo: In multiplayer, if the game doesn't restart automatically, the players should be able to pause and restart. Pause usually doesn't work tho when the finish state is set
	                this.playCosmeticEffects(endPad);
	                return;
	            }
	            // When we reach this point, the level has been completed successfully.
	            if (this.game.type === 'singleplayer')
	                this.finish(endPad);
	            else
	                this.requireServerConfirmation = true; // Do not predict finishing for multiplayer games
	        }
	    }
	    finish(endPad) {
	        this.playCosmeticEffects(endPad);
	        for (let marble of this.game.marbles) {
	            marble.enableFinishState();
	            this.affect(marble);
	        }
	        // Schedule the finish screen to be shown
	        G$1.menu.finishScreen.schedule();
	        G$1.menu.pauseScreen.hide(); // Just to be sure
	    }
	    playCosmeticEffects(endPad) {
	        endPad === null || endPad === void 0 ? void 0 : endPad.spawnFirework(); // EndPad *might* not exist, in that case no fireworks lol
	        G$1.menu.hud.displayAlert(() => "Congratulations! You've finished!", this.game.state.frame);
	    }
	    getState() {
	        return {
	            entityType: 'finishState',
	            frame: this.frame,
	            time: this.time,
	            elapsedTime: this.elapsedTime,
	            isLegal: this.isLegal
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'finishState',
	            frame: null,
	            time: null,
	            elapsedTime: null,
	            isLegal: true
	        };
	    }
	    loadState(state, { remote }) {
	        this.finished = state.frame !== null;
	        this.frame = state.frame;
	        this.time = state.time;
	        this.elapsedTime = state.elapsedTime;
	        this.isLegal = state.isLegal;
	        if (remote && this.finished && this.isLegal) {
	            let endPad = Util$1.findLast(this.game.shapes, (shape) => shape instanceof EndPad$1);
	            this.finish(endPad);
	        }
	    }
	    update() { }
	    render() { }
	}
	//# sourceMappingURL=finish_state.js.map

	/** A trigger is a cuboid-shaped area whose overlap with the marble causes certain events to happen. */
	class Trigger extends Entity {
	    constructor(element, game) {
	        super(game);
	        this.sounds = [];
	        this.currentlyColliding = new Set();
	        this.id = element._id;
	        this.element = element;
	        this.game = game;
	        // Parse the "polyhedron"
	        let coordinates = MisUtils.parseNumberList(element.polyhedron);
	        let origin = new Vector3$1(coordinates[0], coordinates[1], coordinates[2]);
	        let d1 = new Vector3$1(coordinates[3], coordinates[4], coordinates[5]);
	        let d2 = new Vector3$1(coordinates[6], coordinates[7], coordinates[8]);
	        let d3 = new Vector3$1(coordinates[9], coordinates[10], coordinates[11]);
	        // Create the 8 points of the parallelepiped
	        let p1 = origin.clone();
	        let p2 = origin.clone().add(d1);
	        let p3 = origin.clone().add(d2);
	        let p4 = origin.clone().add(d3);
	        let p5 = origin.clone().add(d1).add(d2);
	        let p6 = origin.clone().add(d1).add(d3);
	        let p7 = origin.clone().add(d2).add(d3);
	        let p8 = origin.clone().add(d1).add(d2).add(d3);
	        let mat = new Matrix4();
	        mat.compose(MisUtils.parseVector3(element.position), MisUtils.parseRotation(element.rotation), MisUtils.parseVector3(element.scale));
	        // Apply the transformation matrix to each vertex
	        let vertices = [p1, p2, p3, p4, p5, p6, p7, p8].map(x => x.applyMatrix4(mat));
	        this.vertices = vertices;
	        // Triggers ignore the actual shape of the polyhedron and simply use its AABB.
	        let aabb = new Box3().setFromPoints(vertices);
	        let aabbVertices = Util$1.getBoxVertices(aabb);
	        // Create the collision geometry
	        let ownShape = new ConvexHullCollisionShape(aabbVertices);
	        ownShape.collisionDetectionMask = 0b100; // Collide with the small aux marble
	        let body = new RigidBody();
	        body.type = RigidBodyType.Static;
	        body.evaluationOrder = this.id;
	        body.addCollisionShape(ownShape);
	        this.body = body;
	        // Init collision handlers
	        body.onBeforeIntegrate = () => {
	            for (let body of this.currentlyColliding) {
	                if (!this.body.collisions.some(x => x.s1.body === body)) {
	                    this.currentlyColliding.delete(body);
	                    this.internalStateNeedsStore = true;
	                    let marble = body.userData;
	                    this.onMarbleLeave(marble);
	                }
	            }
	        };
	        body.onBeforeCollisionResponse = () => {
	            for (let collision of this.body.collisions) {
	                let marble = collision.s1.body.userData;
	                if (!this.currentlyColliding.has(collision.s1.body))
	                    this.onMarbleEnter(marble);
	                this.onMarbleInside(marble);
	                this.currentlyColliding.add(collision.s1.body);
	                this.internalStateNeedsStore = true;
	            }
	        };
	        this.reset();
	    }
	    async init() {
	        // Preload all sounds
	        for (let sound of this.sounds) {
	            await AudioManager$1.loadBuffer(sound);
	        }
	    }
	    reset() {
	        this.currentlyColliding.clear();
	    }
	    render() { }
	    stop() { }
	    getInternalState() {
	        return {
	            currentlyColliding: new Set(this.currentlyColliding)
	        };
	    }
	    loadInternalState(state) {
	        this.currentlyColliding = new Set(state.currentlyColliding);
	    }
	    onMarbleInside(marble) { }
	    onMarbleEnter(marble) { }
	    onMarbleLeave(marble) { }
	    update() { }
	}
	//# sourceMappingURL=trigger.js.map

	/** A must-change trigger controls the path of a pathed interior. */
	class MustChangeTrigger extends Trigger {
	    constructor(element, interior) {
	        super(element, interior.game);
	        this.interior = interior;
	    }
	    onMarbleEnter(marble) {
	        this.interior.setTargetTime(MisParser$1.parseNumber(this.element.targettime));
	        if (this.element.instant === "1") {
	            if (this.element.icontinuetottime && this.element.icontinuetottime !== "0") {
	                // Absolutely strange, and not sure if it's even a thing in MBG, but is implement nonetheless.
	                this.interior.currentTime = this.interior.targetTime;
	                this.interior.targetTime = MisParser$1.parseNumber(this.element.icontinuetottime);
	            }
	            else {
	                this.interior.changeTime = -Infinity; // "If instant is 1, the MP will warp to targetTime instantly."
	            }
	        }
	        marble.affect(this.interior);
	    }
	}
	//# sourceMappingURL=must_change_trigger.js.map

	let v1$3 = new Vector3$1();
	let m1$2 = new Matrix4();
	/** Represents a Torque 3D Pathed Interior moving along a set path. */
	class PathedInterior$1 extends Interior$1 {
	    constructor() {
	        super(...arguments);
	        this.restartable = true;
	        this.triggers = [];
	        /** The source time (internal) */
	        this.currentTime = 0;
	        /** The destination time (internal) */
	        this.targetTime = 0;
	        /** The start reference point in time (external) of interior interpolation */
	        this.changeTime = 0;
	        this.prevPosition = new Vector3$1();
	        this.currentPosition = new Vector3$1();
	        this.allowSpecialMaterials = false; // Frictions don't work on pathed interiors
	    }
	    /** Creates a PathedInterior from a sim group containing it and its path (and possible triggers). */
	    static async createFromSimGroup(simGroup, game) {
	        let interiorElement = simGroup.elements.find((element) => element._type === MissionElementType$1.PathedInterior);
	        let { dif: difFile, path } = await game.mission.getDif(interiorElement.interiorresource);
	        if (!difFile)
	            return null;
	        let pathedInterior = new PathedInterior$1(difFile, path, game, MisParser$1.parseNumber(interiorElement.interiorindex));
	        pathedInterior.simGroup = simGroup;
	        pathedInterior.element = interiorElement;
	        game.interiors.push(pathedInterior);
	        await Util$1.wait(10); // See shapes for the meaning of this hack
	        await pathedInterior.init(interiorElement._id);
	        return pathedInterior;
	    }
	    async init(id) {
	        var _a;
	        await super.init(id);
	        // Pathed interiors ignore the normal position, rotation, scale and use the base- variants instead.
	        this.basePosition = MisUtils.parseVector3(this.element.baseposition);
	        this.baseOrientation = MisUtils.parseRotation(this.element.baserotation);
	        this.baseScale = MisUtils.parseVector3(this.element.basescale);
	        this.hasCollision = this.baseScale.x !== 0 && this.baseScale.y !== 0 && this.baseScale.z !== 0; // Don't want to add buggy geometry
	        // Fix zero-volume interiors so they receive correct lighting
	        if (this.baseScale.x === 0)
	            this.baseScale.x = 0.0001;
	        if (this.baseScale.y === 0)
	            this.baseScale.y = 0.0001;
	        if (this.baseScale.z === 0)
	            this.baseScale.z = 0.0001;
	        this.body.onBeforeIntegrate = this.onBeforeIntegrate.bind(this);
	        this.body.orientation.copy(this.baseOrientation);
	        // Add collision geometry
	        for (let i = 0; i < this.detailLevel.convexHulls.length; i++)
	            this.addConvexHull(i, this.baseScale);
	        // Parse the markers
	        this.path = this.simGroup.elements.find((element) => element._type === MissionElementType$1.Path);
	        this.markerData = this.path.markers.map(x => {
	            return {
	                msToNext: MisParser$1.parseNumber(x.mstonext),
	                smoothingType: x.smoothingtype,
	                position: MisUtils.parseVector3(x.position),
	                rotation: MisUtils.parseRotation(x.rotation)
	            };
	        });
	        if (MisParser$1.parseBoolean(this.path.isLooping))
	            this.markerData.push(this.markerData[0]); // In this case, we wrap around the marker list smoothly. Emulate this by copying the start to the end.
	        this.computeDuration();
	        // Add MustChangeTriggers if necessary
	        let triggers = this.simGroup.elements.filter((element) => element._type === MissionElementType$1.Trigger);
	        for (let triggerElement of triggers) {
	            if (!triggerElement.targettime)
	                continue; // Not a pathed interior trigger
	            let trigger = new MustChangeTrigger(triggerElement, this);
	            this.triggers.push(trigger);
	        }
	        // Create a sound effect if so specified
	        if (((_a = this.element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'pathedmovingblock') {
	            this.soundPosition = new Vector3$1(); // This position will be modified
	            this.soundSource = AudioManager$1.createAudioSource('movingblockloop.wav', AudioManager$1.soundGain, this.soundPosition);
	            this.soundSource.setLoop(true);
	            await this.soundSource.promise;
	        }
	        this.reset();
	    }
	    async onLevelStart() {
	        var _a;
	        (_a = this.soundSource) === null || _a === void 0 ? void 0 : _a.play();
	    }
	    /** Computes the total duration of the path. */
	    computeDuration() {
	        let total = 0;
	        // Don't count the last marker
	        for (let i = 0; i < this.markerData.length - 1; i++) {
	            total += this.markerData[i].msToNext;
	        }
	        this.duration = total;
	    }
	    setTargetTime(target) {
	        let currentInternalTime = this.getInternalTime(this.game.state.time);
	        this.currentTime = currentInternalTime; // Start where the interior currently is
	        this.targetTime = target;
	        this.changeTime = 1000 * this.game.state.time;
	        this.stateNeedsStore = true;
	    }
	    /** Gets the internal time along the path. Is guaranteed to be in [0, duration]. */
	    getInternalTime(externalTime) {
	        externalTime *= 1000;
	        if (this.targetTime < 0) {
	            let direction = (this.targetTime === -1) ? 1 : (this.targetTime === -2) ? -1 : 0;
	            return Util$1.adjustedMod(this.currentTime + (externalTime - this.changeTime) * direction, this.duration);
	        }
	        else {
	            let dur = Math.abs(this.currentTime - this.targetTime);
	            let completion = Util$1.clamp(dur ? (externalTime - this.changeTime) / dur : 1, 0, 1);
	            return Util$1.clamp(Util$1.lerp(this.currentTime, this.targetTime, completion), 0, this.duration);
	        }
	    }
	    update() {
	        var _a, _b, _c;
	        this.body.position.copy(this.currentPosition); // Reset it back to where it should be (render loop might've moved it)
	        let transform = this.getTransformAtTime(m1$2, this.getInternalTime(this.game.state.time));
	        this.prevPosition.copy(this.currentPosition);
	        this.currentPosition.setFromMatrixPosition(transform); // The orientation doesn't matter in that version of TGE, so we only need position
	        this.internalStateNeedsStore = true;
	        // Approximate the velocity numerically
	        let velocity = v1$3.copy(this.currentPosition).sub(this.prevPosition).multiplyScalar(GAME_UPDATE_RATE);
	        this.body.linearVelocity.copy(velocity);
	        // Modify the sound effect position, if present
	        if (!this.game.simulator.isReconciling)
	            (_a = this.soundPosition) === null || _a === void 0 ? void 0 : _a.copy(this.currentPosition).add((_c = (_b = this.markerData[0]) === null || _b === void 0 ? void 0 : _b.position) !== null && _c !== void 0 ? _c : new Vector3$1());
	    }
	    onBeforeIntegrate() {
	        this.body.position.copy(this.currentPosition);
	        this.body.syncShapes();
	    }
	    /** Computes the transform of the interior at a point in time along the path. */
	    getTransformAtTime(dst, time) {
	        let m1 = this.markerData[0];
	        let m2 = this.markerData[1];
	        if (!m1) {
	            // Incase there are no markers at all
	            dst.compose(this.basePosition, this.baseOrientation, this.baseScale);
	            return dst;
	        }
	        // Find the two markers in question
	        let currentEndTime = m1.msToNext;
	        let i = 2;
	        while (currentEndTime < time && i < this.markerData.length) {
	            m1 = m2;
	            m2 = this.markerData[i++];
	            currentEndTime += m1.msToNext;
	        }
	        if (!m2)
	            m2 = m1;
	        let m1Time = currentEndTime - m1.msToNext;
	        let m2Time = currentEndTime;
	        let duration = m2Time - m1Time;
	        let position;
	        let completion = Util$1.clamp(duration ? (time - m1Time) / duration : 1, 0, 1);
	        if (m1.smoothingType === "Accelerate") {
	            // A simple easing function
	            completion = Math.sin(completion * Math.PI - (Math.PI / 2)) * 0.5 + 0.5;
	        }
	        else if (m1.smoothingType === "Spline") {
	            // Smooth the path like it's a Catmull-Rom spline.
	            let preStart = (i - 2) - 1;
	            let postEnd = (i - 1) + 1;
	            if (postEnd >= this.path.markers.length)
	                postEnd = 0;
	            if (preStart < 0)
	                preStart = this.path.markers.length - 1;
	            let p0 = this.markerData[preStart].position;
	            let p1 = m1.position;
	            let p2 = m2.position;
	            let p3 = this.markerData[postEnd].position;
	            position = v1$3;
	            position.x = Util$1.catmullRom(completion, p0.x, p1.x, p2.x, p3.x);
	            position.y = Util$1.catmullRom(completion, p0.y, p1.y, p2.y, p3.y);
	            position.z = Util$1.catmullRom(completion, p0.z, p1.z, p2.z, p3.z);
	        }
	        if (!position) {
	            let p1 = m1.position;
	            let p2 = m2.position;
	            position = v1$3.copy(p1).lerp(p2, completion);
	        }
	        // Offset by the position of the first marker
	        let firstPosition = this.markerData[0].position;
	        position.sub(firstPosition);
	        position.add(this.basePosition); // Add the base position
	        dst.compose(position, this.baseOrientation, this.baseScale);
	        return dst;
	    }
	    onMarbleContact(collision, dt, marble) {
	        super.onMarbleContact(collision, dt, marble);
	        this.affect(marble);
	    }
	    render() {
	        let transform = this.getTransformAtTime(m1$2, this.getInternalTime(this.game.state.time));
	        this.mesh.transform.copy(transform);
	        this.mesh.changedTransform();
	        // Set the position of the body as well for correct camera ray casting results
	        this.body.position.setFromMatrixPosition(transform);
	        this.body.syncShapes();
	    }
	    stop() {
	        var _a;
	        (_a = this.soundSource) === null || _a === void 0 ? void 0 : _a.stop();
	    }
	    getState() {
	        return {
	            entityType: 'pathedInterior',
	            currentTime: this.currentTime,
	            targetTime: this.targetTime
	        };
	    }
	    getInitialState() {
	        let currentTime = 0;
	        let targetTime = 0;
	        if (this.element.initialposition) {
	            currentTime = MisParser$1.parseNumber(this.element.initialposition);
	        }
	        if (this.element.initialtargetposition) {
	            targetTime = MisParser$1.parseNumber(this.element.initialtargetposition);
	            // Alright this is strange. In Torque, there are some FPS-dependent client/server desync issues that cause the interior to start at the end position whenever the initialTargetPosition is somewhere greater than 1 and, like, approximately below 50.
	            if (targetTime > 0 && targetTime < 50)
	                currentTime = this.duration;
	        }
	        return {
	            entityType: 'pathedInterior',
	            currentTime,
	            targetTime
	        };
	    }
	    loadState(state, { frame }) {
	        this.currentTime = state.currentTime;
	        this.targetTime = state.targetTime;
	        this.changeTime = 1000 * frame / GAME_UPDATE_RATE;
	        // Set the position
	        let transform = this.getTransformAtTime(m1$2, this.getInternalTime(this.game.state.time));
	        this.currentPosition.setFromMatrixPosition(transform);
	    }
	    getInternalState() {
	        return {
	            prevPosition: this.prevPosition.clone(),
	            currentPosition: this.currentPosition.clone()
	        };
	    }
	    loadInternalState(state) {
	        this.prevPosition.copy(state.prevPosition);
	        this.currentPosition.copy(state.currentPosition);
	    }
	}
	//# sourceMappingURL=pathed_interior.js.map

	/** A checkpoint trigger sets the current checkpoint to an arbitrary shape in the level. */
	class CheckpointTrigger$1 extends Trigger {
	    constructor() {
	        super(...arguments);
	        this.sounds = ['checkpoint.wav'];
	    }
	    onMarbleEnter(marble) {
	        // Shape can be anything, doesn't necessarily have to be a checkpoint
	        let respawnShape = this.game.shapes.find(x => { var _a, _b; return ((_a = x.srcElement) === null || _a === void 0 ? void 0 : _a._name.toLowerCase()) === ((_b = this.element.respawnpoint) === null || _b === void 0 ? void 0 : _b.toLowerCase()); });
	        if (!respawnShape)
	            return;
	        marble.checkpointState.save(respawnShape, this);
	    }
	}
	//# sourceMappingURL=checkpoint_trigger.js.map

	/** Specifies the destination of a teleport. */
	class DestinationTrigger$1 extends Trigger {
	}
	//# sourceMappingURL=destination_trigger.js.map

	/** A help trigger displays an info message when the player touches one. */
	class HelpTrigger$1 extends Trigger {
	    constructor() {
	        super(...arguments);
	        this.sounds = ['infotutorial.wav'];
	    }
	    onMarbleEnter(marble) {
	        G$1.menu.hud.displayHelp(() => {
	            if (this.game.localPlayer !== marble.controllingPlayer)
	                return null;
	            return this.element.text;
	        }, this.game.state.frame);
	    }
	}
	//# sourceMappingURL=help_trigger.js.map

	/** An in-bounds trigger causes OOB on marble exit. */
	class InBoundsTrigger$1 extends Trigger {
	    onMarbleLeave(marble) {
	        marble.goOutOfBounds();
	    }
	}
	//# sourceMappingURL=in_bounds_trigger.js.map

	/** An out-of-bounds trigger causes OOB if the marble enters it. */
	class OutOfBoundsTrigger$1 extends Trigger {
	    onMarbleEnter(marble) {
	        marble.goOutOfBounds();
	    }
	}
	//# sourceMappingURL=out_of_bounds_trigger.js.map

	/*import { Interior } from "./interior";
	import { Marble } from "./marble";
	import { Shape, SharedShapeData } from "./shape";
	import { MissionElementSimGroup, MissionElementType, MissionElementStaticShape, MissionElementItem, MisParser, MissionElementTrigger, MissionElementInteriorInstance, MissionElementTSStatic, MissionElementParticleEmitterNode, MissionElementSky } from "../../shared/mis_parser";
	import { StartPad } from "./shapes/start_pad";
	import { SignFinish } from "./shapes/sign_finish";
	import { SignPlain } from "./shapes/sign_plain";
	import { EndPad, fireworkSmoke, redSpark, redTrail, blueSpark, blueTrail } from "./shapes/end_pad";
	import { Gem } from "./shapes/gem";
	import { SuperJump, superJumpParticleOptions } from "./shapes/super_jump";
	import { SignCaution } from "./shapes/sign_caution";
	import { SuperBounce } from "./shapes/super_bounce";
	import { RoundBumper } from "./shapes/round_bumper";
	import { Helicopter } from "./shapes/helicopter";
	import { DuctFan } from "./shapes/duct_fan";
	import { AntiGravity } from "./shapes/anti_gravity";
	import { LandMine, landMineSmokeParticle, landMineSparksParticle } from "./shapes/land_mine";
	import { ShockAbsorber } from "./shapes/shock_absorber";
	import { SuperSpeed, superSpeedParticleOptions } from "./shapes/super_speed";
	import { TimeTravel } from "./shapes/time_travel";
	import { Tornado } from "./shapes/tornado";
	import { TrapDoor } from "./shapes/trap_door";
	import { TriangleBumper } from "./shapes/triangle_bumper";
	import { Oilslick } from "./shapes/oilslick";
	import { Util, Scheduler } from "./util";
	import { PowerUp } from "./shapes/power_up";
	import { isPressed, releaseAllButtons, gamepadAxes, getPressedFlag, resetPressedFlag, hideTouchControls, maybeShowTouchControls, setTouchControlMode } from "./input";
	import { SmallDuctFan } from "./shapes/small_duct_fan";
	import { PathedInterior } from "./pathed_interior";
	import { Trigger } from "./triggers/trigger";
	import { InBoundsTrigger } from "./triggers/in_bounds_trigger";
	import { HelpTrigger } from "./triggers/help_trigger";
	import { OutOfBoundsTrigger } from "./triggers/out_of_bounds_trigger";
	import { ResourceManager } from "./resources";
	import { AudioManager, AudioSource } from "./audio";
	import { ParticleManager, ParticleEmitterOptions, particleNodeEmittersEmitterOptions, ParticleEmitter } from "./particles";
	import { StorageManager } from "./storage";
	import { Replay } from "./replay";
	import { Mission } from "./mission";
	import { PushButton } from "./shapes/push_button";
	import { DifFile } from "./parsing/dif_parser";
	import { G } from "./global";
	import { Sign } from "./shapes/sign";
	import { Magnet } from "./shapes/magnet";
	import { Nuke, nukeSmokeParticle, nukeSparksParticle } from "./shapes/nuke";
	import { TeleportTrigger } from "./triggers/teleport_trigger";
	import { DestinationTrigger } from "./triggers/destination_trigger";
	import { Checkpoint } from "./shapes/checkpoint";
	import { CheckpointTrigger } from "./triggers/checkpoint_trigger";
	import { EasterEgg } from "./shapes/easter_egg";
	import { RandomPowerUp } from "./shapes/random_power_up";
	import { MbpPauseScreen } from "./ui/pause_screen_mbp";
	import { MbpHud } from "./ui/hud_mbp";
	import { Sky } from "./shapes/sky";
	import { Glass } from "./shapes/glass";
	import { Blast } from "./shapes/blast";
	import { MegaMarble } from "./shapes/mega_marble";
	import { Scene } from "./rendering/scene";
	import { CubeTexture } from "./rendering/cube_texture";
	import { Material } from "./rendering/material";
	import { Mesh } from "./rendering/mesh";
	import { Geometry } from "./rendering/geometry";
	import { AmbientLight } from "./rendering/ambient_light";
	import { DirectionalLight } from "./rendering/directional_light";
	import { mainCanvas, mainRenderer, resize, SCALING_RATIO } from "./ui/misc";
	import { FRAME_RATE_OPTIONS } from "./ui/options_mbp";
	import { World } from "./physics/world";
	import { CollisionShape } from "./physics/collision_shape";
	import { Vector3 } from "./math/vector3";
	import { Quaternion } from "./math/quaternion";
	import { Euler } from "./math/euler";
	import { OrthographicCamera, PerspectiveCamera } from "./rendering/camera";
	import { Plane } from "./math/plane";
	import { gameServers } from "./net/game_server";
	import { GameServerCommands, GameServerMessage } from "../../shared/rtc";*/
	/** How often the physics will be updated, per second. */
	const PHYSICS_TICK_RATE$1 = 120;
	const PLAYBACK_SPEED = 1; // Major attack surface for cheaters here 😟
	/** The vertical offsets of overlay shapes to get them all visually centered. */
	const SHAPE_OVERLAY_OFFSETS = {
	    "shapes/images/helicopter.dts": -67,
	    "shapes/items/superjump.dts": -70,
	    "shapes/items/superbounce.dts": -55,
	    "shapes/items/superspeed.dts": -53,
	    "shapes/items/shockabsorber.dts": -53,
	    "shapes/items/megamarble.dts": -70,
	};
	const SHAPE_OVERLAY_SCALES = {
	    "shapes/items/megamarble.dts": 60,
	};
	/** Default camera pitch */
	const DEFAULT_PITCH$1 = 0.45;
	const BLAST_CHARGE_TIME$1 = 25000;
	const MAX_TIME$1 = 999 * 60 * 1000 + 59 * 1000 + 999; // 999:59.99, should be large enough
	const MBP_SONGS = ['astrolabe.ogg', 'endurance.ogg', 'flanked.ogg', 'grudge.ogg', 'mbp old shell.ogg', 'quiet lab.ogg', 'rising temper.ogg', 'seaside revisited.ogg', 'the race.ogg'];
	// Used for frame rate limiting working correctly
	const decoyCanvas = document.querySelector('#decoy-canvas');
	const decoyCtx = decoyCanvas.getContext('2d');
	/** The central control unit of gameplay. Handles loading, simulation and rendering. */
	class Level extends Scheduler {
	    constructor(mission) {
	        super();
	        this.marbles = [];
	        this.marblePool = [];
	        this.interiors = [];
	        this.sharedInteriorData = new Map();
	        this.triggers = [];
	        this.shapes = [];
	        /** Holds data shared between multiple shapes with the same constructor and .dts path. */
	        this.sharedShapeData = new Map();
	        /** The shapes used for drawing HUD overlay (powerups in the corner) */
	        this.overlayShapes = [];
	        /** The last performance.now() time the physics were ticked. */
	        this.lastPhysicsTick = null;
	        this.lastFrameTime = null;
	        this.started = false;
	        this.paused = true;
	        /** If the level is stopped, it shouldn't be used anymore. */
	        this.stopped = false;
	        /** The timestate at the moment of finishing. */
	        this.finishTime = null;
	        /** The maximum time that has been displayed in the current attempt. */
	        this.maxDisplayedTime = 0;
	        this.pitch = 0;
	        this.yaw = 0;
	        this.lastVerticalTranslation = new Vector3();
	        this.currentUp = new Vector3(0, 0, 1);
	        /** The last time the orientation was changed (by a gravity modifier) */
	        this.orientationChangeTime = -Infinity;
	        /** The old camera orientation quat */
	        this.oldOrientationQuat = new Quaternion();
	        /** The new target camera orientation quat  */
	        this.newOrientationQuat = new Quaternion();
	        /** See usage. */
	        this.previousMouseMovementDistance = 0;
	        this.defaultGravity = 20;
	        this.currentTimeTravelBonus = 0;
	        this.heldPowerUp = null;
	        this.totalGems = 0;
	        this.gemCount = 0;
	        this.blastAmount = 0;
	        this.outOfBounds = false;
	        /** When the jump button was pressed, remember that it was pressed until the next tick to execute the jump. */
	        this.jumpQueued = false;
	        this.useQueued = false;
	        this.blastQueued = false;
	        /** Whether or not the player is currently pressing the restart button. */
	        this.pressingRestart = false;
	        this.restartPressTime = null;
	        /** The time state at the last point the help text was updated. */
	        this.helpTextTimeState = null;
	        /** The time state at the last point the alert text was updated. */
	        this.alertTextTimeState = null;
	        /** Stores the shape that is the destination of the current checkpoint. */
	        this.currentCheckpoint = null;
	        /** If the checkpoint was triggered by a trigger, this field stores that trigger. */
	        this.currentCheckpointTrigger = null;
	        this.checkpointCollectedGems = new Set();
	        this.checkpointHeldPowerUp = null;
	        /** Up vector at the point of checkpointing */
	        this.checkpointUp = null;
	        this.checkpointBlast = null;
	        this.mission = mission;
	        this.loadingState = { loaded: 0, total: 0 };
	    }
	    /** Loads all necessary resources and builds the mission. */
	    async init() {
	        var _a;
	        // Scan the mission for elements to determine required loading effort
	        for (let element of this.mission.allElements) {
	            if ([MissionElementType.InteriorInstance, MissionElementType.Item, MissionElementType.PathedInterior, MissionElementType.StaticShape, MissionElementType.TSStatic].includes(element._type)) {
	                this.loadingState.total++;
	                // Override the end pad element. We do this because only the last finish pad element will actually do anything.
	                if (element._type === MissionElementType.StaticShape && ((_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'endpad')
	                    this.endPadElement = element;
	            }
	        }
	        this.loadingState.total += 6 + 1 + 3 + 6 + 1; // For the scene, marble, UI, sounds (includes music!), and scene compile
	        this.timeState = {
	            timeSinceLoad: -1000 / PHYSICS_TICK_RATE$1,
	            currentAttemptTime: 0,
	            gameplayClock: 0,
	            physicsTickCompletion: 0,
	            tickIndex: 0
	        };
	        // Apply overridden gravity
	        if (this.mission.misFile.marbleAttributes["gravity"] !== undefined) {
	            this.defaultGravity = MisParser.parseNumber(this.mission.misFile.marbleAttributes["gravity"]);
	        }
	        this.world = new World();
	        await this.initScene();
	        await this.initMarble();
	        this.loadingState.loaded += 1;
	        this.particles = new ParticleManager(this);
	        await this.particles.init(mainRenderer);
	        this.scene.particleManager = this.particles;
	        let soundPromise = this.initSounds();
	        await this.addSimGroup(this.mission.root);
	        await this.initUi();
	        this.loadingState.loaded += 3;
	        await soundPromise;
	        this.loadingState.loaded += 6;
	        this.scene.compile();
	        this.loadingState.loaded += 1;
	        this.replay = new Replay(this);
	    }
	    async start() {
	        if (this.stopped)
	            return;
	        this.started = true;
	        this.paused = false;
	        this.restart(true);
	        for (let interior of this.interiors)
	            await interior.onLevelStart();
	        for (let shape of this.shapes)
	            await shape.onLevelStart();
	        AudioManager.normalizePositionalAudioVolume();
	        resize(false); // To update renderer
	        mainCanvas.classList.remove('hidden');
	        this.updateCamera(this.timeState); // Ensure that the camera is positioned correctly before the first tick for correct positional audio playback
	        this.render(); // This will also do a tick
	        this.lastPhysicsTick = performance.now(); // First render usually takes quite long (shader compile etc), so reset the last physics tick back to now
	        this.tickInterval = setInterval(this.tick.bind(this));
	        this.music.play();
	        // Render them once
	        for (let shape of this.shapes)
	            if (shape.isTSStatic)
	                shape.render(this.timeState);
	        gameServers[0].connection.queueCommand('playMission', {
	            missionPath: this.mission.path
	        });
	    }
	    async initScene() {
	        this.scene = new Scene(mainRenderer);
	        let addedShadow = false;
	        // There could be multiple suns, so do it for all of them
	        for (let element of this.mission.allElements) {
	            if (element._type !== MissionElementType.Sun)
	                continue;
	            let directionalColor = MisParser.parseVector4(element.color);
	            let ambientColor = MisParser.parseVector4(element.ambient);
	            let sunDirection = MisParser.parseVector3(element.direction);
	            // Create the ambient light
	            this.scene.addAmbientLight(new AmbientLight(new Vector3(ambientColor.x, ambientColor.y, ambientColor.z)));
	            // Create the sunlight
	            let directionalLight = new DirectionalLight(mainRenderer, new Vector3(directionalColor.x, directionalColor.y, directionalColor.z), sunDirection.clone());
	            this.scene.addDirectionalLight(directionalLight);
	            if (!addedShadow) {
	                addedShadow = true;
	                let shadowCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 10);
	                directionalLight.enableShadowCasting(256, shadowCamera);
	            }
	        }
	        let skyElement = this.mission.allElements.find((element) => element._type === MissionElementType.Sky);
	        let fogColor = MisParser.parseVector4(skyElement.fogcolor);
	        // Uber strange way Torque maps these values:
	        if (fogColor.x > 1)
	            fogColor.x = 1 - (fogColor.x - 1) % 256 / 256;
	        if (fogColor.y > 1)
	            fogColor.y = 1 - (fogColor.y - 1) % 256 / 256;
	        if (fogColor.z > 1)
	            fogColor.z = 1 - (fogColor.z - 1) % 256 / 256;
	        let skySolidColor = MisParser.parseVector4(skyElement.skysolidcolor);
	        // This is kind of a weird situation here. It seems as if when the skysolidcolor isn't the default value, it's used as the skycolor; otherwise, fog color is used. Strange.
	        if (skySolidColor.x !== 0.6 || skySolidColor.y !== 0.6 || skySolidColor.z !== 0.6)
	            fogColor = skySolidColor;
	        mainRenderer.setClearColor(fogColor.x, fogColor.y, fogColor.z, 1);
	        this.camera = new PerspectiveCamera(StorageManager.data.settings.fov, window.innerWidth / window.innerHeight, 0.01, MisParser.parseNumber(skyElement.visibledistance));
	        if (skyElement.useskytextures === "1") {
	            // Create the skybox
	            let skyboxCubeTexture = await this.createSkyboxCubeTexture(skyElement.materiallist.slice(skyElement.materiallist.indexOf('data/') + 'data/'.length), true);
	            if (skyboxCubeTexture) {
	                let material = new Material();
	                material.isSky = true;
	                material.envMap = skyboxCubeTexture;
	                material.depthWrite = false;
	                material.renderOrder = -1000; // Render before everything else
	                let geometry = new Geometry();
	                geometry.positions.push(-1, -1, 0);
	                geometry.positions.push(3, -1, 0);
	                geometry.positions.push(-1, 3, 0);
	                geometry.materials.push(0, 0, 0);
	                geometry.indices.push(0, 1, 2);
	                geometry.fillRest();
	                let mesh = new Mesh(geometry, [material]);
	                this.scene.add(mesh);
	            }
	        }
	        let envmapCubeTexture = await this.createSkyboxCubeTexture('skies/sky_day.dml', false, 128); // Always the default MBG skybox
	        // Use the skybox as the environment map. Don't use the actual envmap image file because its projection requires like three PhDs in mathematics.
	        this.envMap = envmapCubeTexture;
	    }
	    async createSkyboxCubeTexture(dmlPath, increaseLoading, downsampleTo) {
	        let dmlDirectoryPath = dmlPath.slice(0, dmlPath.lastIndexOf('/'));
	        let dmlFile = await this.mission.getResource(dmlPath);
	        if (dmlFile) {
	            // Get all skybox images
	            let lines = (await ResourceManager.readBlobAsText(dmlFile)).split('\n').map(x => x.trim().toLowerCase());
	            let skyboxImages = [];
	            for (let i = 0; i < 6; i++) {
	                let line = lines[i];
	                let filename = this.mission.getFullNamesOf(dmlDirectoryPath + '/' + line)[0];
	                if (!filename) {
	                    skyboxImages.push(new Image());
	                }
	                else {
	                    let image = await this.mission.getImage(dmlDirectoryPath + '/' + filename);
	                    skyboxImages.push(image);
	                }
	                if (increaseLoading)
	                    this.loadingState.loaded++;
	            }
	            // Reorder them to the proper order
	            skyboxImages = Util.remapIndices(skyboxImages, [1, 3, 4, 5, 0, 2]);
	            if (downsampleTo)
	                skyboxImages = await Promise.all(skyboxImages.map(x => Util.downsampleImage(x, downsampleTo, downsampleTo)));
	            let skyboxTexture = new CubeTexture(mainRenderer, skyboxImages);
	            return skyboxTexture;
	        }
	        else {
	            if (increaseLoading)
	                this.loadingState.loaded += 6;
	            return null;
	        }
	    }
	    async initMarble() {
	        this.marble = new Marble(this);
	        this.marble.playerControlled = true;
	        await this.marble.init();
	        this.scene.add(this.marble.group);
	        this.world.add(this.marble.body);
	        this.marbles.push(this.marble);
	        for (let i = 0; i < 8; i++) {
	            let marble = new Marble(this);
	            await marble.init();
	            this.scene.add(marble.group);
	            marble.group.setOpacity(0);
	            this.marblePool.push(marble);
	        }
	        /*
	        for (let i = 0; i < 100; i++) {
	            let second = new Marble(this);
	            await second.init();

	            this.scene.add(second.group);
	            this.world.add(second.body);
	            this.marbles.push(second);

	            second.body.position.set(Math.random() * 5 - 2, Math.random() * 5 - 2 + 20, 510 + Math.random() * 20);
	            second.body.linearVelocity.randomDirection();
	            second.body.syncShapes();
	            second.group.position.copy(this.marble.body.position);
	            second.group.recomputeTransform();
	            second.reset();
	        }
	        */
	    }
	    async initUi() {
	        // Load all necessary UI image elements
	        await G.menu.hud.load();
	        // Set up the HUD overlay
	        let hudOverlayShapePaths = new Set();
	        for (let shape of this.shapes) {
	            if (shape instanceof PowerUp || shape instanceof Gem) {
	                if (shape instanceof PowerUp && shape.autoUse)
	                    continue; // Can't collect these aye
	                // We need to display the gem and powerup shapes in the HUD
	                if (shape instanceof RandomPowerUp) {
	                    for (let path of shape.getAllDtsPaths())
	                        hudOverlayShapePaths.add(path);
	                }
	                else {
	                    hudOverlayShapePaths.add(shape.dtsPath);
	                }
	            }
	        }
	        this.overlayScene = new Scene(mainRenderer);
	        let overlayLight = new AmbientLight(new Vector3().setScalar(1));
	        this.overlayScene.addAmbientLight(overlayLight);
	        this.overlayCamera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, -window.innerHeight / 2, window.innerHeight / 2, 1, 1000);
	        this.overlayCamera.up.set(0, 0, -1);
	        this.overlayCamera.lookAt(new Vector3(1, 0, 0));
	        for (let path of hudOverlayShapePaths) {
	            let shape = new Shape();
	            shape.dtsPath = path;
	            shape.ambientRotate = true;
	            shape.showSequences = false;
	            // MBP's UI gem color is randomized
	            if (path.includes("gem") && G.menu.hud instanceof MbpHud)
	                shape.matNamesOverride['base.gem'] = Gem.pickRandomColor() + '.gem';
	            await shape.init();
	            this.overlayShapes.push(shape);
	            this.overlayScene.add(shape.group);
	            if (path.includes("gem")) {
	                shape.ambientSpinFactor /= -2; // Gems spin the other way apparently
	            }
	            else {
	                shape.ambientSpinFactor /= 2;
	                shape.setOpacity(0);
	            }
	        }
	        if (this.totalGems > 0) {
	            // Show the gem overlay
	            G.menu.hud.setGemVisibility(true);
	        }
	        else {
	            // Hide the gem UI
	            G.menu.hud.setGemVisibility(false);
	        }
	        this.overlayScene.compile();
	        if (G.menu.pauseScreen instanceof MbpPauseScreen)
	            G.menu.pauseScreen.jukebox.reset();
	    }
	    async initSounds() {
	        let musicFileName;
	        if (this.mission.modification === 'ultra') {
	            musicFileName = 'tim trance.ogg'; // ALWAYS play this banger
	            this.originalMusicName = musicFileName;
	        }
	        else if (G.modification !== 'gold' && this.mission.missionInfo.music && this.mission.missionInfo.music.toLowerCase() !== 'pianoforte.ogg') {
	            musicFileName = this.mission.missionInfo.music.toLowerCase();
	            this.originalMusicName = musicFileName;
	        }
	        else {
	            if (this.mission.modification === 'gold') {
	                // Play the song based on the level index
	                let levelIndex = G.menu.levelSelect.currentMissionArray.indexOf(this.mission);
	                musicFileName = ['groovepolice.ogg', 'classic vibe.ogg', 'beach party.ogg'][(levelIndex + 1) % 3]; // The default music choice is based off of level index
	                // Yes, the extra space is intentional
	                this.originalMusicName = ['groove police.ogg', 'classic vibe.ogg', 'beach party.ogg'][(levelIndex + 1) % 3];
	            }
	            else {
	                // Play a random *MBP* song
	                musicFileName = Util.randomFromArray(MBP_SONGS);
	                this.originalMusicName = musicFileName;
	            }
	        }
	        if (G.modification === 'platinum')
	            musicFileName = 'music/' + musicFileName;
	        let toLoad = ["spawn.wav", "ready.wav", "set.wav", "go.wav", "whoosh.wav", musicFileName];
	        if (isFinite(this.mission.qualifyTime) && G.modification === 'platinum')
	            toLoad.push("alarm.wav", "alarm_timeout.wav", "infotutorial.wav");
	        try {
	            await AudioManager.loadBuffers(toLoad);
	        }
	        catch (e) {
	            // Something died, maybe it was the music, try replacing it with a song we know exists
	            let newMusic = Util.randomFromArray(MBP_SONGS);
	            this.originalMusicName = newMusic;
	            toLoad[toLoad.indexOf(musicFileName)] = 'music/' + newMusic;
	            musicFileName = 'music/' + newMusic;
	            await AudioManager.loadBuffers(toLoad);
	        }
	        this.music = AudioManager.createAudioSource(musicFileName, AudioManager.musicGain);
	        this.music.setLoop(true);
	        await this.music.promise;
	    }
	    /** Adds all elements within a sim group. */
	    async addSimGroup(simGroup) {
	        // Check if it's a pathed interior group
	        if (simGroup.elements.find((element) => element._type === MissionElementType.PathedInterior)) {
	            // Create the pathed interior
	            let pathedInterior = await PathedInterior.createFromSimGroup(simGroup, this);
	            if (!pathedInterior)
	                return;
	            this.scene.add(pathedInterior.mesh);
	            if (pathedInterior.hasCollision)
	                this.world.add(pathedInterior.body);
	            for (let trigger of pathedInterior.triggers) {
	                this.world.add(trigger.body);
	                this.triggers.push(trigger);
	            }
	            return;
	        }
	        let promises = [];
	        for (let element of simGroup.elements) {
	            switch (element._type) {
	                case MissionElementType.SimGroup:
	                    promises.push(this.addSimGroup(element));
	                    break;
	                case MissionElementType.InteriorInstance:
	                    promises.push(this.addInterior(element));
	                    break;
	                case MissionElementType.StaticShape:
	                case MissionElementType.Item:
	                    promises.push(this.addShape(element));
	                    break;
	                case MissionElementType.Trigger:
	                    promises.push(this.addTrigger(element));
	                    break;
	                case MissionElementType.TSStatic:
	                    promises.push(this.addTSStatic(element));
	                    break;
	                case MissionElementType.ParticleEmitterNode:
	                    this.addParticleEmitterNode(element);
	                    break;
	            }
	        }
	        await Promise.all(promises);
	    }
	    async addInterior(element) {
	        let { dif: difFile, path } = await this.mission.getDif(element.interiorfile);
	        if (!difFile)
	            return;
	        let interior = new Interior(difFile, path, this);
	        this.interiors.push(interior);
	        await Util.wait(10); // See shapes for the meaning of this hack
	        await interior.init(element._id);
	        this.scene.add(interior.mesh);
	        let interiorPosition = MisParser.parseVector3(element.position);
	        let interiorRotation = MisParser.parseRotation(element.rotation);
	        let interiorScale = MisParser.parseVector3(element.scale);
	        let hasCollision = interiorScale.x !== 0 && interiorScale.y !== 0 && interiorScale.z !== 0; // Don't want to add buggy geometry
	        // Fix zero-volume interiors so they receive correct lighting
	        if (interiorScale.x === 0)
	            interiorScale.x = 0.0001;
	        if (interiorScale.y === 0)
	            interiorScale.y = 0.0001;
	        if (interiorScale.z === 0)
	            interiorScale.z = 0.0001;
	        interior.setTransform(interiorPosition, interiorRotation, interiorScale);
	        if (hasCollision)
	            this.world.add(interior.body);
	    }
	    async addShape(element) {
	        var _a;
	        let shape;
	        // Add the correct shape based on type
	        let dataBlockLowerCase = (_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	        if (!dataBlockLowerCase) ;
	        else if (dataBlockLowerCase === "startpad")
	            shape = new StartPad();
	        else if (dataBlockLowerCase === "endpad")
	            shape = new EndPad(element === this.endPadElement);
	        else if (dataBlockLowerCase === "signfinish")
	            shape = new SignFinish();
	        else if (dataBlockLowerCase.startsWith("signplain"))
	            shape = new SignPlain(element);
	        else if (dataBlockLowerCase.startsWith("gemitem"))
	            shape = new Gem(element), this.totalGems++;
	        else if (dataBlockLowerCase === "superjumpitem")
	            shape = new SuperJump(element);
	        else if (dataBlockLowerCase.startsWith("signcaution"))
	            shape = new SignCaution(element);
	        else if (dataBlockLowerCase === "superbounceitem")
	            shape = new SuperBounce(element);
	        else if (dataBlockLowerCase === "roundbumper")
	            shape = new RoundBumper();
	        else if (dataBlockLowerCase === "trianglebumper")
	            shape = new TriangleBumper();
	        else if (dataBlockLowerCase === "helicopteritem")
	            shape = new Helicopter(element);
	        else if (dataBlockLowerCase === "ductfan")
	            shape = new DuctFan();
	        else if (dataBlockLowerCase === "smallductfan")
	            shape = new SmallDuctFan();
	        else if (dataBlockLowerCase === "antigravityitem")
	            shape = new AntiGravity(element);
	        else if (dataBlockLowerCase === "norespawnantigravityitem")
	            shape = new AntiGravity(element, true);
	        else if (dataBlockLowerCase === "landmine")
	            shape = new LandMine();
	        else if (dataBlockLowerCase === "shockabsorberitem")
	            shape = new ShockAbsorber(element);
	        else if (dataBlockLowerCase === "superspeeditem")
	            shape = new SuperSpeed(element);
	        else if (["timetravelitem", "timepenaltyitem"].includes(dataBlockLowerCase))
	            shape = new TimeTravel(element);
	        else if (dataBlockLowerCase === "tornado")
	            shape = new Tornado();
	        else if (dataBlockLowerCase === "trapdoor")
	            shape = new TrapDoor(element);
	        else if (dataBlockLowerCase === "oilslick")
	            shape = new Oilslick();
	        else if (dataBlockLowerCase === "pushbutton")
	            shape = new PushButton();
	        else if (dataBlockLowerCase.startsWith("sign") || dataBlockLowerCase === "arrow")
	            shape = new Sign(element);
	        else if (dataBlockLowerCase === "magnet")
	            shape = new Magnet();
	        else if (dataBlockLowerCase === "nuke")
	            shape = new Nuke();
	        else if (dataBlockLowerCase === "checkpoint")
	            shape = new Checkpoint();
	        else if (dataBlockLowerCase === "easteregg")
	            shape = new EasterEgg(element);
	        else if (dataBlockLowerCase === "randompowerupitem")
	            shape = new RandomPowerUp(element);
	        else if (["clear", "cloudy", "dusk", "wintry"].includes(dataBlockLowerCase))
	            shape = new Sky(dataBlockLowerCase);
	        else if (/glass_\d+shape/.test(dataBlockLowerCase))
	            shape = new Glass(dataBlockLowerCase);
	        else if (dataBlockLowerCase === "blastitem")
	            shape = new Blast(element);
	        else if (dataBlockLowerCase === "megamarbleitem")
	            shape = new MegaMarble(element);
	        if (!shape)
	            return;
	        this.shapes.push(shape);
	        // This is a bit hacky, but wait a short amount so that all shapes will have been created by the time this codepath continues. This is necessary for correct sharing of data between shapes.
	        await Util.wait(10);
	        await shape.init(this, element);
	        // Set the shape's transform
	        let shapePosition = MisParser.parseVector3(element.position);
	        let shapeRotation = MisParser.parseRotation(element.rotation);
	        let shapeScale = MisParser.parseVector3(element.scale);
	        // Apparently we still do collide with zero-volume shapes
	        if (shapeScale.x === 0)
	            shapeScale.x = 0.0001;
	        if (shapeScale.y === 0)
	            shapeScale.y = 0.0001;
	        if (shapeScale.z === 0)
	            shapeScale.z = 0.0001;
	        shape.setTransform(shapePosition, shapeRotation, shapeScale);
	        this.scene.add(shape.group);
	        for (let body of shape.bodies)
	            this.world.add(body);
	        for (let collider of shape.colliders)
	            this.world.add(collider.body);
	    }
	    async addTrigger(element) {
	        var _a;
	        let trigger;
	        // Create a trigger based on type
	        let dataBlockLowerCase = (_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	        if (dataBlockLowerCase === "outofboundstrigger") {
	            trigger = new OutOfBoundsTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "inboundstrigger") {
	            trigger = new InBoundsTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "helptrigger") {
	            trigger = new HelpTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "teleporttrigger") {
	            trigger = new TeleportTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "destinationtrigger") {
	            trigger = new DestinationTrigger(element, this);
	        }
	        else if (dataBlockLowerCase === "checkpointtrigger") {
	            trigger = new CheckpointTrigger(element, this);
	        }
	        if (!trigger)
	            return;
	        this.triggers.push(trigger);
	        this.world.add(trigger.body);
	        await trigger.init();
	    }
	    /** Adds a TSStatic (totally static shape) to the world. */
	    async addTSStatic(element) {
	        let shape = new Shape();
	        let shapeName = element.shapename.toLowerCase();
	        let index = shapeName.indexOf('data/');
	        if (index === -1)
	            return;
	        shape.dtsPath = shapeName.slice(index + 'data/'.length);
	        shape.isTSStatic = true;
	        shape.shareId = 1;
	        if (shapeName.includes('colmesh'))
	            shape.receiveShadows = false; // Special case for colmesh
	        this.shapes.push(shape);
	        await Util.wait(10); // Same hack as for regular shapes
	        try {
	            await shape.init(this, element);
	        }
	        catch (e) {
	            console.error("Error in creating TSStatic, skipping it for now.", e);
	            Util.removeFromArray(this.shapes, shape);
	            return;
	        }
	        shape.setTransform(MisParser.parseVector3(element.position), MisParser.parseRotation(element.rotation), MisParser.parseVector3(element.scale));
	        this.scene.add(shape.group);
	        if (shape.worldScale.x !== 0 && shape.worldScale.y !== 0 && shape.worldScale.z !== 0) {
	            // Only add the shape if it actually has any volume
	            for (let body of shape.bodies)
	                this.world.add(body);
	            for (let collider of shape.colliders)
	                this.world.add(collider.body);
	        }
	    }
	    /** Adds a ParticleEmitterNode to the world. */
	    addParticleEmitterNode(element) {
	        let emitterOptions = particleEmitterMap[element.emitter];
	        if (!emitterOptions)
	            return;
	        this.particles.createEmitter(emitterOptions, MisParser.parseVector3(element.position));
	    }
	    /** Restarts and resets the level. */
	    restart(forceHardRestart) {
	        var _a, _b;
	        if (!forceHardRestart && this.currentCheckpoint && this.replay.mode !== 'playback') {
	            // There's a checkpoint, so load its state instead of restarting the whole level
	            this.loadCheckpointState();
	            return;
	        }
	        let hud = G.menu.hud;
	        hud.setPowerupButtonState(false, true);
	        this.timeState.gameplayClock = 0;
	        if (this.replay && this.replay.version <= 4) {
	            // In older versions, the first tick would immediately advance the entire simulation to a non-zero time instead of correctly keeping it at 0 for a while.
	            this.timeState.currentAttemptTime = 0;
	            this.timeState.tickIndex = 0;
	        }
	        else {
	            // Both of these will become zero after the first tick:
	            this.timeState.currentAttemptTime = -1000 / PHYSICS_TICK_RATE$1;
	            this.timeState.tickIndex = -1;
	        }
	        this.currentTimeTravelBonus = 0;
	        this.outOfBounds = false;
	        this.lastPhysicsTick = null;
	        this.maxDisplayedTime = 0;
	        this.blastAmount = 0;
	        if (this.totalGems > 0) {
	            this.gemCount = 0;
	            hud.displayGemCount(this.gemCount, this.totalGems);
	        }
	        this.currentCheckpoint = null;
	        this.currentCheckpointTrigger = null;
	        this.checkpointCollectedGems.clear();
	        this.checkpointHeldPowerUp = null;
	        this.checkpointUp = null;
	        this.checkpointBlast = null;
	        this.restartPressTime = null;
	        this.finishTime = null;
	        let { position: startPosition, euler } = this.getStartPositionAndOrientation();
	        // Place the marble a bit above the start pad position
	        this.marble.body.position.set(startPosition.x, startPosition.y, startPosition.z + 3);
	        this.marble.body.syncShapes();
	        this.marble.group.position.copy(this.marble.body.position);
	        this.marble.group.recomputeTransform();
	        this.marble.reset();
	        this.marble.calculatePredictiveTransforms();
	        // Determine starting camera orientation based on the start pad
	        this.yaw = euler.z + Math.PI / 2;
	        this.pitch = DEFAULT_PITCH$1;
	        let missionInfo = this.mission.missionInfo;
	        if (missionInfo.starthelptext)
	            G.menu.hud.displayHelp(missionInfo.starthelptext); // Show the start help text
	        for (let shape of this.shapes)
	            shape.reset();
	        for (let interior of this.interiors)
	            interior.reset();
	        for (let trigger of this.triggers)
	            trigger.reset();
	        // Reset the physics
	        this.currentUp.set(0, 0, 1);
	        this.orientationChangeTime = -Infinity;
	        this.oldOrientationQuat = new Quaternion();
	        this.newOrientationQuat = new Quaternion();
	        this.setGravityIntensity(this.defaultGravity);
	        this.deselectPowerUp();
	        hud.setCenterText('none');
	        maybeShowTouchControls();
	        setTouchControlMode((this.replay.mode === 'playback') ? 'replay' : 'normal');
	        (_a = this.timeTravelSound) === null || _a === void 0 ? void 0 : _a.stop();
	        this.timeTravelSound = null;
	        (_b = this.alarmSound) === null || _b === void 0 ? void 0 : _b.stop();
	        this.alarmSound = null;
	        this.replay.init();
	        // Queue the ready-set-go events
	        AudioManager.play('spawn.wav');
	        this.clearSchedule();
	        this.schedule(500, () => {
	            hud.setCenterText('ready');
	            AudioManager.play('ready.wav');
	        });
	        this.schedule(2000, () => {
	            hud.setCenterText('set');
	            AudioManager.play('set.wav');
	        });
	        this.schedule(GO_TIME, () => {
	            hud.setCenterText('go');
	            AudioManager.play('go.wav');
	        });
	        this.schedule(5500, () => {
	            if (!this.outOfBounds)
	                hud.setCenterText('none');
	        });
	    }
	    render() {
	        var _a, _b, _c, _d, _e, _f;
	        if (this.stopped)
	            return;
	        requestAnimationFrame(this.render.bind(this));
	        let time = performance.now();
	        if (this.lastFrameTime === null) {
	            this.lastFrameTime = time;
	        }
	        else {
	            let cap = FRAME_RATE_OPTIONS[StorageManager.data.settings.frameRateCap];
	            // When FPS is unlocked in the browser but limited in-game, for some browser frames, the game won't draw anything. This makes the browser think it's okay to slow down the rate of requestAnimationFrame, which is not desirable in this case. Therefore we trick the browser into thinking the GPU is doing something by continuously clearing a 1x1 canvas each frame.
	            if (isFinite(cap))
	                decoyCtx.clearRect(0, 0, 1, 1);
	            // Take care of frame rate limiting:
	            let elapsed = time - this.lastFrameTime;
	            let required = 1000 / cap;
	            if (elapsed < required)
	                return;
	            this.lastFrameTime += required;
	            this.lastFrameTime = Math.max(this.lastFrameTime, time - 2 * required); // To avoid the last frame time from lagging behind
	        }
	        this.tick(time);
	        if (this.stopped)
	            return; // Check it again here 'cuz the tick might've changed it
	        let physicsTickLength = 1000 / PHYSICS_TICK_RATE$1;
	        let completion = Util.clamp((time - this.lastPhysicsTick) / physicsTickLength * PLAYBACK_SPEED, 0, 1);
	        // Set up an intermediate time state for smoother rendering
	        let tempTimeState = {
	            timeSinceLoad: this.timeState.timeSinceLoad + completion * physicsTickLength,
	            currentAttemptTime: this.timeState.currentAttemptTime + completion * physicsTickLength,
	            gameplayClock: (this.currentTimeTravelBonus || this.timeState.currentAttemptTime < GO_TIME) ? this.timeState.gameplayClock : this.timeState.gameplayClock + completion * physicsTickLength,
	            physicsTickCompletion: completion,
	            tickIndex: this.timeState.tickIndex + completion
	        };
	        for (let marble of this.marbles)
	            marble.render(tempTimeState);
	        for (let interior of this.interiors)
	            interior.render(tempTimeState);
	        for (let shape of this.shapes)
	            if (!shape.isTSStatic)
	                shape.render(tempTimeState);
	        this.particles.render(tempTimeState.timeSinceLoad);
	        this.updateCamera(tempTimeState);
	        this.camera.updateMatrixWorld();
	        // Update the shadow camera
	        (_a = this.scene.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.updateCamera(this.marble.group.position.clone(), -1);
	        // Render the scene
	        this.scene.prepareForRender(this.camera);
	        this.marble.renderReflection();
	        mainRenderer.render(this.scene, this.camera);
	        // Update the overlay
	        for (let overlayShape of this.overlayShapes) {
	            overlayShape.group.position.x = 500; // Make sure the shape is between the near and far planes of the camera
	            overlayShape.render(this.timeState);
	            if (overlayShape.dtsPath.includes("gem")) {
	                overlayShape.group.scale.setScalar(45 / SCALING_RATIO);
	                overlayShape.group.position.y = 25 / SCALING_RATIO;
	                overlayShape.group.position.z = -35 / SCALING_RATIO;
	            }
	            else {
	                overlayShape.group.scale.setScalar(((_b = SHAPE_OVERLAY_SCALES[overlayShape.dtsPath]) !== null && _b !== void 0 ? _b : 40) / SCALING_RATIO);
	                overlayShape.group.position.y = window.innerWidth - 55 / SCALING_RATIO;
	                overlayShape.group.position.z = SHAPE_OVERLAY_OFFSETS[overlayShape.dtsPath] / SCALING_RATIO;
	            }
	            overlayShape.group.recomputeTransform();
	        }
	        // Render the overlay
	        this.overlayCamera.updateMatrixWorld();
	        this.overlayScene.prepareForRender(this.overlayCamera);
	        mainRenderer.render(this.overlayScene, this.overlayCamera, null, false);
	        // This might seem a bit strange, but the time we display is actually a few milliseconds in the PAST (unless the user is currently in TT or has finished), for the reason that time was able to go backwards upon finishing or collecting TTs due to CCD time correction. That felt wrong, so we accept this inaccuracy in displaying time for now.
	        let timeToDisplay = tempTimeState.gameplayClock;
	        if (this.finishTime)
	            timeToDisplay = this.finishTime.gameplayClock;
	        if (this.currentTimeTravelBonus === 0 && !this.finishTime)
	            timeToDisplay = Math.max(timeToDisplay - 1000 / PHYSICS_TICK_RATE$1, 0);
	        this.maxDisplayedTime = Math.max(timeToDisplay, this.maxDisplayedTime);
	        if (this.currentTimeTravelBonus === 0 && !this.finishTime)
	            timeToDisplay = this.maxDisplayedTime;
	        timeToDisplay = Math.min(timeToDisplay, MAX_TIME$1);
	        let hud = G.menu.hud;
	        hud.displayTime(timeToDisplay / 1000, this.determineClockColor(timeToDisplay));
	        hud.displayBlastMeterFullness(this.blastAmount);
	        hud.displayFps();
	        // Update help and alert text visibility
	        let helpTextTime = (_d = (_c = this.helpTextTimeState) === null || _c === void 0 ? void 0 : _c.timeSinceLoad) !== null && _d !== void 0 ? _d : -Infinity;
	        let alertTextTime = (_f = (_e = this.alertTextTimeState) === null || _e === void 0 ? void 0 : _e.timeSinceLoad) !== null && _f !== void 0 ? _f : -Infinity;
	        let helpTextCompletion = Util.clamp((this.timeState.timeSinceLoad - helpTextTime - 3000) / 1000, 0, 1) ** 2;
	        let alertTextCompletion = Util.clamp((this.timeState.timeSinceLoad - alertTextTime - 3000) / 1000, 0, 1) ** 2;
	        hud.helpElement.style.opacity = (1 - helpTextCompletion).toString();
	        hud.helpElement.style.filter = `brightness(${Util.lerp(1, 0.25, helpTextCompletion)})`;
	        hud.alertElement.style.opacity = (1 - alertTextCompletion).toString();
	        hud.alertElement.style.filter = `brightness(${Util.lerp(1, 0.25, alertTextCompletion)})`;
	    }
	    determineClockColor(timeToDisplay) {
	        if (G.modification === 'gold')
	            return;
	        if (this.finishTime)
	            return 'green'; // Even if not qualified
	        if (this.timeState.currentAttemptTime < GO_TIME || this.currentTimeTravelBonus > 0)
	            return 'green';
	        if (timeToDisplay >= this.mission.qualifyTime)
	            return 'red';
	        if (this.timeState.currentAttemptTime >= GO_TIME && isFinite(this.mission.qualifyTime) && G.modification === 'platinum') {
	            // Create the flashing effect
	            let alarmStart = this.mission.computeAlarmStartTime();
	            let elapsed = timeToDisplay - alarmStart;
	            if (elapsed < 0)
	                return;
	            if (Math.floor(elapsed / 1000) % 2 === 0)
	                return 'red';
	        }
	        return; // Default yellow
	    }
	    /** Updates the position of the camera based on marble position and orientation. */
	    updateCamera(timeState) {
	        let marblePosition = this.marble.group.position;
	        let orientationQuat = this.getOrientationQuat(timeState);
	        let up = new Vector3(0, 0, 1).applyQuaternion(orientationQuat);
	        let directionVector = new Vector3(1, 0, 0);
	        // The camera is translated up a bit so it looks "over" the marble
	        let cameraVerticalTranslation = new Vector3(0, 0, 0.3);
	        if (this.replay.mode === 'playback') {
	            let indexLow = Math.max(0, this.replay.currentTickIndex - 1);
	            let indexHigh = this.replay.currentTickIndex;
	            // Smoothly interpolate pitch and yaw between the last two keyframes
	            this.pitch = Util.lerp(this.replay.cameraOrientations[indexLow].pitch, this.replay.cameraOrientations[indexHigh].pitch, timeState.physicsTickCompletion);
	            this.pitch = Math.max(-Math.PI / 2 + Math.PI / 4, Math.min(Math.PI / 2 - 0.0001, this.pitch)); // This bounds thing might have gotten inaccurate in the conversion from float64 to float32, so do it here again
	            this.yaw = Util.lerp(this.replay.cameraOrientations[indexLow].yaw, this.replay.cameraOrientations[indexHigh].yaw, timeState.physicsTickCompletion);
	        }
	        if (this.finishTime) {
	            // Make the camera spin around slowly
	            this.pitch = Util.lerp(this.finishPitch, DEFAULT_PITCH$1, Util.clamp((timeState.currentAttemptTime - this.finishTime.currentAttemptTime) / 333, 0, 1));
	            this.yaw = this.finishYaw - (timeState.currentAttemptTime - this.finishTime.currentAttemptTime) / 1000 * 0.6;
	        }
	        if (!this.outOfBounds) {
	            directionVector.applyAxisAngle(new Vector3(0, 1, 0), this.pitch);
	            directionVector.applyAxisAngle(new Vector3(0, 0, 1), this.yaw);
	            directionVector.applyQuaternion(orientationQuat);
	            cameraVerticalTranslation.applyAxisAngle(new Vector3(0, 1, 0), this.pitch);
	            cameraVerticalTranslation.applyAxisAngle(new Vector3(0, 0, 1), this.yaw);
	            cameraVerticalTranslation.applyQuaternion(orientationQuat);
	            this.camera.up = up;
	            this.camera.position.copy(marblePosition).sub(directionVector.clone().multiplyScalar(2.5));
	            this.camera.lookAt(marblePosition);
	            this.camera.position.add(cameraVerticalTranslation);
	            // Handle wall intersections:
	            const closeness = 0.1;
	            let rayCastOrigin = marblePosition;
	            let processedShapes = new Set();
	            for (let i = 0; i < 3; i++) {
	                // Shoot rays from the marble to the postiion of the camera
	                let rayCastDirection = this.camera.position.clone().sub(rayCastOrigin);
	                rayCastDirection.addScaledVector(rayCastDirection.clone().normalize(), 2);
	                let length = rayCastDirection.length();
	                let hits = this.world.castRay(rayCastOrigin, rayCastDirection.normalize(), length);
	                let firstHit = hits.find(x => x.shape !== this.marble.shape);
	                if (firstHit) {
	                    processedShapes.add(firstHit.shape);
	                    // Construct a plane at the point of ray impact based on the normal
	                    let plane = new Plane();
	                    let normal = firstHit.normal;
	                    let position = firstHit.point;
	                    plane.setFromNormalAndCoplanarPoint(normal, position);
	                    // Project the camera position onto the plane
	                    let target = new Vector3();
	                    let projected = plane.projectPoint(this.camera.position, target);
	                    // If the camera is too far from the plane anyway, break
	                    let dist = plane.distanceToPoint(this.camera.position);
	                    if (dist >= closeness)
	                        break;
	                    // Go the projected point and look at the marble
	                    this.camera.position.copy(projected.add(normal.multiplyScalar(closeness)));
	                    Util.cameraLookAtDirect(this.camera, marblePosition);
	                    let rotationAxis = new Vector3(1, 0, 0);
	                    rotationAxis.applyQuaternion(this.camera.orientation);
	                    let theta = Math.atan(0.3 / 2.5); // 0.3 is the vertical translation, 2.5 the distance away from the marble.
	                    // Rotate the camera back upwards such that the marble is in the same visual location on screen as before
	                    let rot = new Quaternion().setFromAxisAngle(rotationAxis, theta);
	                    this.camera.orientation.premultiply(rot);
	                    continue;
	                }
	                break;
	            }
	            this.lastVerticalTranslation = cameraVerticalTranslation;
	        }
	        else {
	            // Simply look at the marble
	            this.camera.position.copy(this.oobCameraPosition);
	            this.camera.position.sub(this.lastVerticalTranslation);
	            this.camera.lookAt(marblePosition);
	            this.camera.position.add(this.lastVerticalTranslation);
	        }
	    }
	    tick(time) {
	        var _a, _b;
	        if (this.stopped)
	            return;
	        //if (this.paused) return; // fixme
	        if (time === undefined)
	            time = performance.now();
	        let playReplay = this.replay.mode === 'playback';
	        if (!playReplay && !G.menu.finishScreen.showing && (isPressed('use') || this.useQueued) && getPressedFlag('use')) {
	            if (this.outOfBounds && !this.finishTime) {
	                // Skip the out of bounds "animation" and restart immediately
	                this.restart(false);
	                return;
	            }
	        }
	        G.menu.finishScreen.handleGamepadInput();
	        // Handle pressing of the gamepad pause button
	        if (isPressed('pause') && getPressedFlag('pause')) {
	            resetPressedFlag('pause');
	            resetPressedFlag('jump');
	            resetPressedFlag('use');
	            resetPressedFlag('restart');
	            this.pause();
	        }
	        if (this.lastPhysicsTick === null) {
	            // If there hasn't been a physics tick yet, ensure there is one now
	            this.lastPhysicsTick = time - 1000 / PHYSICS_TICK_RATE$1 * 1.1 / PLAYBACK_SPEED;
	        }
	        /** Time since the last physics tick */
	        let elapsed = time - this.lastPhysicsTick;
	        elapsed *= PLAYBACK_SPEED;
	        if (elapsed >= 1000) {
	            elapsed = 1000;
	            this.lastPhysicsTick = time - 1000;
	        }
	        let tickDone = false;
	        // Make sure to execute the correct amount of ticks
	        while (elapsed >= 1000 / PHYSICS_TICK_RATE$1) {
	            // Update gameplay clock, taking into account the Time Travel state
	            if (this.timeState.currentAttemptTime >= GO_TIME) {
	                if (this.currentTimeTravelBonus > 0) {
	                    // Subtract remaining time travel time
	                    this.currentTimeTravelBonus -= 1000 / PHYSICS_TICK_RATE$1;
	                    if (!this.timeTravelSound) {
	                        this.timeTravelSound = AudioManager.createAudioSource('timetravelactive.wav');
	                        this.timeTravelSound.setLoop(true);
	                        this.timeTravelSound.play();
	                    }
	                }
	                else {
	                    // Increase the gameplay time
	                    this.timeState.gameplayClock += 1000 / PHYSICS_TICK_RATE$1;
	                    (_a = this.timeTravelSound) === null || _a === void 0 ? void 0 : _a.stop();
	                    this.timeTravelSound = null;
	                }
	                if (this.currentTimeTravelBonus < 0) {
	                    // If we slightly undershot the zero mark of the remaining time travel bonus, add the "lost time" back onto the gameplay clock:
	                    this.timeState.gameplayClock += -this.currentTimeTravelBonus;
	                    this.currentTimeTravelBonus = 0;
	                }
	            }
	            this.timeState.timeSinceLoad += 1000 / PHYSICS_TICK_RATE$1;
	            this.timeState.currentAttemptTime += 1000 / PHYSICS_TICK_RATE$1;
	            this.timeState.tickIndex++;
	            this.lastPhysicsTick += 1000 / PHYSICS_TICK_RATE$1 / PLAYBACK_SPEED;
	            elapsed -= 1000 / PHYSICS_TICK_RATE$1;
	            let prevGameplayClock = this.timeState.gameplayClock;
	            this.tickSchedule(this.timeState.currentAttemptTime);
	            if (this.mission.hasBlast && this.blastAmount < 1)
	                this.blastAmount = Util.clamp(this.blastAmount + 1000 / BLAST_CHARGE_TIME$1 / PHYSICS_TICK_RATE$1, 0, 1);
	            for (let interior of this.interiors)
	                interior.tick(this.timeState);
	            for (let trigger of this.triggers)
	                trigger.tick(this.timeState);
	            for (let shape of this.shapes)
	                if (!shape.isTSStatic)
	                    shape.tick(this.timeState);
	            for (let marble of this.marbles)
	                marble.update();
	            if (!playReplay) {
	                let gravityBefore = this.world.gravity.clone();
	                if (this.finishTime)
	                    this.world.gravity.setScalar(0);
	                this.world.step(1 / PHYSICS_TICK_RATE$1);
	                this.world.gravity.copy(gravityBefore);
	            }
	            for (let marble of this.marbles)
	                marble.postStep();
	            this.jumpQueued = false;
	            this.useQueued = false;
	            this.blastQueued = false;
	            let yawChange = 0.0;
	            let pitchChange = 0.0;
	            let freeLook = StorageManager.data.settings.alwaysFreeLook || isPressed('freeLook');
	            let amount = Util.lerp(1, 6, StorageManager.data.settings.keyboardSensitivity);
	            if (isPressed('cameraLeft'))
	                yawChange += amount;
	            if (isPressed('cameraRight'))
	                yawChange -= amount;
	            if (isPressed('cameraUp'))
	                pitchChange -= amount;
	            if (isPressed('cameraDown'))
	                pitchChange += amount;
	            yawChange -= gamepadAxes.cameraX * Util.lerp(0.5, 10, StorageManager.data.settings.mouseSensitivity);
	            if (freeLook)
	                pitchChange += gamepadAxes.cameraY * Util.lerp(0.5, 10, StorageManager.data.settings.mouseSensitivity);
	            this.yaw += yawChange / PHYSICS_TICK_RATE$1;
	            this.pitch += pitchChange / PHYSICS_TICK_RATE$1;
	            this.particles.tick();
	            tickDone = true;
	            // Handle alarm warnings (that the user is about to exceed the par time)
	            if (this.timeState.currentAttemptTime >= GO_TIME && isFinite(this.mission.qualifyTime) && G.modification === 'platinum' && !this.finishTime) {
	                let alarmStart = this.mission.computeAlarmStartTime();
	                if (prevGameplayClock <= alarmStart && this.timeState.gameplayClock >= alarmStart && !this.alarmSound) {
	                    // Start the alarm
	                    this.alarmSound = AudioManager.createAudioSource('alarm.wav');
	                    this.alarmSound.setLoop(true);
	                    this.alarmSound.play();
	                    G.menu.hud.displayHelp(`You have ${(this.mission.qualifyTime - alarmStart) / 1000} seconds remaining.`, true);
	                }
	                if (prevGameplayClock < this.mission.qualifyTime && this.timeState.gameplayClock >= this.mission.qualifyTime) {
	                    // Stop the alarm
	                    (_b = this.alarmSound) === null || _b === void 0 ? void 0 : _b.stop();
	                    this.alarmSound = null;
	                    G.menu.hud.displayHelp("The clock has passed the Par Time.", true);
	                    AudioManager.play('alarm_timeout.wav');
	                }
	            }
	            // Record or playback the replay
	            if (!playReplay) {
	                this.replay.record();
	            }
	            else {
	                this.replay.playBack();
	                if (this.replay.isPlaybackComplete()) {
	                    this.stopAndExit();
	                    return;
	                }
	            }
	            this.queueStateUpdates();
	        }
	        AudioManager.updatePositionalAudio(this.timeState, this.camera.position, this.yaw);
	        this.pitch = Math.max(-Math.PI / 2 + Math.PI / 4, Math.min(Math.PI / 2 - 0.0001, this.pitch)); // The player can't look straight up
	        if (tickDone)
	            for (let marble of this.marbles)
	                marble.calculatePredictiveTransforms();
	        // Handle pressing of the restart button
	        if (!this.finishTime && isPressed('restart') && !this.pressingRestart) {
	            this.restart(false);
	            if (this.currentCheckpoint)
	                this.restartPressTime = performance.now();
	            this.pressingRestart = true;
	        }
	        else if (!isPressed('restart')) {
	            this.pressingRestart = false;
	        }
	        // Holding down the restart button for 1 second will force a hard restart
	        if (!this.finishTime && isPressed('restart') && this.restartPressTime !== null) {
	            if (this.restartPressTime !== null && performance.now() - this.restartPressTime >= 1000)
	                this.restart(true);
	        }
	    }
	    /** Get the current interpolated orientation quaternion. */
	    getOrientationQuat(time) {
	        let completion = Util.clamp((time.currentAttemptTime - this.orientationChangeTime) / 300, 0, 1);
	        return this.oldOrientationQuat.clone().slerp(this.newOrientationQuat, completion);
	    }
	    /** Sets the current up vector and gravity with it. */
	    setUp(newUp, instant = false) {
	        let time = this.timeState;
	        newUp.normalize(); // We never know 👀
	        this.currentUp.copy(newUp);
	        let gravityStrength = this.world.gravity.length();
	        this.world.gravity.copy(newUp).multiplyScalar(-1 * gravityStrength);
	        let currentQuat = this.getOrientationQuat(time);
	        let oldUp = new Vector3(0, 0, 1);
	        oldUp.applyQuaternion(currentQuat);
	        let quatChange = new Quaternion();
	        let dot = newUp.dot(oldUp);
	        if (dot <= -(1 - 1e-15) && !(this.replay.version < 3)) { // If the old and new up are exact opposites, there are infinitely many possible rotations we could do. So choose the one that maintains the current look vector the best. Replay check so we don't break old stuff.
	            let lookVector = new Vector3(0, 0, 1).applyQuaternion(this.camera.orientation);
	            let intermediateVector = oldUp.clone().cross(lookVector).normalize();
	            // First rotation to the intermediate vector, then rotate from there to the new up
	            quatChange.setFromUnitVectors(oldUp, intermediateVector);
	            quatChange.multiplyQuaternions(new Quaternion().setFromUnitVectors(intermediateVector, newUp), quatChange);
	        }
	        else {
	            // Instead of calculating the new quat from nothing, calculate it from the last one to guarantee the shortest possible rotation.
	            quatChange.setFromUnitVectors(oldUp, newUp);
	        }
	        this.newOrientationQuat = quatChange.multiply(currentQuat);
	        this.oldOrientationQuat = currentQuat;
	        this.orientationChangeTime = instant ? -Infinity : time.currentAttemptTime;
	    }
	    /** Gets the position and orientation of the player spawn point. */
	    getStartPositionAndOrientation() {
	        // The player is spawned at the last start pad in the mission file.
	        let startPad = Util.findLast(this.shapes, (shape) => shape instanceof StartPad);
	        let position;
	        let euler = new Euler();
	        if (startPad) {
	            // If there's a start pad, start there
	            position = startPad.worldPosition;
	            euler.setFromQuaternion(startPad.worldOrientation, "ZXY");
	        }
	        else {
	            // Search for spawn points used for multiplayer
	            let spawnPoints = this.mission.allElements.find(x => x._name === "SpawnPoints");
	            if (spawnPoints) {
	                let first = spawnPoints.elements[0];
	                position = MisParser.parseVector3(first.position);
	            }
	            else {
	                // If there isn't anything, start at this weird point
	                position = new Vector3(0, 0, 300);
	            }
	        }
	        return { position, euler };
	    }
	    setGravityIntensity(intensity) {
	        let gravityVector = this.currentUp.clone().multiplyScalar(-1 * intensity);
	        this.world.gravity.copy(gravityVector);
	    }
	    onResize() {
	        if (!this.camera || !this.overlayCamera)
	            return;
	        this.camera.aspect = window.innerWidth / window.innerHeight;
	        this.camera.updateProjectionMatrix();
	        this.overlayCamera.left = 0;
	        this.overlayCamera.right = window.innerWidth;
	        this.overlayCamera.top = 0;
	        this.overlayCamera.bottom = window.innerHeight;
	        this.overlayCamera.updateProjectionMatrix();
	    }
	    onMouseMove(e) {
	        if (!this.started || !document.pointerLockElement || this.finishTime || this.paused || this.replay.mode === 'playback')
	            return;
	        let totalDistance = Math.hypot(e.movementX, e.movementY);
	        // Strangely enough, Chrome really bugs out sometimes and flings the mouse into a random direction quickly. We try to catch that here and ignore the mouse movement if we detect it.
	        if (totalDistance > 350 && this.previousMouseMovementDistance * 4 < totalDistance) {
	            this.previousMouseMovementDistance *= 1.5; // Make the condition harder to hit the next time
	            return;
	        }
	        this.previousMouseMovementDistance = totalDistance;
	        let factor = Util.lerp(1 / 2500, 1 / 100, StorageManager.data.settings.mouseSensitivity);
	        let xFactor = (StorageManager.data.settings.invertMouse & 0b01) ? -1 : 1;
	        let yFactor = (StorageManager.data.settings.invertMouse & 0b10) ? -1 : 1;
	        let freeLook = StorageManager.data.settings.alwaysFreeLook || isPressed('freeLook');
	        if (freeLook)
	            this.pitch += e.movementY * factor * yFactor;
	        this.yaw -= e.movementX * factor * xFactor;
	    }
	    pickUpPowerUp(powerUp, playPickUpSound = true) {
	        if (!powerUp)
	            return false;
	        if (this.heldPowerUp && powerUp.constructor === this.heldPowerUp.constructor)
	            return false;
	        this.heldPowerUp = powerUp;
	        G.menu.hud.setPowerupButtonState(true);
	        for (let overlayShape of this.overlayShapes) {
	            if (overlayShape.dtsPath.includes("gem"))
	                continue;
	            // Show the corresponding icon in the HUD
	            overlayShape.setOpacity(Number(overlayShape.dtsPath === powerUp.dtsPath));
	        }
	        if (playPickUpSound)
	            AudioManager.play(powerUp.sounds[0]);
	        return true;
	    }
	    deselectPowerUp() {
	        if (!this.heldPowerUp) {
	            G.menu.hud.setPowerupButtonState(false);
	            return;
	        }
	        this.heldPowerUp = null;
	        G.menu.hud.setPowerupButtonState(false);
	        for (let overlayShape of this.overlayShapes) {
	            if (overlayShape.dtsPath.includes("gem"))
	                continue;
	            overlayShape.setOpacity(0);
	        }
	    }
	    pickUpGem(t) {
	        this.gemCount++;
	        let string;
	        let gemWord = (G.modification === 'gold') ? 'gem' : 'diamond';
	        // Show a notification (and play a sound) based on the gems remaining
	        if (this.gemCount === this.totalGems) {
	            string = `You have all the ${gemWord}s, head for the finish!`;
	            AudioManager.play('gotallgems.wav');
	            // Some levels with this package end immediately upon collection of all gems
	            if (this.mission.misFile.activatedPackages.includes('endWithTheGems')) {
	                this.touchFinish(t);
	            }
	        }
	        else {
	            string = `You picked up a ${gemWord}${G.modification === 'gold' ? '.' : '!'}  `;
	            let remaining = this.totalGems - this.gemCount;
	            if (remaining === 1) {
	                string += `Only one ${gemWord} to go!`;
	            }
	            else {
	                string += `${remaining} ${gemWord}s to go!`;
	            }
	            AudioManager.play('gotgem.wav');
	        }
	        G.menu.hud.displayAlert(string);
	        G.menu.hud.displayGemCount(this.gemCount, this.totalGems);
	    }
	    addTimeTravelBonus(bonus, timeToRevert) {
	        if (this.currentTimeTravelBonus === 0) {
	            this.timeState.gameplayClock -= timeToRevert;
	            if (this.timeState.gameplayClock < 0)
	                this.timeState.gameplayClock = 0;
	            bonus -= timeToRevert;
	        }
	        this.currentTimeTravelBonus += bonus;
	    }
	    /** Triggers the out-of-bounds state. */
	    goOutOfBounds() {
	        if (this.outOfBounds || this.finishTime)
	            return;
	        G.menu.hud.setPowerupButtonState(true);
	        this.updateCamera(this.timeState); // Update the camera at the point of OOB-ing
	        this.outOfBounds = true;
	        this.outOfBoundsTime = Util.jsonClone(this.timeState);
	        this.oobCameraPosition = this.camera.position.clone();
	        G.menu.hud.setCenterText('outofbounds');
	        AudioManager.play('whoosh.wav');
	        if (this.replay.mode !== 'playback')
	            this.schedule(this.timeState.currentAttemptTime + 2000, () => this.restart(false), 'oobRestart');
	    }
	    /** Sets a new active checkpoint. */
	    saveCheckpointState(shape, trigger) {
	        var _a, _b;
	        if (this.currentCheckpoint === shape)
	            return;
	        if ((_a = this.currentCheckpoint) === null || _a === void 0 ? void 0 : _a.worldPosition.equals(shape.worldPosition))
	            return; // Some levels have identical overlapping checkpoints, which can cause an infinite checkpointing loop.
	        let disableOob = ((_b = shape.srcElement) === null || _b === void 0 ? void 0 : _b.disableOob) || (trigger === null || trigger === void 0 ? void 0 : trigger.element.disableOob);
	        if (MisParser.parseBoolean(disableOob) && this.outOfBounds)
	            return; // The checkpoint is configured to not work when the player is already OOB
	        this.currentCheckpoint = shape;
	        this.currentCheckpointTrigger = trigger;
	        this.checkpointCollectedGems.clear();
	        this.checkpointUp = this.currentUp.clone();
	        this.checkpointBlast = this.blastAmount;
	        // Remember all gems that were collected up to this point
	        for (let shape of this.shapes) {
	            if (!(shape instanceof Gem))
	                continue;
	            if (shape.pickedUp)
	                this.checkpointCollectedGems.add(shape);
	        }
	        this.checkpointHeldPowerUp = this.heldPowerUp;
	        G.menu.hud.displayAlert("Checkpoint reached!");
	        AudioManager.play('checkpoint.wav');
	    }
	    /** Resets to the last stored checkpoint state. */
	    loadCheckpointState() {
	        var _a, _b, _c, _d, _e, _f;
	        if (!this.currentCheckpoint)
	            return;
	        let marble = this.marble;
	        // Quite note: Checkpoints have slightly different behavior in Ultra, that's why there's some checks
	        let gravityField = ((_a = this.currentCheckpoint.srcElement) === null || _a === void 0 ? void 0 : _a.gravity) || ((_b = this.currentCheckpointTrigger) === null || _b === void 0 ? void 0 : _b.element.gravity);
	        if (MisParser.parseBoolean(gravityField) || this.mission.modification === 'ultra') {
	            // In this case, we set the gravity to the relative "up" vector of the checkpoint shape.
	            let up = new Vector3(0, 0, 1);
	            up.applyQuaternion(this.currentCheckpoint.worldOrientation);
	            this.setUp(up, true);
	        }
	        else {
	            // Otherwise, we restore gravity to what was stored.
	            this.setUp(this.checkpointUp, true);
	        }
	        // Determine where to spawn the marble
	        let offset = new Vector3();
	        let add = ((_c = this.currentCheckpoint.srcElement) === null || _c === void 0 ? void 0 : _c.add) || ((_d = this.currentCheckpointTrigger) === null || _d === void 0 ? void 0 : _d.element.add);
	        if (add)
	            offset.add(MisParser.parseVector3(add));
	        let sub = ((_e = this.currentCheckpoint.srcElement) === null || _e === void 0 ? void 0 : _e.sub) || ((_f = this.currentCheckpointTrigger) === null || _f === void 0 ? void 0 : _f.element.sub);
	        if (sub)
	            offset.sub(MisParser.parseVector3(sub));
	        if (!add && !sub) {
	            offset.z = 3; // Defaults to (0, 0, 3)
	            if (this.mission.modification === 'ultra')
	                offset.applyQuaternion(this.currentCheckpoint.worldOrientation); // weird <3
	        }
	        marble.body.position.copy(this.currentCheckpoint.worldPosition).add(offset);
	        marble.body.linearVelocity.setScalar(0);
	        marble.body.angularVelocity.setScalar(0);
	        marble.calculatePredictiveTransforms();
	        // Set camera orienation
	        let euler = new Euler();
	        euler.setFromQuaternion(this.currentCheckpoint.worldOrientation, "ZXY");
	        this.yaw = euler.z + Math.PI / 2;
	        this.pitch = DEFAULT_PITCH$1;
	        // Restore gem states
	        for (let shape of this.shapes) {
	            if (!(shape instanceof Gem))
	                continue;
	            if (shape.pickedUp && !this.checkpointCollectedGems.has(shape)) {
	                shape.reset();
	                this.gemCount--;
	            }
	        }
	        G.menu.hud.displayGemCount(this.gemCount, this.totalGems);
	        G.menu.hud.setCenterText('none');
	        // Turn all of these off
	        marble.superBounceEnableTime = -Infinity;
	        marble.shockAbsorberEnableTime = -Infinity;
	        marble.helicopterEnableTime = -Infinity;
	        marble.megaMarbleEnableTime = -Infinity;
	        this.clearSchedule();
	        this.outOfBounds = false;
	        this.blastAmount = this.checkpointBlast;
	        this.finishTime = null; // For those very, very rare cases where the player touched the finish while OOB, but not fast enough, so they get respawned at the checkpoint and we need to remove the "finish lock".
	        this.deselectPowerUp(); // Always deselect first
	        // Wait a bit to select the powerup to prevent immediately using it incase the user skipped the OOB screen by clicking
	        if (this.checkpointHeldPowerUp)
	            this.schedule(this.timeState.currentAttemptTime + 500, () => this.pickUpPowerUp(this.checkpointHeldPowerUp, false));
	        AudioManager.play('spawn.wav');
	        this.replay.recordCheckpointRespawn();
	    }
	    touchFinish(completionOfImpact) {
	        var _a;
	        if (this.finishTime !== null)
	            return;
	        this.replay.recordTouchFinish();
	        if (this.gemCount < this.totalGems) {
	            AudioManager.play('missinggems.wav');
	            G.menu.hud.displayAlert((G.modification === 'gold') ? "You can't finish without all the gems!!" : "You may not finish without all the diamonds!");
	        }
	        else {
	            if (completionOfImpact === undefined)
	                completionOfImpact = 1;
	            let toSubtract = (1 - completionOfImpact) * 1000 / PHYSICS_TICK_RATE$1;
	            this.finishTime = Util.jsonClone(this.timeState);
	            // Compute the precise finish time here
	            this.finishTime.timeSinceLoad -= toSubtract;
	            this.finishTime.currentAttemptTime -= toSubtract;
	            if (this.currentTimeTravelBonus === 0)
	                this.finishTime.gameplayClock -= toSubtract;
	            this.finishTime.gameplayClock = Util.clamp(this.finishTime.gameplayClock, 0, MAX_TIME$1); // Apply the time cap
	            this.finishTime.physicsTickCompletion = completionOfImpact;
	            this.currentTimeTravelBonus = 0;
	            (_a = this.alarmSound) === null || _a === void 0 ? void 0 : _a.stop();
	            if (this.replay.mode === 'playback')
	                this.finishTime = this.replay.finishTime;
	            this.finishYaw = this.yaw;
	            this.finishPitch = this.pitch;
	            let endPad = Util.findLast(this.shapes, (shape) => shape instanceof EndPad);
	            endPad === null || endPad === void 0 ? void 0 : endPad.spawnFirework(this.timeState); // EndPad *might* not exist, in that case no fireworks lol
	            G.menu.hud.displayAlert("Congratulations! You've finished!");
	            // Check if the player is OOB, but still allow finishing with less than half a second of having been OOB
	            if (this.outOfBounds && this.timeState.currentAttemptTime - this.outOfBoundsTime.currentAttemptTime >= 500)
	                return;
	            // When we reach this point, the player has actually successfully completed the level.
	            this.clearScheduleId('oobRestart'); // Make sure we don't restart the level now
	            // Schedule the finish screen to be shown
	            if (this.replay.mode !== 'playback')
	                this.schedule(this.timeState.currentAttemptTime + 2000, () => {
	                    var _a;
	                    // Show the finish screen
	                    (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	                    G.menu.finishScreen.show();
	                    hideTouchControls();
	                    resetPressedFlag('use');
	                    resetPressedFlag('jump');
	                    resetPressedFlag('restart');
	                });
	        }
	    }
	    /** Pauses the level. */
	    pause() {
	        var _a;
	        if (this.paused || (G.level.finishTime && G.level.replay.mode === 'record'))
	            return;
	        this.paused = true;
	        (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	        releaseAllButtons(); // Safety measure to prevent keys from getting stuck
	        G.menu.pauseScreen.show();
	        hideTouchControls();
	    }
	    /** Unpauses the level. */
	    unpause() {
	        this.paused = false;
	        if (!Util.isTouchDevice)
	            Util.requestPointerLock();
	        G.menu.pauseScreen.hide();
	        this.lastPhysicsTick = performance.now();
	        maybeShowTouchControls();
	    }
	    /** Ends the level irreversibly. */
	    stop() {
	        var _a, _b, _c, _d, _e, _f, _g;
	        this.stopped = true;
	        clearInterval(this.tickInterval);
	        this.dispose();
	        this.music.stop();
	        for (let interior of this.interiors) {
	            if (interior instanceof PathedInterior)
	                (_a = interior.soundSource) === null || _a === void 0 ? void 0 : _a.stop();
	        }
	        for (let shape of this.shapes) {
	            if (shape instanceof Tornado || shape instanceof DuctFan)
	                (_b = shape.soundSource) === null || _b === void 0 ? void 0 : _b.stop();
	        }
	        (_c = this.marble.rollingSound) === null || _c === void 0 ? void 0 : _c.stop();
	        (_d = this.marble.slidingSound) === null || _d === void 0 ? void 0 : _d.stop();
	        (_e = this.marble.helicopterSound) === null || _e === void 0 ? void 0 : _e.stop();
	        (_f = this.marble.shockAbsorberSound) === null || _f === void 0 ? void 0 : _f.stop();
	        (_g = this.marble.superBounceSound) === null || _g === void 0 ? void 0 : _g.stop();
	        AudioManager.stopAllAudio();
	    }
	    /** Stops and destroys the current level and returns back to the menu. */
	    stopAndExit() {
	        var _a;
	        this.stop();
	        G.level = null;
	        mainCanvas.classList.add('hidden');
	        G.menu.pauseScreen.hide();
	        G.menu.levelSelect.show();
	        G.menu.levelSelect.displayBestTimes(); // Potentially update best times having changed
	        G.menu.finishScreen.hide();
	        G.menu.hideGameUi();
	        G.menu.show();
	        (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	    }
	    /** Returns how much percent the level has finished loading. */
	    getLoadingCompletion() {
	        return this.loadingState.total ? this.loadingState.loaded / this.loadingState.total : 0;
	    }
	    /** Disposes the GPU assets used by the level. */
	    dispose() {
	        this.scene.dispose();
	        this.marble.dispose();
	        mainRenderer.cleanUp();
	    }
	    queueStateUpdates() {
	        for (let marble of this.marbles) {
	            if (marble !== this.marble)
	                continue;
	            if (marble.hasNewState) {
	                let lastState = Util.last(marble.stateHistory);
	                gameServers[0].connection.queueCommand('gameObjectUpdate', {
	                    gameObjectId: marble.id,
	                    state: lastState.state
	                }, true, 'stateUpdate@' + marble.id);
	            }
	        }
	    }
	    onStateUpdate(data) {
	        let marble = this.marbles.find(x => x.id === data.gameObjectId);
	        if (marble === this.marble)
	            return;
	        if (!marble) {
	            marble = this.marblePool.pop();
	            marble.id = data.gameObjectId;
	            marble.group.setOpacity(1);
	            this.world.add(marble.body);
	            this.marbles.push(marble);
	            console.log("Created");
	        }
	        marble.loadState(data.state); // temp type for now
	    }
	}
	//# sourceMappingURL=level.js.map

	/** A teleport trigger teleports the marble to a specified destination after some time of being inside it. */
	class TeleportTrigger$1 extends Trigger {
	    constructor(element, game) {
	        super(element, game);
	        /** How long after entry until the teleport happens */
	        this.delay = 2000;
	        this.sounds = ["teleport.wav"];
	        if (element.delay)
	            this.delay = MisParser$1.parseNumber(element.delay);
	    }
	    onMarbleEnter(marble) {
	        let teleportState = marble.getTeleportState(this);
	        teleportState.exitFrame = null;
	        marble.enableTeleportingLook();
	        if (teleportState.entryFrame !== null)
	            return;
	        teleportState.entryFrame = this.game.state.frame;
	        G$1.menu.hud.displayAlert(() => {
	            return this.game.localPlayer.controlledMarble === marble ? "Teleporter has been activated, please wait." : null;
	        }, this.game.state.frame);
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            let sound = AudioManager$1.createAudioSource('teleport.wav', undefined, marble.body.position);
	            sound.play();
	            marble.teleportSounds.get(this).push(sound);
	        }, `${this.id} ${marble.id}sound`, true);
	    }
	    onMarbleLeave(marble) {
	        let teleportState = marble.getTeleportState(this);
	        teleportState.exitFrame = this.game.state.frame;
	        marble.disableTeleportingLook();
	    }
	    executeTeleport(marble) {
	        let teleportState = marble.getTeleportState(this);
	        teleportState.entryFrame = null;
	        // Find the destination trigger
	        let destination = this.game.triggers.find(x => { var _a; return x instanceof DestinationTrigger$1 && x.element._name.toLowerCase() === ((_a = this.element.destination) === null || _a === void 0 ? void 0 : _a.toLowerCase()); });
	        if (!destination)
	            return; // Who knows
	        let body = marble.body;
	        // Determine where to place the marble
	        let position;
	        if (this.element.centerdestpoint || destination.element.centerdestpoint) {
	            position = destination.body.position;
	        }
	        else {
	            position = destination.vertices[0].clone().add(new Vector3$1(0, 0, 3));
	        }
	        body.position.copy(position);
	        body.prevPosition.copy(position); // Avoid funky CCD business
	        marble.cancelInterpolation();
	        if (!MisParser$1.parseBoolean(this.element.keepvelocity || destination.element.keepvelocity))
	            body.linearVelocity.setScalar(0);
	        if (MisParser$1.parseBoolean(this.element.inversevelocity || destination.element.inversevelocity))
	            body.linearVelocity.negate();
	        if (!MisParser$1.parseBoolean(this.element.keepangular || destination.element.keepangular))
	            body.angularVelocity.setScalar(0);
	        // Determine camera orientation
	        if (!MisParser$1.parseBoolean(this.element.keepcamera || destination.element.keepcamera) && marble.controllingPlayer) {
	            let yaw;
	            if (this.element.camerayaw)
	                yaw = Util$1.degToRad(MisParser$1.parseNumber(this.element.camerayaw));
	            else if (destination.element.camerayaw)
	                yaw = Util$1.degToRad(MisParser$1.parseNumber(destination.element.camerayaw));
	            else
	                yaw = 0;
	            marble.controllingPlayer.yaw = yaw + Math.PI / 2;
	            marble.controllingPlayer.pitch = DEFAULT_PITCH$1;
	        }
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play('spawn.wav', undefined, undefined, marble.body.position);
	        }, `${this.id} ${marble.id}spawn`, true);
	        for (let sound of marble.teleportSounds.get(this))
	            sound.stop();
	        marble.teleportSounds.get(this).length = 0;
	    }
	}
	//# sourceMappingURL=teleport_trigger.js.map

	const DEFAULT_COOLDOWN_DURATION = 7;
	/** Powerups can be collected and used by the player for bonus effects. */
	class PowerUp$1 extends Shape$1 {
	    constructor(element) {
	        super();
	        this.restartable = true;
	        /** Reappears after this time. */
	        this.cooldownDuration = DEFAULT_COOLDOWN_DURATION;
	        /** Whether or not to automatically use the powerup instantly on pickup. */
	        this.autoUse = false;
	        this.ambientRotate = true;
	        this.collideable = false;
	        this.shareMaterials = false;
	        /** Overrides the full pick up alert string. */
	        this.customPickUpAlert = null;
	        /** If 'an' should be used instead of 'a' in the pickup alert. */
	        this.an = false;
	        this.pickUpFrame = -Infinity;
	        this.pickedUpBy = null;
	        this.element = element;
	    }
	    get pickupable() {
	        return this.game.state.frame - this.pickUpFrame >= this.cooldownDuration * GAME_UPDATE_RATE;
	    }
	    onMarbleInside(t, marble) {
	        marble.affect(this);
	        //this.interactWith(marble);
	        //this.stateNeedsStore = true;
	        if (!this.pickupable)
	            return;
	        if (this.pickUp(marble)) {
	            this.pickUpFrame = this.game.state.frame;
	            this.pickedUpBy = marble;
	            this.affect(marble);
	            this.pickUpCosmetically(marble, this.game.state.frame);
	            //this.setCollisionEnabled(false);
	            if (this.autoUse) {
	                this.use(marble, t);
	                this.useCosmetically(marble);
	            }
	            this.stateNeedsStore = true;
	        }
	    }
	    update(onlyVisual) {
	        if (onlyVisual)
	            return;
	        // Enable or disable the collision based on pickupability
	        //this.setCollisionEnabled(this.pickupable);
	    }
	    render() {
	        super.render();
	        let opacity = 1;
	        if (this.pickUpFrame > -Infinity && this.cooldownDuration > 0) {
	            let availableTime = this.pickUpFrame / GAME_UPDATE_RATE + this.cooldownDuration;
	            opacity = Util$1.clamp(this.game.state.time - availableTime, 0, 1);
	        }
	        this.setOpacity(opacity);
	    }
	    pickUpCosmetically(marble, frame) {
	        if (marble === this.game.localPlayer.controlledMarble)
	            this.game.simulator.executeNonDuplicatableEvent(() => AudioManager$1.play(this.sounds[0]), `${this.id}sound`, true);
	        G$1.menu.hud.displayAlert(this.getAlertMessage.bind(this), frame);
	        if (MisParser$1.parseBoolean(this.element.showhelponpickup) && !this.autoUse)
	            G$1.menu.hud.displayHelp(this.getHelpMessage.bind(this), frame);
	    }
	    getAlertMessage() {
	        var _a;
	        if (this.pickedUpBy === null)
	            return null;
	        if (this.pickedUpBy.controllingPlayer !== this.game.localPlayer)
	            return null;
	        return (_a = this.customPickUpAlert) !== null && _a !== void 0 ? _a : `You picked up ${this.an ? 'an' : 'a'} ${this.pickUpName}!`;
	    }
	    getHelpMessage() {
	        if (this.pickedUpBy === null)
	            return null;
	        if (this.pickedUpBy.controllingPlayer !== this.game.localPlayer)
	            return null;
	        return `Press <func:bind mousefire> to use the ${this.pickUpName}!`;
	    }
	    getState() {
	        var _a, _b;
	        return {
	            entityType: 'powerUp',
	            pickUpFrame: isFinite(this.pickUpFrame) ? this.pickUpFrame : null,
	            pickedUpBy: (_b = (_a = this.pickedUpBy) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'powerUp',
	            pickUpFrame: null,
	            pickedUpBy: null
	        };
	    }
	    loadState(state, { frame }) {
	        var _a;
	        let prevPickUpFrame = this.pickUpFrame;
	        this.pickUpFrame = (_a = state.pickUpFrame) !== null && _a !== void 0 ? _a : -Infinity;
	        this.pickedUpBy = this.game.getEntityById(state.pickedUpBy);
	        if (this.pickedUpBy && prevPickUpFrame < this.pickUpFrame)
	            this.pickUpCosmetically(this.pickedUpBy, frame);
	    }
	}
	//# sourceMappingURL=power_up.js.map

	/** Changes the gravity on pickup. */
	class AntiGravity$1 extends PowerUp$1 {
	    constructor(element, respawnInstantly = false) {
	        super(element);
	        this.dtsPath = "shapes/items/antigravity.dts";
	        this.autoUse = true;
	        this.pickUpName = (G$1.modification === 'gold') ? "Gravity Modifier" : "Gravity Defier";
	        this.sounds = ["gravitychange.wav"];
	        if (respawnInstantly)
	            this.cooldownDuration = -Infinity;
	    }
	    pickUp(marble) {
	        let direction = new Vector3$1(0, 0, -1);
	        direction.applyQuaternion(this.worldOrientation).normalize();
	        return !direction.fequals(marble.currentUp);
	    }
	    use(marble) {
	        // Determine the new up vector
	        let direction = new Vector3$1(0, 0, -1);
	        direction.applyQuaternion(this.worldOrientation);
	        marble.setUp(direction);
	        AudioManager$1.play(this.sounds[0]);
	    }
	    useCosmetically(marble) {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(this.sounds[0]);
	        }, `${this.id} ${marble.id}useCosmetic`, true);
	    }
	}
	//# sourceMappingURL=anti_gravity.js.map

	class Blast$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = 'shapes/items/blast.dts';
	        this.autoUse = true;
	        this.sounds = ["publastvoice.wav"];
	        this.pickUpName = "Blast PowerUp";
	    }
	    pickUp() {
	        return true;
	    }
	    use(marble) {
	        marble.blastAmount = 1.03;
	    }
	    useCosmetically() { }
	}
	//# sourceMappingURL=blast.js.map

	/** On contact, sets a new checkpoint with itself as the respawn shape. */
	class Checkpoint$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/buttons/checkpoint.dts";
	        this.sounds = ['checkpoint.wav'];
	    }
	    onMarbleContact(collision, marble) {
	        marble.checkpointState.save(this);
	    }
	}
	//# sourceMappingURL=checkpoint.js.map

	/** A shape with force areas that can push or pull the marble. */
	class ForceShape extends Shape$1 {
	    /** Creates a cone-shaped force area that widens as it gets farther away its origin. */
	    addConicForce(distance, arcangle, strength) {
	        let semiverticalangle = arcangle / 2; // Self explanatory, the semi-vertical angle of the right circular cone
	        // Apparently, the tip of the cone in MB is a bit behind the center of the fan,
	        // we are not handling the cases the marble is just a little bit behind the fan, so we must adjust the strength accordingly.
	        // Strength of the fan is inversely proportional to the distance between the tip of the cone and the marble
	        let actualStrength = strength - (strength * (0.7 / distance));
	        let actualDistance = distance - 0.7;
	        // Create a cone-shaped collider
	        this.addCollider(() => new BallCollisionShape(distance), new Matrix4(), (t, dt, marble) => {
	            let perpendicular = new Vector3$1(0, 0, 1); // The normal to the fan
	            perpendicular.applyQuaternion(this.worldOrientation);
	            let conetip = this.worldPosition.clone().sub(perpendicular.multiplyScalar(0.7)); // The tip of the cone
	            let vec = marble.body.position.clone().sub(conetip); // The vector from the tip of the cone to the marble
	            if (vec.length() === 0)
	                return;
	            if (vec.length() > actualDistance)
	                return; // Our distance is greater than the allowed distance, so we stop right here
	            // Maximum force is proportional to the negative of the distance between the marble and the tip of the cone
	            let maxF = Util$1.lerp(actualStrength, 0, vec.length() / actualDistance);
	            // Calculate the angle between the perpendicular and the relative position of the marble to the tip of the cone
	            let theta = perpendicular.angleTo(vec);
	            // If our angle is more than the maximum angle, we stop. The division by 2 is just there cause it just works.
	            if (theta > semiverticalangle / 2)
	                return;
	            // The force at an an angle is a parabolic function peaking at maxF, and its zeroes are the the positive and negative semi-vertical angles
	            let forcemag = Math.abs(-maxF * (theta - semiverticalangle) * (theta + semiverticalangle));
	            forcemag *= Math.sign(actualStrength);
	            // Now we have to get the direction of force
	            let force = vec.clone();
	            force.normalize();
	            // Now we apply it
	            marble.body.linearVelocity.addScaledVector(force, forcemag * dt);
	        });
	    }
	    /** Like `addConicForce`, but directly ported from OpenMBU (which did some reverse-engineering magic) */
	    addConicForceExceptItsAccurateThisTime(forceRadius, forceArc, forceStrength) {
	        // Create a cone-shaped collider
	        this.addCollider(() => new BallCollisionShape(forceRadius), new Matrix4(), (t, dt, marble) => {
	            let force = this.computeAccurateConicForce(marble.body.position, forceRadius, forceArc, forceStrength);
	            // Calculate the actual force
	            force.multiplyScalar(dt);
	            // Now we apply it
	            marble.body.linearVelocity.add(force);
	        });
	    }
	    computeAccurateConicForce(pos, forceRadius, forceArc, forceStrength) {
	        let strength = 0.0;
	        let dot = 0.0;
	        let posVec = new Vector3$1();
	        let retForce = new Vector3$1();
	        let node = this.worldMatrix.clone(); // In the general case, this is a mount node, but we're only using this method for magnets so far and those don't have that, so use the magnet's transform instead
	        let nodeVec = new Vector3$1(node.elements[4], node.elements[5], node.elements[6]); // Gets the second column, so basically the transformed y axis
	        nodeVec.normalize();
	        posVec = pos.clone().sub(new Vector3$1().setFromMatrixPosition(node));
	        dot = posVec.length();
	        if (forceRadius < dot) {
	            // We're outside the area of effect
	            return retForce;
	        }
	        strength = (1 - dot / forceRadius) * forceStrength;
	        posVec.multiplyScalar(1 / dot);
	        let newDot = nodeVec.dot(posVec);
	        let arc = forceArc;
	        if (arc < newDot) {
	            retForce.add(posVec.multiplyScalar(strength).multiplyScalar(newDot - arc).multiplyScalar(1 / (1 - arc)));
	        }
	        return retForce;
	    }
	    /** Creates a spherical-shaped force whose force always acts in the direction away from the center. */
	    addSphericalForce(radius, strength) {
	        this.addCollider(() => new BallCollisionShape(radius), new Matrix4(), (t, dt, marble) => {
	            let vec = marble.body.position.clone().sub(this.worldPosition);
	            if (vec.length() === 0)
	                return;
	            let strengthFac = 1 - Util$1.clamp(vec.length() / radius, 0, 1) ** 2; // Quadratic falloff with distance
	            marble.body.linearVelocity.addScaledVector(vec.normalize(), strength * strengthFac * dt);
	        });
	    }
	    /** Creates a spherical-shaped force whose force acts in the direction of the vector specified. */
	    addFieldForce(radius, forceVector) {
	        this.addCollider(() => new BallCollisionShape(radius), new Matrix4(), (t, dt, marble) => {
	            if (marble.body.position.distanceTo(this.worldPosition) >= radius)
	                return;
	            // Simply add the force
	            marble.body.linearVelocity.addScaledVector(forceVector, dt);
	        });
	    }
	}
	//# sourceMappingURL=force_shape.js.map

	/** Blows the marble away. */
	class DuctFan$1 extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/ductfan.dts";
	        this.sounds = ["fan_loop.wav"];
	        this.addConicForce(10, 2.617, 40);
	    }
	    async onLevelStart() {
	        this.soundSource = AudioManager$1.createAudioSource(this.sounds[0], AudioManager$1.soundGain, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}
	//# sourceMappingURL=duct_fan.js.map

	/** Easter eggs are hidden collectibles that the player can search for. */
	class EasterEgg$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/easteregg.dts";
	        this.cooldownDuration = Infinity; // Won't respawn until the level is restarted
	        this.autoUse = true;
	        this.sounds = ["easter.wav", "easterfound.wav"]; // The sound varies based on if the player already found the egg
	        this.pickUpName = '';
	        this.alreadyHadEasterEgg = false;
	    }
	    init(game, srcElement = null) {
	        this.alreadyHadEasterEgg = StorageManager$1.data.collectedEggs.includes(game.mission.path);
	        Util$1.removeFromArray(StorageManager$1.data.collectedEggs, game.mission.path);
	        return super.init(game, srcElement);
	    }
	    pickUp() {
	        return true;
	    }
	    pickUpCosmetically(marble, frame) {
	        let alreadyFound = StorageManager$1.data.collectedEggs.includes(this.game.mission.path);
	        if (!alreadyFound) {
	            StorageManager$1.data.collectedEggs.push(this.game.mission.path);
	            StorageManager$1.store();
	            G$1.menu.levelSelect.displayMission(); // To refresh the icon
	        }
	        this.game.simulator.executeNonDuplicatableEvent(() => AudioManager$1.play(this.sounds[Number(alreadyFound)]), `${this.id}sound`, true);
	        G$1.menu.hud.displayAlert(() => alreadyFound ? "You already found this Easter Egg." : "You found an Easter Egg!", frame);
	    }
	    use() { }
	    useCosmetically() { }
	    loadState(state, meta) {
	        if (!this.alreadyHadEasterEgg) {
	            let index = StorageManager$1.data.collectedEggs.indexOf(this.game.mission.path);
	            if (index !== -1 && state.pickedUpBy === null) {
	                // "Unpickup" the egg
	                StorageManager$1.data.collectedEggs.splice(index, 1);
	                StorageManager$1.store();
	                G$1.menu.levelSelect.displayMission(); // To refresh the icon
	            }
	        }
	        super.loadState(state, meta);
	    }
	}
	//# sourceMappingURL=easter_egg.js.map

	class Glass$1 extends Shape$1 {
	    constructor(dataBlock) {
	        super();
	        let dim = /glass_(\d+)shape/.exec(dataBlock)[1];
	        this.dtsPath = `shapes/glass/${dim}x3.dts`;
	        this.colliderDtsPath = `shapes/glass/col/${dim}x3.dts`;
	    }
	}
	//# sourceMappingURL=glass.js.map

	/** Reduces gravity temporarily. */
	class Helicopter$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/images/helicopter.dts";
	        this.showSequences = false;
	        this.shareNodeTransforms = false;
	        this.pickUpName = (G$1.modification === 'gold') ? "Gyrocopter PowerUp" : "Helicopter PowerUp";
	        this.sounds = ["pugyrocoptervoice.wav", "use_gyrocopter.wav"];
	    }
	    pickUp(marble) {
	        return marble.pickUpPowerUp(this);
	    }
	    use(marble) {
	        marble.enableHelicopter();
	    }
	    useCosmetically() { }
	}
	//# sourceMappingURL=helicopter.js.map

	/** Land mines explode on contact and knock the marble away. */
	class LandMine$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/hazards/landmine.dts";
	        this.disappearTime = -Infinity;
	        this.sounds = ['explode1.wav'];
	        this.shareMaterials = false;
	    }
	    onMarbleContact(collision, marble) {
	        if (this.game instanceof MultiplayerGame) {
	            // We disable prediction of mine impacts of marbles we're not sure about, because mine impacts create a very sudden and disturbing gameplay effect.
	            let sureAboutIt = marble.affectedBy.size === 1 && marble.affectedBy.has(this.game.localPlayer);
	            if (!sureAboutIt && this.game.state.frame > this.game.state.serverFrame)
	                return;
	        }
	        let minePos = this.worldPosition;
	        for (let marble of this.game.marbles) {
	            let vec = marble.body.position.clone().sub(minePos);
	            let explosionStrength = this.computeExplosionStrength(vec.length());
	            if (explosionStrength === 0)
	                continue;
	            // Add velocity to the marble
	            marble.body.linearVelocity.addScaledVector(vec.normalize(), explosionStrength);
	            marble.slidingTimeout = 2;
	            this.affect(marble);
	        }
	        this.disappearTime = this.game.state.time;
	        this.setCollisionEnabled(false);
	        this.stateNeedsStore = true;
	        marble.affect(this);
	        this.applyCosmeticEffects();
	    }
	    /** Computes the strength of the explosion (force) based on distance from it. */
	    computeExplosionStrength(r) {
	        // Figured out through testing by RandomityGuy
	        if (r >= 10.25)
	            return 0;
	        if (r >= 10)
	            return Util$1.lerp(30.0087, 30.7555, r - 10);
	        // The explosion first becomes stronger the further you are away from it, then becomes weaker again (parabolic).
	        let a = 0.071436222;
	        let v = ((r - 5) ** 2) / (-4 * a) + 87.5;
	        return v;
	    }
	    update(onlyVisual) {
	        if (onlyVisual)
	            return;
	        // Enable or disable the collision based on disappear time
	        let visible = this.game.state.time >= this.disappearTime + 5;
	        this.setCollisionEnabled(visible);
	    }
	    render() {
	        let opacity = Util$1.clamp(this.game.state.time - (this.disappearTime + 5), 0, 1);
	        this.setOpacity(opacity);
	        super.render();
	    }
	    getState() {
	        return {
	            entityType: 'explosive',
	            disappearTime: this.disappearTime
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'explosive',
	            disappearTime: -Infinity
	        };
	    }
	    loadState(state) {
	        if (state.disappearTime > this.disappearTime)
	            this.applyCosmeticEffects();
	        this.disappearTime = state.disappearTime;
	    }
	    applyCosmeticEffects() {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(this.sounds[0], undefined, undefined, this.worldPosition);
	            this.game.renderer.particles.createEmitter(landMineParticle, this.worldPosition);
	            this.game.renderer.particles.createEmitter(landMineSmokeParticle, this.worldPosition);
	            this.game.renderer.particles.createEmitter(landMineSparksParticle, this.worldPosition);
	            // Normally, we would add a light here, but eh.
	        }, `${this.id}sound`, true);
	    }
	}
	/** The fire particle. */
	const landMineParticle = {
	    ejectionPeriod: 0.2,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 2,
	    velocityVariance: 1,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1000,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.8,
	        acceleration: 0,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.56, g: 0.36, b: 0.26, a: 0 }],
	        sizes: [0.5, 1],
	        times: [0, 1]
	    }
	};
	/** The smoke particle. */
	const landMineSmokeParticle = {
	    ejectionPeriod: 0.5,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 0.8,
	    velocityVariance: 0.4,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1200,
	        lifetimeVariance: 300,
	        dragCoefficient: 0.85,
	        acceleration: -8,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.2, g: 0.2, b: 0.2, a: 1 }, { r: 0, g: 0, b: 0, a: 0 }],
	        sizes: [1, 1.5, 2],
	        times: [0, 0.5, 1]
	    }
	};
	/** The sparks exploding away. */
	const landMineSparksParticle = {
	    ejectionPeriod: 0.4,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 13 / 4,
	    velocityVariance: 6.75 / 4,
	    emitterLifetime: 100,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 500,
	        lifetimeVariance: 350,
	        dragCoefficient: 0.75,
	        acceleration: -8,
	        colors: [{ r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 1, g: 0.4, b: 0.3, a: 0 }],
	        sizes: [0.5, 0.25, 0.25],
	        times: [0, 0.5, 1]
	    }
	};
	//# sourceMappingURL=land_mine.js.map

	/** Magnets pull the marble towards itself. */
	class Magnet$1 extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/magnet/magnet.dts";
	        this.collideable = false;
	        this.sounds = ["magnet.wav"];
	        this.addConicForceExceptItsAccurateThisTime(10, 0.7, -90);
	    }
	    async onLevelStart() {
	        this.soundSource = AudioManager$1.createAudioSource(this.sounds[0], AudioManager$1.soundGain, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}
	//# sourceMappingURL=magnet.js.map

	class MegaMarble$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = 'shapes/items/megamarble.dts';
	        this.sounds = ["pumegamarblevoice.wav", "dosuperjump.wav", "mega_bouncehard1.wav", "mega_bouncehard2.wav", "mega_bouncehard3.wav", "mega_bouncehard4.wav", "mega_roll.wav"];
	        this.pickUpName = "Mega Marble PowerUp";
	    }
	    pickUp(marble) {
	        return marble.pickUpPowerUp(this);
	    }
	    use(marble) {
	        marble.enableMegaMarble();
	    }
	    useCosmetically() { }
	}
	//# sourceMappingURL=mega_marble.js.map

	/** Nukes explode on contact and knock the marble away even more than mines do. */
	class Nuke$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/hazards/nuke/nuke.dts";
	        this.disappearTime = -Infinity;
	        this.sounds = ['nukeexplode.wav'];
	        this.shareMaterials = false;
	    }
	    onMarbleContact(collision, marble) {
	        if (this.game instanceof MultiplayerGame) {
	            // We disable prediction of nuke impacts of marbles we're not sure about, because nuke impacts create a very sudden and disturbing gameplay effect.
	            let sureAboutIt = marble.affectedBy.size === 1 && marble.affectedBy.has(this.game.localPlayer);
	            if (!sureAboutIt && this.game.state.frame > this.game.state.serverFrame)
	                return;
	        }
	        let nukePos = this.worldPosition;
	        for (let marble of this.game.marbles) {
	            let explosionForce = this.computeExplosionForce(marble.body.position.clone().sub(nukePos));
	            if (explosionForce.length() === 0)
	                continue;
	            // Add velocity to the marble
	            marble.body.linearVelocity.add(explosionForce);
	            marble.slidingTimeout = 2;
	            this.affect(marble);
	        }
	        this.disappearTime = this.game.state.time;
	        this.setCollisionEnabled(false);
	        this.stateNeedsStore = true;
	        marble.affect(this);
	        this.applyCosmeticEffects();
	    }
	    /** Computes the force of the explosion based on the vector to the nuke. Ported from decompiled MBG. */
	    computeExplosionForce(distVec) {
	        const range = 10;
	        const power = 100;
	        let dist = distVec.length();
	        if (dist < range) {
	            let scalar = (1 - dist / range) * power;
	            distVec.multiplyScalar(scalar);
	        }
	        else {
	            distVec.setScalar(0);
	        }
	        return distVec;
	    }
	    update(onlyVisual) {
	        if (onlyVisual)
	            return;
	        // Enable or disable the collision based on disappear time
	        let visible = this.game.state.time >= this.disappearTime + 5;
	        this.setCollisionEnabled(visible);
	    }
	    render() {
	        let opacity = Util$1.clamp(this.game.state.time - (this.disappearTime + 15), 0, 1);
	        this.setOpacity(opacity);
	        super.render();
	    }
	    getState() {
	        return {
	            entityType: 'explosive',
	            disappearTime: this.disappearTime
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'explosive',
	            disappearTime: -Infinity
	        };
	    }
	    loadState(state) {
	        if (state.disappearTime > this.disappearTime)
	            this.applyCosmeticEffects();
	        this.disappearTime = state.disappearTime;
	    }
	    applyCosmeticEffects() {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(this.sounds[0], undefined, undefined, this.worldPosition);
	            this.game.renderer.particles.createEmitter(nukeParticle, this.worldPosition);
	            this.game.renderer.particles.createEmitter(nukeSmokeParticle, this.worldPosition);
	            this.game.renderer.particles.createEmitter(nukeSparksParticle, this.worldPosition);
	        }, `${this.id}sound`, true);
	    }
	}
	/** The fire particle. */
	const nukeParticle = {
	    ejectionPeriod: 0.2,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 2,
	    velocityVariance: 1,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1000,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.8,
	        acceleration: 0,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.56, g: 0.36, b: 0.26, a: 0 }],
	        sizes: [0.5, 1],
	        times: [0, 1]
	    }
	};
	/** The smoke particle. */
	const nukeSmokeParticle = {
	    ejectionPeriod: 0.5,
	    ambientVelocity: new Vector3$1(0, 0, 0),
	    ejectionVelocity: 1.3,
	    velocityVariance: 0.5,
	    emitterLifetime: 50,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/smoke.png',
	        blending: BlendingType.Normal,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 2500,
	        lifetimeVariance: 300,
	        dragCoefficient: 0.7,
	        acceleration: -8,
	        colors: [{ r: 0.56, g: 0.36, b: 0.26, a: 1 }, { r: 0.2, g: 0.2, b: 0.2, a: 0.85 }, { r: 0, g: 0, b: 0, a: 0 }],
	        sizes: [1, 1.5, 2],
	        times: [0, 0.5, 1]
	    }
	};
	/** The sparks exploding away. */
	const nukeSparksParticle = {
	    ejectionPeriod: 1.7,
	    ambientVelocity: new Vector3$1(0, -0.5, 0),
	    ejectionVelocity: 13 / 1.5,
	    velocityVariance: 5 / 1,
	    emitterLifetime: 5000,
	    inheritedVelFactor: 0.2,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 40,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 4500,
	        lifetimeVariance: 2500,
	        dragCoefficient: 0.5,
	        acceleration:  0 ,
	        colors: [{ r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 0.6, g: 0.4, b: 0.3, a: 1 }, { r: 1, g: 0.4, b: 0.3, a: 0 }],
	        sizes: [0.5, 0.4, 0.2],
	        times: [0, 0.5, 1]
	    }
	};
	//# sourceMappingURL=nuke.js.map

	/** Oilslicks are slippery. */
	class Oilslick$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/hazards/oilslick.dts";
	        this.friction = specialFrictionFactor['friction_none'];
	    }
	}
	//# sourceMappingURL=oilslick.js.map

	const RESET_TIME = 5;
	/** A simple shape representing a button that is pushed down when the shape is touched. */
	class PushButton$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = 'shapes/buttons/pushbutton.dts';
	        this.lastContactTime = -Infinity;
	        this.shareNodeTransforms = false;
	    }
	    get animationDuration() {
	        return this.dts.sequences[0].duration;
	    }
	    update(onlyVisual) {
	        let currentCompletion = this.getCurrentCompletion();
	        // Override the keyframe
	        this.sequenceKeyframeOverride.set(this.dts.sequences[0], currentCompletion * (this.dts.sequences[0].numKeyframes - 1));
	        super.update(onlyVisual);
	    }
	    /** Gets the current completion of the button pressedness. 0 = not pressed, 1 = completely pressed down. */
	    getCurrentCompletion() {
	        let elapsed = this.game.state.time - this.lastContactTime;
	        let completion = Util$1.clamp(elapsed / this.animationDuration, 0, 1);
	        if (elapsed > RESET_TIME)
	            completion = Util$1.clamp(1 - (elapsed - RESET_TIME) / this.animationDuration, 0, 1);
	        return completion;
	    }
	    onMarbleContact(collision, marble) {
	        let currentCompletion = this.getCurrentCompletion();
	        // Only trigger the button if it's completely retracted
	        if (currentCompletion === 0) {
	            this.lastContactTime = this.game.state.time;
	            this.stateNeedsStore = true;
	            marble.affect(this);
	        }
	    }
	    getState() {
	        return {
	            entityType: 'pushButton',
	            lastContactTime: this.lastContactTime
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'pushButton',
	            lastContactTime: -1
	        };
	    }
	    loadState(state) {
	        this.lastContactTime = state.lastContactTime;
	    }
	}
	//# sourceMappingURL=push_button.js.map

	/** Temporarily reduces marble restitution. */
	class ShockAbsorber$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/shockabsorber.dts";
	        this.pickUpName = (G$1.modification === 'gold') ? "Shock Absorber PowerUp" : "Anti-Recoil PowerUp";
	        this.an = G$1.modification !== 'gold';
	        this.sounds = ["pushockabsorbervoice.wav", "superbounceactive.wav"];
	    }
	    pickUp(marble) {
	        return marble.pickUpPowerUp(this);
	    }
	    use(marble) {
	        marble.enableShockAbsorber();
	    }
	    useCosmetically() { }
	}
	//# sourceMappingURL=shock_absorber.js.map

	/** Temporarily increase marble restitution. */
	class SuperBounce$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/superbounce.dts";
	        this.pickUpName = (G$1.modification === 'gold') ? "Super Bounce PowerUp" : "Marble Recoil PowerUp";
	        this.sounds = ["pusuperbouncevoice.wav", "forcefield.wav"];
	    }
	    pickUp(marble) {
	        return marble.pickUpPowerUp(this);
	    }
	    use(marble) {
	        marble.enableSuperBounce();
	    }
	    useCosmetically() { }
	}
	//# sourceMappingURL=super_bounce.js.map

	/** Gives the marble an upwards boost. */
	class SuperJump$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/superjump.dts";
	        this.pickUpName = (G$1.modification === 'gold') ? "Super Jump PowerUp" : "Jump Boost PowerUp";
	        this.sounds = ["pusuperjumpvoice.wav", "dosuperjump.wav"];
	    }
	    pickUp(marble) {
	        return marble.pickUpPowerUp(this);
	    }
	    use(marble) {
	        marble.body.linearVelocity.addScaledVector(marble.currentUp, 20); // Simply add to vertical velocity
	    }
	    useCosmetically(marble) {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(this.sounds[1], undefined, undefined, marble.body.position);
	            this.game.renderer.particles.createEmitter(superJumpParticleOptions, null, () => marble.body.position.clone());
	        }, `${this.id} ${marble.id}useCosmetic`, marble !== this.game.localPlayer.controlledMarble);
	    }
	}
	const superJumpParticleOptions = {
	    ejectionPeriod: 10,
	    ambientVelocity: new Vector3$1(0, 0, 0.05),
	    ejectionVelocity: 1 * 0.5,
	    velocityVariance: 0.25 * 0.5,
	    emitterLifetime: 1000,
	    inheritedVelFactor: 0.1,
	    particleOptions: {
	        texture: 'particles/twirl.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 90,
	        spinRandomMin: -90,
	        spinRandomMax: 90,
	        lifetime: 1000,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.25,
	        acceleration: 0,
	        colors: [{ r: 0, g: 0.5, b: 1, a: 0 }, { r: 0, g: 0.6, b: 1, a: 1 }, { r: 0, g: 0.6, b: 1, a: 0 }],
	        sizes: [0.25, 0.25, 0.5],
	        times: [0, 0.75, 1]
	    }
	};
	//# sourceMappingURL=super_jump.js.map

	/** Accelerates the marble. */
	class SuperSpeed$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/superspeed.dts";
	        this.pickUpName = (G$1.modification === 'gold') ? "Super Speed PowerUp" : "Speed Booster PowerUp";
	        this.sounds = ["pusuperspeedvoice.wav", "dosuperspeed.wav"];
	    }
	    pickUp(marble) {
	        return marble.pickUpPowerUp(this);
	    }
	    use(marble) {
	        let movementVector = new Vector3$1(1, 0, 0);
	        movementVector.applyAxisAngle(new Vector3$1(0, 0, 1), marble.currentControlState.yaw);
	        // Okay, so Super Speed directionality is a bit strange. In general, the direction is based on the normal vector of the last surface you had contact with.
	        let quat = marble.orientationQuat;
	        movementVector.applyQuaternion(quat);
	        let quat2 = new Quaternion$1();
	        quat2.setFromUnitVectors(marble.currentUp, marble.lastContactNormal); // Determine the necessary rotation to rotate the up vector to the contact normal.
	        movementVector.applyQuaternion(quat2); // ...then rotate the movement bonus vector by that amount.
	        marble.body.linearVelocity.addScaledVector(movementVector, 24.7); // Whirligig's determined value (ok it's actually 25 but we ain't changing it)
	    }
	    useCosmetically(marble) {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(this.sounds[1], undefined, undefined, marble.body.position);
	            this.game.renderer.particles.createEmitter(superSpeedParticleOptions, null, () => marble.body.position.clone());
	        }, `${this.id} ${marble.id}useCosmetic`, marble !== this.game.localPlayer.controlledMarble);
	    }
	}
	const superSpeedParticleOptions = {
	    ejectionPeriod: 5,
	    ambientVelocity: new Vector3$1(0, 0, 0.2),
	    ejectionVelocity: 1 * 0.5,
	    velocityVariance: 0.25 * 0.5,
	    emitterLifetime: 1100,
	    inheritedVelFactor: 0.25,
	    particleOptions: {
	        texture: 'particles/spark.png',
	        blending: BlendingType.Additive,
	        spinSpeed: 0,
	        spinRandomMin: 0,
	        spinRandomMax: 0,
	        lifetime: 1500,
	        lifetimeVariance: 150,
	        dragCoefficient: 0.25,
	        acceleration: 0,
	        colors: [{ r: 0.8, g: 0.8, b: 0, a: 0 }, { r: 0.8, g: 0.8, b: 0, a: 1 }, { r: 0.8, g: 0.8, b: 0, a: 0 }],
	        sizes: [0.25, 0.25, 1],
	        times: [0, 0.25, 1]
	    }
	};
	//# sourceMappingURL=super_speed.js.map

	/** Temporarily pauses the game clock. */
	class TimeTravel$1 extends PowerUp$1 {
	    constructor(element) {
	        super(element);
	        this.dtsPath = "shapes/items/timetravel.dts";
	        this.cooldownDuration = Infinity; // Won't respawn until the level is restarted
	        this.autoUse = true;
	        this.timeBonus = 5000;
	        this.sounds = ["putimetravelvoice.wav", "timetravelactive.wav"];
	        this.pickUpName = ''; // Modified on the fly based on the time bonus
	        if (element.timebonus) {
	            this.timeBonus = MisParser$1.parseNumber(element.timebonus);
	        }
	        if (element.timepenalty) {
	            this.timeBonus = -MisParser$1.parseNumber(element.timepenalty);
	        }
	        if (G$1.modification === 'gold') {
	            this.pickUpName = `${this.timeBonus / 1000} second Time Travel bonus`;
	        }
	        else {
	            this.pickUpName = `${Math.abs(this.timeBonus / 1000)} second Time ${this.timeBonus >= 0 ? 'Modifier' : 'Penalty'}`; // MBP calls them Time Penalty when they add time
	        }
	    }
	    pickUp() {
	        return true;
	    }
	    use(marble, t) {
	        let timeToRevert = (1 - t) / GAME_UPDATE_RATE;
	        // todo wtf is this replay shit
	        //if (this.level.replay.mode === 'playback') timeToRevert = this.level.replay.timeTravelTimeToRevert.get(this.id);
	        //else this.level.replay.timeTravelTimeToRevert.set(this.id, timeToRevert);
	        this.game.clock.addTimeTravelBonus(this.timeBonus / 1000, timeToRevert);
	        this.affect(this.game.clock);
	    }
	    useCosmetically(marble) {
	        if (marble === this.game.localPlayer.controlledMarble)
	            this.game.simulator.executeNonDuplicatableEvent(() => {
	                AudioManager$1.play(this.sounds[0]);
	            }, `${this.id}sound`, true);
	    }
	}
	//# sourceMappingURL=time_travel.js.map

	const POSSIBLE_RANDOM_POWER_UPS = [SuperJump$1, SuperSpeed$1, Helicopter$1, SuperBounce$1, ShockAbsorber$1, TimeTravel$1];
	/** A random power-up decides which power-up it acts like once it is picked up. */
	class RandomPowerUp$1 extends PowerUp$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/items/random.dts";
	        this.pickUpName = '';
	        this.lastInstance = null;
	        this.probeCount = 0;
	    }
	    pickUp(marble) {
	        // Loop until a power-up is found that can be picked up
	        while (true) {
	            // Choose a random power-up
	            let instance = this.game.randomPowerUpInstances[Math.floor(Util$1.seededRandom(this.game.seed + this.id, this.probeCount++) * this.game.randomPowerUpInstances.length)];
	            if (instance.pickUp(marble)) {
	                this.lastInstance = instance;
	                this.imitatePowerUp(instance);
	                marble.affect(instance);
	                return true;
	            }
	        }
	    }
	    use(marble, t) {
	        this.lastInstance.use(marble, t);
	    }
	    useCosmetically(marble) {
	        this.lastInstance.useCosmetically(marble);
	    }
	    imitatePowerUp(instance) {
	        this.pickUpName = instance.pickUpName;
	        this.customPickUpAlert = instance.customPickUpAlert;
	        this.an = instance.an;
	        this.autoUse = instance.autoUse;
	        this.cooldownDuration = instance.cooldownDuration;
	        this.sounds = instance.sounds;
	    }
	    getState() {
	        var _a, _b;
	        return {
	            ...super.getState(),
	            entityType: 'randomPowerUp',
	            probeCount: this.probeCount,
	            lastInstance: (_b = (_a = this.lastInstance) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null
	        };
	    }
	    getInitialState() {
	        return {
	            ...super.getInitialState(),
	            entityType: 'randomPowerUp',
	            probeCount: 0,
	            lastInstance: null
	        };
	    }
	    loadState(state, meta) {
	        this.probeCount = state.probeCount;
	        this.lastInstance = this.game.getEntityById(state.lastInstance);
	        if (this.lastInstance)
	            this.imitatePowerUp(this.lastInstance);
	        super.loadState(state, meta);
	    }
	}
	//# sourceMappingURL=random_power_up.js.map

	/** A bumper is a shape which knocks the marble away on contact. */
	class Bumper extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.lastContactTime = -Infinity;
	        this.shareNodeTransforms = false;
	    }
	    get animationDuration() {
	        return this.dts.sequences[0].duration;
	    }
	    onMarbleContact(collision, marble) {
	        let time = this.game.state.time;
	        this.lastContactTime = time;
	        // Set the velocity along the contact normal, but make sure it's capped
	        marble.setLinearVelocityInDirection(collision.normal, 15, false);
	        marble.slidingTimeout = 2; // Make sure we don't slide on the bumper after bouncing off it
	        this.affect(marble);
	        this.stateNeedsStore = true;
	        this.playSound(marble === this.game.localPlayer.controlledMarble);
	    }
	    render() {
	        let currentCompletion = Util$1.clamp((this.game.state.time - this.lastContactTime) / this.animationDuration, 0, 1);
	        // Override the keyframe for the "wiggle" effect
	        this.sequenceKeyframeOverride.set(this.dts.sequences[0], currentCompletion * (this.dts.sequences[0].numKeyframes - 1));
	        super.render();
	    }
	    getState() {
	        return {
	            entityType: 'bumper',
	            lastContactTime: this.lastContactTime
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'bumper',
	            lastContactTime: -Infinity
	        };
	    }
	    loadState(state) {
	        if (state.lastContactTime > this.lastContactTime)
	            this.playSound(true);
	        this.lastContactTime = state.lastContactTime;
	    }
	    playSound(safetyMargin) {
	        this.game.simulator.executeNonDuplicatableEvent(() => {
	            AudioManager$1.play(this.sounds[0], undefined, undefined, this.worldPosition);
	        }, `${this.id}sound`, safetyMargin);
	    }
	}
	//# sourceMappingURL=bumper.js.map

	/** A round bumper. */
	class RoundBumper$1 extends Bumper {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/bumpers/pball_round.dts";
	        this.sounds = ["bumperding1.wav"];
	    }
	}
	//# sourceMappingURL=round_bumper.js.map

	/** Sign used in MBP to show a direction. */
	class Sign$1 extends Shape$1 {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/signs/sign.dts";
	        if (element.datablock.toLowerCase() !== 'arrow') {
	            // Determine the direction to show
	            let direction = element.datablock.slice("Sign".length).toLowerCase();
	            switch (direction) {
	                case "":
	                    this.dtsPath = "shapes/signs/sign.dts";
	                    break;
	                case "down":
	                    this.dtsPath = "shapes/signs/signdown.dts";
	                    break;
	                case "up":
	                    this.dtsPath = "shapes/signs/signup.dts";
	                    break;
	                case "side":
	                    this.dtsPath = "shapes/signs/signside.dts";
	                    break;
	                case "downside":
	                    this.dtsPath = "shapes/signs/signdown-side.dts";
	                    break;
	                case "upside":
	                    this.dtsPath = "shapes/signs/signup-side.dts";
	                    break;
	            }
	        }
	    }
	}
	//# sourceMappingURL=sign.js.map

	/** A caution/danger sign. */
	class SignCaution$1 extends Shape$1 {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/signs/cautionsign.dts";
	        this.shareMaterials = false;
	        // Determine the type of the sign
	        let type = element.datablock.slice("SignCaution".length).toLowerCase();
	        switch (type) {
	            case "caution":
	                this.matNamesOverride["base.cautionsign"] = "caution.cautionsign";
	                break;
	            case "danger":
	                this.matNamesOverride["base.cautionsign"] = "danger.cautionsign";
	                break;
	        }
	    }
	}
	//# sourceMappingURL=sign_caution.js.map

	/** The flickering finish sign, usually above the finish pad. */
	class SignFinish$1 extends Shape$1 {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/signs/finishlinesign.dts";
	    }
	}
	//# sourceMappingURL=sign_finish.js.map

	/** A plain sign showing a direction. */
	class SignPlain$1 extends Shape$1 {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/signs/plainsign.dts";
	        this.shareMaterials = false;
	        // Determine the direction to show
	        let direction = element.datablock.slice("SignPlain".length).toLowerCase();
	        switch (direction) {
	            case "right":
	                this.matNamesOverride["base.plainsign"] = "right.plainsign";
	                break;
	            case "left":
	                this.matNamesOverride["base.plainsign"] = "left.plainsign";
	                break;
	            case "up":
	                this.matNamesOverride["base.plainsign"] = "up.plainsign";
	                break;
	            case "down":
	                this.matNamesOverride["base.plainsign"] = "down.plainsign";
	                break;
	        }
	    }
	}
	//# sourceMappingURL=sign_plain.js.map

	class Sky$1 extends Shape$1 {
	    constructor(type) {
	        super();
	        this.collideable = false;
	        this.dtsPath = `shapes/skies/${type}/${type}.dts`;
	    }
	}
	//# sourceMappingURL=sky.js.map

	/** Blows the marble away, but not much. */
	class SmallDuctFan$1 extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/ductfan.dts";
	        this.sounds = ["fan_loop.wav"];
	        this.addConicForce(5, 2.617, 10);
	    }
	    async onLevelStart() {
	        this.soundSource = AudioManager$1.createAudioSource(this.sounds[0], AudioManager$1.soundGain, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}
	//# sourceMappingURL=small_duct_fan.js.map

	/** Sucks the marble in and then slings it upwards. */
	class Tornado$1 extends ForceShape {
	    constructor() {
	        super();
	        this.dtsPath = "shapes/hazards/tornado.dts";
	        this.collideable = false;
	        this.sounds = ["tornado.wav"];
	        this.addSphericalForce(8, -60);
	        this.addSphericalForce(3, 60);
	        this.addFieldForce(3, new Vector3$1(0, 0, 150)); // The upwards force is always in the same direction regardless of tornado orientation
	    }
	    async onLevelStart() {
	        this.soundSource = AudioManager$1.createAudioSource(this.sounds[0], AudioManager$1.soundGain, this.worldPosition);
	        this.soundSource.setLoop(true);
	        this.soundSource.play();
	        await this.soundSource.promise;
	    }
	}
	//# sourceMappingURL=tornado.js.map

	const RESET_TIME$1 = 5;
	/** Trap doors open on contact. */
	class TrapDoor$1 extends Shape$1 {
	    constructor(element) {
	        super();
	        this.dtsPath = "shapes/hazards/trapdoor.dts";
	        this.hasNonVisualSequences = true;
	        this.shareNodeTransforms = false;
	        this.lastContactTime = -Infinity;
	        /** The time it takes from the moment of touching the trapdoor to it opening. */
	        this.timeout = 0;
	        this.lastCompletion = 0;
	        this.sounds = ['trapdooropen.wav'];
	        if (element.timeout)
	            this.timeout = MisParser$1.parseNumber(element.timeout) / 1000;
	    }
	    get animationDuration() {
	        return this.dts.sequences[0].duration;
	    }
	    update(onlyVisual) {
	        let currentCompletion = this.getCurrentCompletion();
	        // Override the keyframe
	        this.sequenceKeyframeOverride.set(this.dts.sequences[0], currentCompletion * (this.dts.sequences[0].numKeyframes - 1));
	        super.update(onlyVisual);
	        if (onlyVisual)
	            return;
	        let direction = Math.sign(currentCompletion - this.lastCompletion);
	        if (direction !== 0 && direction !== this.lastDirection) {
	            // If the direction has changed, play the sound
	            this.game.simulator.executeNonDuplicatableEvent(() => {
	                AudioManager$1.play(this.sounds[0], 1, AudioManager$1.soundGain, this.worldPosition);
	            }, `${this.id}sound`, true);
	        }
	        if (this.lastCompletion !== currentCompletion || this.lastDirection !== direction) {
	            this.lastCompletion = currentCompletion;
	            this.lastDirection = direction;
	            this.internalStateNeedsStore = true;
	        }
	    }
	    /** Gets the current completion of the trapdoor openness. 0 = closed, 1 = open. */
	    getCurrentCompletion() {
	        let elapsed = this.game.state.time - this.lastContactTime;
	        let completion = Util$1.clamp(elapsed / this.animationDuration, 0, 1);
	        if (elapsed > RESET_TIME$1)
	            completion = Util$1.clamp(1 - (elapsed - RESET_TIME$1) / this.animationDuration, 0, 1);
	        return completion;
	    }
	    onMarbleContact(collision, marble) {
	        this.affect(marble);
	        let time = this.game.state.time;
	        if (time - this.lastContactTime <= 0)
	            return; // The trapdoor is queued to open, so don't do anything.
	        let currentCompletion = this.getCurrentCompletion();
	        // Set the last contact time accordingly so that the trapdoor starts closing (again)
	        this.lastContactTime = time - currentCompletion * this.animationDuration;
	        if (currentCompletion === 0)
	            this.lastContactTime += this.timeout;
	        this.stateNeedsStore = true;
	        marble.affect(this);
	    }
	    getState() {
	        return {
	            entityType: 'trapDoor',
	            lastContactTime: this.lastContactTime
	        };
	    }
	    getInitialState() {
	        return {
	            entityType: 'trapDoor',
	            lastContactTime: -Infinity
	        };
	    }
	    loadState(state) {
	        this.lastContactTime = state.lastContactTime;
	    }
	    getInternalState() {
	        return {
	            ...super.getInternalState(),
	            lastCompletion: this.lastCompletion,
	            lastDirection: this.lastDirection
	        };
	    }
	    loadInternalState(state) {
	        super.loadInternalState(state);
	        this.lastCompletion = state.lastCompletion;
	        this.lastDirection = state.lastDirection;
	    }
	}
	//# sourceMappingURL=trap_door.js.map

	/** A triangle-shaped bumper. */
	class TriangleBumper$1 extends Bumper {
	    constructor() {
	        super(...arguments);
	        this.dtsPath = "shapes/bumpers/pball_tri.dts";
	        this.sounds = ["bumper1.wav"];
	    }
	}
	//# sourceMappingURL=triangle_bumper.js.map

	const MBP_SONGS$1 = ['astrolabe.ogg', 'endurance.ogg', 'flanked.ogg', 'grudge.ogg', 'mbp old shell.ogg', 'quiet lab.ogg', 'rising temper.ogg', 'seaside revisited.ogg', 'the race.ogg'];
	class GameInitter {
	    constructor(game) {
	        /** Holds data shared between multiple shapes with the same constructor and .dts path. */
	        this.sharedShapeData = new Map();
	        this.game = game;
	        this.loadingState = { loaded: 0, total: 0 };
	    }
	    /** Returns how much percent the game has finished loading. */
	    getLoadingCompletion() {
	        return this.loadingState.total ? this.loadingState.loaded / this.loadingState.total : 0;
	    }
	    async init() {
	        var _a;
	        let { game } = this;
	        let { renderer } = game;
	        // Scan the mission for elements to determine required loading effort
	        for (let element of game.mission.allElements) {
	            if ([MissionElementType$1.InteriorInstance, MissionElementType$1.Item, MissionElementType$1.PathedInterior, MissionElementType$1.StaticShape, MissionElementType$1.TSStatic].includes(element._type)) {
	                this.loadingState.total++;
	                // Override the end pad element. We do this because only the last finish pad element will actually do anything.
	                if (element._type === MissionElementType$1.StaticShape && ((_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'endpad')
	                    this.endPadElement = element;
	            }
	        }
	        this.loadingState.total += 6 /*+ 1*/ + 3 + 6 + 1; // For the scene, marble, UI, sounds (includes music!), and scene compile
	        await renderer.init();
	        /*
	        await this.initMarbles();
	        this.loadingState.loaded += 1;
	        */
	        let soundPromise = this.initSounds();
	        await this.addSimGroup(game.mission.root);
	        for (let interior of game.interiors)
	            game.addEntity(interior);
	        for (let shape of game.shapes)
	            game.addEntity(shape);
	        for (let trigger of game.triggers)
	            game.addEntity(trigger);
	        let maxEntityId = Math.max(...game.entities.map(x => x.id));
	        this.auxEntityId = maxEntityId + 1;
	        game.clock = new Clock(game, this.auxEntityId++);
	        game.addEntity(game.clock);
	        game.finishState = new FinishState(game, this.auxEntityId++);
	        game.addEntity(game.finishState);
	        if (game.shapes.some(x => x instanceof RandomPowerUp$1))
	            await this.initRandomPowerUpInstances();
	        await renderer.initHud();
	        this.loadingState.loaded += 3;
	        await soundPromise;
	        this.loadingState.loaded += 6;
	        renderer.scene.compile();
	        this.loadingState.loaded += 1;
	        game.orbitSphere = this.computeOrbitSphere();
	    }
	    async initSounds() {
	        let { game } = this;
	        let musicFileName;
	        if (game.mission.modification === 'ultra') {
	            musicFileName = 'tim trance.ogg'; // ALWAYS play this banger
	            game.originalMusicName = musicFileName;
	        }
	        else if (G$1.modification !== 'gold' && game.mission.missionInfo.music && game.mission.missionInfo.music.toLowerCase() !== 'pianoforte.ogg') {
	            musicFileName = game.mission.missionInfo.music.toLowerCase();
	            game.originalMusicName = musicFileName;
	        }
	        else {
	            if (game.mission.modification === 'gold') {
	                // Play the song based on the level index
	                let levelIndex = G$1.menu.levelSelect.currentMissionArray.indexOf(game.mission);
	                musicFileName = ['groovepolice.ogg', 'classic vibe.ogg', 'beach party.ogg'][(levelIndex + 1) % 3]; // The default music choice is based off of level index
	                // Yes, the extra space is intentional
	                game.originalMusicName = ['groove police.ogg', 'classic vibe.ogg', 'beach party.ogg'][(levelIndex + 1) % 3];
	            }
	            else {
	                // Play a random *MBP* song
	                musicFileName = Util$1.randomFromArray(MBP_SONGS$1);
	                game.originalMusicName = musicFileName;
	            }
	        }
	        if (G$1.modification === 'platinum')
	            musicFileName = 'music/' + musicFileName;
	        let toLoad = ["spawn.wav", "ready.wav", "set.wav", "go.wav", "whoosh.wav", musicFileName];
	        if (isFinite(game.mission.qualifyTime) && G$1.modification === 'platinum')
	            toLoad.push("alarm.wav", "alarm_timeout.wav", "infotutorial.wav");
	        try {
	            await AudioManager$1.loadBuffers(toLoad);
	        }
	        catch (e) {
	            // Something died, maybe it was the music, try replacing it with a song we know exists
	            let newMusic = Util$1.randomFromArray(MBP_SONGS$1);
	            game.originalMusicName = newMusic;
	            toLoad[toLoad.indexOf(musicFileName)] = 'music/' + newMusic;
	            musicFileName = 'music/' + newMusic;
	            await AudioManager$1.loadBuffers(toLoad);
	        }
	        game.music = AudioManager$1.createAudioSource(musicFileName, AudioManager$1.musicGain);
	        game.music.setLoop(true);
	        await game.music.promise;
	    }
	    /** Adds all elements within a sim group. */
	    async addSimGroup(simGroup) {
	        let { game } = this;
	        let { simulator, renderer } = game;
	        // Check if it's a pathed interior group
	        if (simGroup.elements.find((element) => element._type === MissionElementType$1.PathedInterior)) {
	            // Create the pathed interior
	            let pathedInterior = await PathedInterior$1.createFromSimGroup(simGroup, game);
	            if (!pathedInterior)
	                return;
	            renderer.scene.add(pathedInterior.mesh);
	            if (pathedInterior.hasCollision)
	                simulator.world.add(pathedInterior.body);
	            for (let trigger of pathedInterior.triggers) {
	                simulator.world.add(trigger.body);
	                game.triggers.push(trigger);
	            }
	            return;
	        }
	        let promises = [];
	        for (let element of simGroup.elements) {
	            switch (element._type) {
	                case MissionElementType$1.SimGroup:
	                    promises.push(this.addSimGroup(element));
	                    break;
	                case MissionElementType$1.InteriorInstance:
	                    promises.push(this.addInterior(element));
	                    break;
	                case MissionElementType$1.StaticShape:
	                case MissionElementType$1.Item:
	                    promises.push(this.addShape(element));
	                    break;
	                case MissionElementType$1.Trigger:
	                    promises.push(this.addTrigger(element));
	                    break;
	                case MissionElementType$1.TSStatic:
	                    promises.push(this.addTSStatic(element));
	                    break;
	                case MissionElementType$1.ParticleEmitterNode:
	                    this.addParticleEmitterNode(element);
	                    break;
	            }
	        }
	        await Promise.all(promises);
	    }
	    async addInterior(element) {
	        let { game } = this;
	        let { simulator, renderer } = game;
	        let { dif: difFile, path } = await game.mission.getDif(element.interiorfile);
	        if (!difFile)
	            return;
	        let interior = new Interior$1(difFile, path, game);
	        game.interiors.push(interior);
	        await Util$1.wait(10); // fixme See shapes for the meaning of this hack
	        await interior.init(element._id);
	        renderer.scene.add(interior.mesh);
	        let interiorPosition = MisUtils.parseVector3(element.position);
	        let interiorRotation = MisUtils.parseRotation(element.rotation);
	        let interiorScale = MisUtils.parseVector3(element.scale);
	        let hasCollision = interiorScale.x !== 0 && interiorScale.y !== 0 && interiorScale.z !== 0; // Don't want to add buggy geometry
	        // Fix zero-volume interiors so they receive correct lighting
	        if (interiorScale.x === 0)
	            interiorScale.x = 0.0001;
	        if (interiorScale.y === 0)
	            interiorScale.y = 0.0001;
	        if (interiorScale.z === 0)
	            interiorScale.z = 0.0001;
	        interior.setTransform(interiorPosition, interiorRotation, interiorScale);
	        if (hasCollision)
	            simulator.world.add(interior.body);
	    }
	    async addShape(element) {
	        var _a;
	        let { game } = this;
	        let { simulator, renderer } = game;
	        let shape;
	        // Add the correct shape based on type
	        let dataBlockLowerCase = (_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	        if (!dataBlockLowerCase) ;
	        else if (dataBlockLowerCase === "startpad")
	            shape = new StartPad$1();
	        else if (dataBlockLowerCase === "endpad")
	            shape = new EndPad$1(element === this.endPadElement);
	        else if (dataBlockLowerCase === "signfinish")
	            shape = new SignFinish$1();
	        else if (dataBlockLowerCase.startsWith("signplain"))
	            shape = new SignPlain$1(element);
	        else if (dataBlockLowerCase.startsWith("gemitem"))
	            shape = new Gem$1(), game.totalGems++;
	        else if (dataBlockLowerCase === "superjumpitem")
	            shape = new SuperJump$1(element);
	        else if (dataBlockLowerCase.startsWith("signcaution"))
	            shape = new SignCaution$1(element);
	        else if (dataBlockLowerCase === "superbounceitem")
	            shape = new SuperBounce$1(element);
	        else if (dataBlockLowerCase === "roundbumper")
	            shape = new RoundBumper$1();
	        else if (dataBlockLowerCase === "trianglebumper")
	            shape = new TriangleBumper$1();
	        else if (dataBlockLowerCase === "helicopteritem")
	            shape = new Helicopter$1(element);
	        else if (dataBlockLowerCase === "ductfan")
	            shape = new DuctFan$1();
	        else if (dataBlockLowerCase === "smallductfan")
	            shape = new SmallDuctFan$1();
	        else if (dataBlockLowerCase === "antigravityitem")
	            shape = new AntiGravity$1(element);
	        else if (dataBlockLowerCase === "norespawnantigravityitem")
	            shape = new AntiGravity$1(element, true);
	        else if (dataBlockLowerCase === "landmine")
	            shape = new LandMine$1();
	        else if (dataBlockLowerCase === "shockabsorberitem")
	            shape = new ShockAbsorber$1(element);
	        else if (dataBlockLowerCase === "superspeeditem")
	            shape = new SuperSpeed$1(element);
	        else if (["timetravelitem", "timepenaltyitem"].includes(dataBlockLowerCase))
	            shape = new TimeTravel$1(element);
	        else if (dataBlockLowerCase === "tornado")
	            shape = new Tornado$1();
	        else if (dataBlockLowerCase === "trapdoor")
	            shape = new TrapDoor$1(element);
	        else if (dataBlockLowerCase === "oilslick")
	            shape = new Oilslick$1();
	        else if (dataBlockLowerCase === "pushbutton")
	            shape = new PushButton$1();
	        else if (dataBlockLowerCase.startsWith("sign") || dataBlockLowerCase === "arrow")
	            shape = new Sign$1(element);
	        else if (dataBlockLowerCase === "magnet")
	            shape = new Magnet$1();
	        else if (dataBlockLowerCase === "nuke")
	            shape = new Nuke$1();
	        else if (dataBlockLowerCase === "checkpoint")
	            shape = new Checkpoint$1();
	        else if (dataBlockLowerCase === "easteregg")
	            shape = new EasterEgg$1(element);
	        else if (dataBlockLowerCase === "randompowerupitem")
	            shape = new RandomPowerUp$1(element);
	        else if (["clear", "cloudy", "dusk", "wintry"].includes(dataBlockLowerCase))
	            shape = new Sky$1(dataBlockLowerCase);
	        else if (/glass_\d+shape/.test(dataBlockLowerCase))
	            shape = new Glass$1(dataBlockLowerCase);
	        else if (dataBlockLowerCase === "blastitem")
	            shape = new Blast$1(element);
	        else if (dataBlockLowerCase === "megamarbleitem")
	            shape = new MegaMarble$1(element);
	        if (!shape)
	            return;
	        game.shapes.push(shape);
	        // This is a bit hacky, but wait a short amount so that all shapes will have been created by the time this codepath continues. This is necessary for correct sharing of data between shapes.
	        await Util$1.wait(10);
	        await shape.init(game, element);
	        // Set the shape's transform
	        let shapePosition = MisUtils.parseVector3(element.position);
	        let shapeRotation = MisUtils.parseRotation(element.rotation);
	        let shapeScale = MisUtils.parseVector3(element.scale);
	        // Apparently we still do collide with zero-volume shapes
	        if (shapeScale.x === 0)
	            shapeScale.x = 0.0001;
	        if (shapeScale.y === 0)
	            shapeScale.y = 0.0001;
	        if (shapeScale.z === 0)
	            shapeScale.z = 0.0001;
	        shape.setTransform(shapePosition, shapeRotation, shapeScale);
	        renderer.scene.add(shape.group);
	        for (let body of shape.bodies)
	            simulator.world.add(body);
	        for (let collider of shape.colliders)
	            simulator.world.add(collider.body);
	    }
	    /** Initiates all power-ups that can possibly be spawned by a Random PowerUp. */
	    async initRandomPowerUpInstances() {
	        this.game.randomPowerUpInstances = [];
	        for (let Class of POSSIBLE_RANDOM_POWER_UPS) {
	            let instance = new Class({});
	            await instance.init(this.game, { _id: this.auxEntityId++ });
	            this.game.randomPowerUpInstances.push(instance);
	            this.game.addEntity(instance);
	            this.game.shapes.push(instance);
	        }
	    }
	    async addTrigger(element) {
	        var _a;
	        let { game } = this;
	        let { simulator } = game;
	        let trigger;
	        // Create a trigger based on type
	        let dataBlockLowerCase = (_a = element.datablock) === null || _a === void 0 ? void 0 : _a.toLowerCase();
	        if (dataBlockLowerCase === "outofboundstrigger") {
	            trigger = new OutOfBoundsTrigger$1(element, game);
	        }
	        else if (dataBlockLowerCase === "inboundstrigger") {
	            trigger = new InBoundsTrigger$1(element, game);
	        }
	        else if (dataBlockLowerCase === "helptrigger") {
	            trigger = new HelpTrigger$1(element, game);
	        }
	        else if (dataBlockLowerCase === "teleporttrigger") {
	            trigger = new TeleportTrigger$1(element, game);
	        }
	        else if (dataBlockLowerCase === "destinationtrigger") {
	            trigger = new DestinationTrigger$1(element, game);
	        }
	        else if (dataBlockLowerCase === "checkpointtrigger") {
	            trigger = new CheckpointTrigger$1(element, game);
	        }
	        if (!trigger)
	            return;
	        game.triggers.push(trigger);
	        simulator.world.add(trigger.body);
	        await trigger.init();
	    }
	    /** Adds a TSStatic (totally static shape) to the world. */
	    async addTSStatic(element) {
	        let { game } = this;
	        let { simulator, renderer } = game;
	        let shape = new Shape$1();
	        let shapeName = element.shapename.toLowerCase();
	        let index = shapeName.indexOf('data/');
	        if (index === -1)
	            return;
	        shape.dtsPath = shapeName.slice(index + 'data/'.length);
	        shape.isTSStatic = true;
	        shape.shareId = 1;
	        if (shapeName.includes('colmesh'))
	            shape.receiveShadows = false; // Special case for colmesh
	        game.shapes.push(shape);
	        await Util$1.wait(10); // Same hack as for regular shapes
	        try {
	            await shape.init(game, element);
	        }
	        catch (e) {
	            console.error("Error in creating TSStatic, skipping it for now.", e);
	            Util$1.removeFromArray(game.shapes, shape);
	            return;
	        }
	        shape.setTransform(MisUtils.parseVector3(element.position), MisUtils.parseRotation(element.rotation), MisUtils.parseVector3(element.scale));
	        renderer.scene.add(shape.group);
	        if (shape.worldScale.x !== 0 && shape.worldScale.y !== 0 && shape.worldScale.z !== 0) {
	            // Only add the shape if it actually has any volume
	            for (let body of shape.bodies)
	                simulator.world.add(body);
	            for (let collider of shape.colliders)
	                simulator.world.add(collider.body);
	        }
	    }
	    /** Adds a ParticleEmitterNode to the world. */
	    addParticleEmitterNode(element) {
	        // Yeah I know I could define it outside but Rollup was having a moment
	        const particleEmitterMap = {
	            MarbleBounceEmitter: bounceParticleOptions,
	            MarbleTrailEmitter: particleNodeEmittersEmitterOptions.MarbleTrailEmitter,
	            MarbleSuperJumpEmitter: Object.assign(ParticleEmitter.cloneOptions(superJumpParticleOptions), {
	                emitterLifetime: 5000,
	                ambientVelocity: new Vector3$1(-0.3, 0, -0.5)
	            }),
	            MarbleSuperSpeedEmitter: Object.assign(ParticleEmitter.cloneOptions(superSpeedParticleOptions), {
	                emitterLifetime: 5000,
	                ambientVelocity: new Vector3$1(-0.5, 0, -0.5)
	            }),
	            LandMineEmitter: particleNodeEmittersEmitterOptions.LandMineEmitter,
	            LandMineSmokeEmitter: landMineSmokeParticle,
	            LandMineSparkEmitter: landMineSparksParticle,
	            NukeEmitter: particleNodeEmittersEmitterOptions.LandMineEmitter,
	            NukeSmokeEmitter: nukeSmokeParticle,
	            NukeSparkEmitter: nukeSparksParticle,
	            FireWorkSmokeEmitter: fireworkSmoke,
	            RedFireWorkSparkEmitter: redSpark,
	            RedFireWorkTrailEmitter: redTrail,
	            BlueFireWorkSparkEmitter: blueSpark,
	            BlueFireWorkTrailEmitter: blueTrail
	        };
	        let emitterOptions = particleEmitterMap[element.emitter];
	        if (!emitterOptions)
	            return;
	        this.game.renderer.particles.createEmitter(emitterOptions, MisUtils.parseVector3(element.position));
	    }
	    /** Adds a Balloon entity to the world. They're just a testing entity, fun to play around with. */
	    async addBalloon() {
	        let balloon = new Balloon(this.game, this.auxEntityId + 1);
	        await balloon.init();
	        this.game.addEntity(balloon);
	    }
	    computeOrbitSphere() {
	        let triggerAabb = new Box3();
	        let nonTriggerAabb = new Box3();
	        for (let body of this.game.simulator.world.bodies) {
	            if (this.game.shapes.some(x => x instanceof Sky$1 && x.bodies.includes(body)))
	                continue;
	            for (let shape of body.shapes) {
	                let trigger = this.game.triggers.find(x => x.body === body);
	                if (!trigger) {
	                    nonTriggerAabb.expandByPoint(shape.boundingBox.min);
	                    nonTriggerAabb.expandByPoint(shape.boundingBox.max);
	                }
	                else if (trigger instanceof InBoundsTrigger$1) {
	                    triggerAabb.expandByPoint(shape.boundingBox.min);
	                    triggerAabb.expandByPoint(shape.boundingBox.max);
	                }
	            }
	        }
	        let aabb = triggerAabb.isEmpty() ? nonTriggerAabb : triggerAabb.intersect(nonTriggerAabb);
	        if (aabb.isEmpty()) {
	            aabb = nonTriggerAabb;
	            if (aabb.isEmpty()) {
	                return { center: new Vector3$1(), radius: 1 };
	            }
	        }
	        return {
	            center: aabb.getCenter(new Vector3$1()),
	            radius: aabb.getSize(new Vector3$1()).length() / 2
	        };
	    }
	}

	/** Represents a simple ambient light that lights up everything uniformly. */
	class AmbientLight$1 {
	    constructor(color) {
	        this.color = color;
	    }
	}
	//# sourceMappingURL=ambient_light.js.map

	/** Represents a light source that casts light globally in a specific direction. Can cast shadows. */
	class DirectionalLight$1 {
	    constructor(renderer, color, direction) {
	        this.camera = null;
	        this.renderer = renderer;
	        this.color = color;
	        this.direction = direction;
	    }
	    /** Turns on shadow casting for this light and sets up the necessary textures and buffers. */
	    enableShadowCasting(textureResolution, camera) {
	        Util$1.assert(Util$1.isPowerOf2(textureResolution)); // We never know 😓
	        let { gl } = this.renderer;
	        this.camera = camera;
	        // Create the texture that will store the depth information
	        let depthTexture = gl.createTexture();
	        let depthComponent = (gl instanceof WebGLRenderingContext) ? gl.DEPTH_COMPONENT : gl.DEPTH_COMPONENT32F;
	        let type = (gl instanceof WebGLRenderingContext) ? gl.UNSIGNED_INT : gl.FLOAT;
	        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, depthComponent, textureResolution, textureResolution, 0, gl.DEPTH_COMPONENT, type, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        this.depthTexture = depthTexture;
	        // Create the framebuffer
	        let depthFramebuffer = gl.createFramebuffer();
	        gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
	        this.depthFramebuffer = depthFramebuffer;
	        // "For a bunch of reasons we also need to create a color texture and attach it as a color attachment even though we won't actually use it."
	        let unusedTexture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, unusedTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureResolution, textureResolution, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        this.colorTexture = unusedTexture;
	        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, unusedTexture, 0);
	        this.depthTexture = depthTexture;
	        this.textureResolution = textureResolution;
	    }
	    /**
	     * Updates the position of the shadow camera.
	     * @param offset Specifies the offset in the direction of the light from `position`.
	     */
	    updateCamera(position, offset) {
	        if (!this.camera)
	            return;
	        this.camera.position.copy(position.clone().addScaledVector(this.direction, offset));
	        this.camera.lookAt(this.camera.position.clone().add(this.direction));
	        this.camera.updateMatrixWorld();
	    }
	    /** Renders to the shadow map with all shadow casters from the given scene. */
	    renderShadowMap(scene) {
	        if (!this.camera)
	            return;
	        let { gl, shadowMapProgram } = this.renderer;
	        gl.depthMask(true);
	        gl.bindFramebuffer(gl.FRAMEBUFFER, this.depthFramebuffer);
	        gl.viewport(0, 0, this.textureResolution, this.textureResolution);
	        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	        shadowMapProgram.use();
	        gl.uniformMatrix4fv(shadowMapProgram.getUniformLocation('viewMatrix'), false, new Float32Array(this.camera.matrixWorldInverse.elements));
	        gl.uniformMatrix4fv(shadowMapProgram.getUniformLocation('projectionMatrix'), false, new Float32Array(this.camera.projectionMatrix.elements));
	        gl.uniform1i(shadowMapProgram.getUniformLocation('meshInfos'), 7);
	        // Draw static meshes
	        shadowMapProgram.bindVertexBufferGroup(scene.staticBufferGroup);
	        this.renderer.bindMeshInfoTexture(scene.staticMeshInfoTexture, shadowMapProgram);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, scene.staticShadowCasterIndexBuffer);
	        gl.drawElements(gl.TRIANGLES, scene.staticShadowCasterIndices.length, gl.UNSIGNED_INT, 0); // A single draw call is enough
	        // Draw dynamic meshes
	        shadowMapProgram.bindVertexBufferGroup(scene.dynamicBufferGroup);
	        this.renderer.bindMeshInfoTexture(scene.dynamicMeshInfoTexture, shadowMapProgram);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, scene.dynamicShadowCasterIndexBuffer);
	        gl.drawElements(gl.TRIANGLES, scene.dynamicShadowCasterIndices.length, gl.UNSIGNED_INT, 0);
	    }
	    /** Binds the shadow map to texture unit 2. */
	    bindShadowMap() {
	        let { gl } = this.renderer;
	        this.renderer.bindTexture(this.depthTexture, 2, gl.TEXTURE_2D);
	    }
	    dispose() {
	        if (!this.camera)
	            return;
	        let { gl } = this.renderer;
	        gl.deleteTexture(this.depthTexture);
	        gl.deleteTexture(this.colorTexture);
	        gl.deleteFramebuffer(this.depthFramebuffer);
	    }
	}
	//# sourceMappingURL=directional_light.js.map

	var materialVert = "precision highp float;\r\nprecision highp int;\r\n\r\n#include <definitions>\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec4 tangent;\r\nattribute vec2 uv;\r\nattribute float meshInfoIndex;\r\n\r\nuniform highp sampler2D meshInfos; // This is where mesh transformation and other things about the mesh are stored in\r\nuniform int meshInfoTextureWidth;\r\nuniform int meshInfoTextureHeight;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 inverseProjectionMatrix;\r\nuniform bool skipTransparent;\r\nuniform mat4 directionalLightTransform;\r\nuniform vec3 eyePosition;\r\nuniform float materialOpacity;\r\n\r\nvarying vec4 vPosition;\r\nvarying vec3 vNormal;\r\nvarying vec2 vUv;\r\nvarying float vOpacity;\r\nvarying vec4 vShadowPosition;\r\nvarying vec3 vReflect;\r\nvarying mat3 vTbn;\r\nvarying vec4 vTangent;\r\nvarying float vFragDepth;\r\nvarying float vIsPerspective;\r\nvarying vec3 eyeDirection;\r\n\r\n#ifdef IS_WEBGL1\r\n\tmat3 transpose(mat3 inMatrix) {\r\n\t\tvec3 i0 = inMatrix[0];\r\n\t\tvec3 i1 = inMatrix[1];\r\n\t\tvec3 i2 = inMatrix[2];\r\n\r\n\t\tmat3 outMatrix = mat3(\r\n\t\t\tvec3(i0.x, i1.x, i2.x),\r\n\t\t\tvec3(i0.y, i1.y, i2.y),\r\n\t\t\tvec3(i0.z, i1.z, i2.z)\r\n\t\t);\r\n\r\n\t\treturn outMatrix;\r\n\t}\r\n\r\n\t// http://www.thetenthplanet.de/archives/1180\r\n\tmat3 inverse(mat3 M) {\r\n\t\tmat3 M_t = transpose(M);\r\n\t\tfloat det = dot(cross(M_t[0], M_t[1]), M_t[2]);\r\n\t\tmat3 adjugate = mat3(cross(M_t[1], M_t[2]), cross(M_t[2], M_t[0]), cross(M_t[0], M_t[1]));\r\n\t\treturn adjugate / det;\r\n\t}\r\n#endif\r\n\r\n// _ here because on some systems, \"mod\" is already defined?\r\nint _mod(int a, int n) {\r\n\t#ifdef IS_WEBGL1\r\n\t\treturn a - n * (a / n);\r\n\t#else\r\n\t\treturn a % n;\r\n\t#endif\r\n}\r\n\r\n// Gets the mesh info for the mesh at a specific index. The mesh info contains its transformation and other things.\r\nmat4 getMeshInfo(int index) {\r\n\t// Figure out where we need to sample the texture\r\n\tivec2 coords = ivec2(\r\n\t\t_mod(4 * index, meshInfoTextureWidth),\r\n\t\t(4 * index) / meshInfoTextureWidth\r\n\t);\r\n\r\n\t#ifdef IS_WEBGL1\r\n\t\t// Primitive way, sample with texture coordinates\r\n\t\treturn mat4(\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(0, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(1, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(2, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight)),\r\n\t\t\ttexture2D(meshInfos, vec2(coords + ivec2(3, 0)) / vec2(meshInfoTextureWidth, meshInfoTextureHeight))\r\n\t\t);\r\n\t#else\r\n\t\t// Better way, sample with pixel coordinates\r\n\t\treturn mat4(\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(0, 0), 0),\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(1, 0), 0),\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(2, 0), 0),\r\n\t\t\ttexelFetch(meshInfos, coords + ivec2(3, 0), 0)\r\n\t\t);\r\n\t#endif\r\n}\r\n\r\nbool isPerspectiveMatrix(mat4 m) {\r\n\treturn m[2][3] == -1.0; // Taken from three.js, no clue how this works\r\n}\r\n\r\nvoid main() {\r\n\t#ifdef IS_SKY\r\n\t\t// https://gamedev.stackexchange.com/a/60377\r\n\t\tmat4 inverseProjection = inverseProjectionMatrix;\r\n\t\tmat3 inverseModelView = transpose(mat3(viewMatrix));\r\n\t\tvec3 unprojected = (inverseProjection * vec4(position, 1.0)).xyz;\r\n\t\teyeDirection = inverseModelView * unprojected;\r\n\t\t\r\n\t\tgl_Position = vec4(position, 1.0);\r\n\t#else\r\n\t\tmat4 meshInfo = getMeshInfo(int(meshInfoIndex + 0.1)); // + 0.1 to make sure it casts correctly, lol\r\n\t\tmat4 transform = meshInfo;\r\n\t\ttransform[0][3] = 0.0; // The last row of a transformation matrix is always the same, so set it to what it should be\r\n\t\ttransform[1][3] = 0.0;\r\n\t\ttransform[2][3] = 0.0;\r\n\t\ttransform[3][3] = 1.0;\r\n\t\tfloat opacity = meshInfo[0][3];\r\n\t\tint meshFlags = int(meshInfo[1][3]);\r\n\r\n\t\topacity *= materialOpacity;\r\n\t\tvOpacity = opacity;\r\n\r\n\t\tif (skipTransparent && opacity < 1.0) {\r\n\t\t\t// The object isn't fully opaque, so skip it\r\n\t\t\tgl_Position = vec4(0.0);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvec4 worldPosition = transform * vec4(position, 1.0);\r\n\t\tvPosition = worldPosition;\r\n\r\n\t\tmat4 mvp = projectionMatrix * viewMatrix * transform; // Combine them into a single matrix to reduce possible precision errors\r\n\t\tgl_Position = mvp * vec4(position, 1.0);\r\n\r\n\t\tvUv = uv;\r\n\t\t#ifdef FLIP_Y\r\n\t\t\tvUv.y = 1.0 - vUv.y;\r\n\t\t#endif\r\n\r\n\t\t// Compute the transformation matrix for normals (not tangents, tho!)\r\n\t\t// Note that when the transformation doesn't involve any scaling, the upper mat3 part is orthonormal meaning its inverse is equal to its transpose. In this case, normalTransform == mat3(transform).\r\n\t\tmat3 normalTransform = transpose(inverse(mat3(transform)));\r\n\r\n\t\tvec3 transformedNormal = normalTransform * normal;\r\n\t\t#ifdef NORMALIZE_NORMALS\r\n\t\t\t// Many normals, like those used in the tornado, are actually not normalized\r\n\t\t\ttransformedNormal = normalize(transformedNormal);\r\n\t\t#endif\r\n\t\tvNormal = transformedNormal;\r\n\r\n\t\tvTangent = tangent; // Needed so that it doesn't get optimized out (fucks with vertex attributes somehow)\r\n\t\t#ifdef USE_NORMAL_MAP\r\n\t\t\tvec3 N = transformedNormal;\r\n\t\t\tvec3 T = normalize((transform * vec4(tangent.xyz, 0.0)).xyz);\r\n\t\t\t// re-orthogonalize T with respect to N\r\n\t\t\tT = normalize(T - dot(T, N) * N);\r\n\t\t\t// then retrieve perpendicular vector B with the cross product of T and N\r\n\t\t\tvec3 B = cross(N, T) * tangent.w;\r\n\t\t\tmat3 tbn = mat3(T, B, N);\r\n\t\t\tvTbn = tbn;\r\n\t\t#endif\r\n\r\n\t\t#if defined(RECEIVE_SHADOWS) || defined(IS_SHADOW)\r\n\t\t\t// Compute where we are within shadow camera view space\r\n\t\t\tvShadowPosition = directionalLightTransform * worldPosition;\r\n\t\t#endif\r\n\r\n\t\t#if defined(USE_ENV_MAP) && !defined(USE_ACCURATE_REFLECTION_RAY)\r\n\t\t\t// Compute the reflection ray\r\n\t\t\tvec3 incidentRay = normalize(worldPosition.xyz - eyePosition);\r\n\t\t\tvec3 reflected = reflect(incidentRay, normalize(transformedNormal));\r\n\t\t\tvReflect = reflected;\r\n\t\t#endif\r\n\r\n\t\t#ifdef LOG_DEPTH_BUF\r\n\t\t\t// Some values we need to pass along for logarithmic depth buffer stuffs\r\n\t\t\tvFragDepth = 1.0 + gl_Position.w;\r\n\t\t\tvIsPerspective = float(isPerspectiveMatrix(projectionMatrix));\r\n\t\t#endif\r\n\t#endif\r\n}";

	var materialFrag = "precision mediump float;\r\n\r\n#define SHADOW_RADIUS 2\r\n#include <definitions>\r\n\r\n// This condition here is necessary to save on varying vectors; some mobile devices (*cough* iPhones *cough*) only support 8 varying vec4s, and this separation here makes sure we stay just under that. If, in the future, more varyings will be necessary, this condition can always be refined more. Also, apparently I'm not allowed to indent 'varying'.\r\n#ifdef IS_SKY\r\nvarying vec3 eyeDirection;\r\n#else\r\nvarying vec4 vPosition;\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying float vOpacity;\r\nvarying vec4 vShadowPosition;\r\nvarying vec3 vReflect;\r\nvarying mat3 vTbn; // Matrix used to transform the normal map vectors\r\nvarying float vFragDepth;\r\nvarying float vIsPerspective;\r\n#endif\r\n\r\nuniform sampler2D diffuseMap;\r\nuniform samplerCube envMap;\r\nuniform sampler2D normalMap;\r\nuniform sampler2D specularMap;\r\nuniform sampler2D noiseMap;\r\n\r\nuniform float reflectivity;\r\nuniform highp vec3 eyePosition;\r\nuniform float specularIntensity;\r\nuniform float shininess;\r\nuniform float logDepthBufFC;\r\nuniform float secondaryMapUvFactor;\r\n\r\nuniform vec3 ambientLight;\r\nuniform vec3 directionalLightColor;\r\nuniform vec3 directionalLightDirection;\r\nuniform mediump sampler2D directionalLightShadowMap;\r\n\r\n#if defined(LOG_DEPTH_BUF) && defined(IS_WEBGL1)\r\n\t#extension GL_EXT_frag_depth : enable // For some reason, the extension needs to be enabled in-shader\r\n#endif\r\n\r\n// Computes standard Lambertian reflectance\r\nfloat lambert(vec3 normal, vec3 lightPosition) {\r\n\tfloat result = dot(normal, lightPosition);\r\n\treturn max(result, 0.0);\r\n}\r\n\r\n#ifdef IS_WEBGL1\r\n\tmat3 transpose(mat3 inMatrix) {\r\n\t\tvec3 i0 = inMatrix[0];\r\n\t\tvec3 i1 = inMatrix[1];\r\n\t\tvec3 i2 = inMatrix[2];\r\n\r\n\t\tmat3 outMatrix = mat3(\r\n\t\t\tvec3(i0.x, i1.x, i2.x),\r\n\t\t\tvec3(i0.y, i1.y, i2.y),\r\n\t\t\tvec3(i0.z, i1.z, i2.z)\r\n\t\t);\r\n\r\n\t\treturn outMatrix;\r\n\t}\r\n#endif\r\n\r\nvec4 sampleCubeTexture(samplerCube tex, vec3 uvw) {\r\n\t#ifdef ENV_MAP_Z_UP\r\n\t\tuvw.yz = vec2(uvw.z, -uvw.y); // Rotate the \"cube\" about the x-axis because by default, cubemaps are Y-up but we're in Z-up space\r\n\t#endif\r\n\r\n\treturn textureCube(tex, uvw);\r\n}\r\n\r\n// Gets the intensity of a shadow given a point in shadow camera view space\r\nfloat getShadowIntensity(sampler2D map, vec4 shadowPosition, int mapSize) {\r\n\tvec3 projectedTexcoord = shadowPosition.xyz / shadowPosition.w;\r\n\tprojectedTexcoord = (projectedTexcoord + vec3(1.0)) / 2.0; // From [-1, 1] to [0, 1]\r\n\r\n\t// Check if we're even within the bounds of the shadow texture\r\n\tbool inBounds =\r\n\t\tmin(projectedTexcoord.x, min(projectedTexcoord.y, projectedTexcoord.z)) > 0.0 &&\r\n\t\tmax(projectedTexcoord.x, max(projectedTexcoord.y, projectedTexcoord.z)) < 1.0;\r\n\t\r\n\tif (!inBounds) return 0.0; // If not, say there's no shadow\r\n\r\n\tfloat mapSizeF = float(mapSize);\r\n\tfloat total = 0.0;\r\n\r\n\t// Sample the texture in an area to soften it a bit\r\n\tfor (int x = -SHADOW_RADIUS; x <= SHADOW_RADIUS; x++) {\r\n\t\tfor (int y = -SHADOW_RADIUS; y <= SHADOW_RADIUS; y++) {\r\n\t\t\tvec2 uv = projectedTexcoord.xy + vec2(float(x) / mapSizeF, float(y) / mapSizeF);\r\n\t\t\tfloat depthValue = texture2D(map, uv.xy).r;\r\n\t\t\tif (depthValue < projectedTexcoord.z) total += 1.0;\r\n\t\t}\r\n\t}\r\n\r\n\treturn mix(total / float((SHADOW_RADIUS*2+1)*(SHADOW_RADIUS*2+1)), 0.0, projectedTexcoord.z * projectedTexcoord.z);\r\n}\r\n\r\n// Fresnel-Schlick approximation\r\nfloat fresnel(vec3 direction, vec3 normal, bool invert) {\r\n\tvec3 nDirection = normalize(direction);\r\n\tvec3 nNormal = normalize(normal);\r\n\tvec3 halfDirection = normalize(nNormal + nDirection);\r\n\r\n\tfloat exponent = 5.0;\r\n\tfloat cosine = dot(halfDirection, nDirection);\r\n\tfloat product = max(cosine, 0.0);\r\n\tfloat factor = invert ? 1.0 - pow(product, exponent) : pow(product, exponent);\r\n\t\r\n\treturn factor;\r\n}\r\n\r\nvoid main() {\r\n\t#if defined(LOG_DEPTH_BUF) && !defined(IS_SKY)\r\n\t\t// We always need to set gl_FragDepthEXT when it's present in the file, otherwise it gets real weird\r\n\t\t// Also: Doing a strict comparison with == 1.0 can cause noise artifacts\r\n\t\tgl_FragDepthEXT = (vIsPerspective != 0.0)? log2(vFragDepth) * logDepthBufFC * 0.5 : gl_FragCoord.z;\r\n\t#endif\r\n\r\n\t#ifdef IS_SKY\r\n\t\t// We simply sample the skybox cube texture and we're done.\r\n\t\tvec4 sampled = sampleCubeTexture(envMap, eyeDirection);\r\n\t\tgl_FragColor = sampled;\r\n\t#elif defined(IS_SHADOW)\r\n\t\tbool hasDirectionalLight = dot(directionalLightDirection, directionalLightDirection) > 0.0;\r\n\t\tfloat intensity = getShadowIntensity(directionalLightShadowMap, vShadowPosition, 250);\r\n\t\tif (!hasDirectionalLight) intensity = 0.0;\r\n\t\t\r\n\t\tgl_FragColor = vec4(vec3(0.0), intensity * 0.25); // Note that this intensity differs from the one used in the normal shader path. That's because with a separate shadow material, it's actually difficult to figure out how dark the shadow should be - so whatever value we picked here just looked the least odd.\r\n\t#else\r\n\t\tvec4 diffuse = vec4(1.0);\r\n\r\n\t\t#ifdef USE_DIFFUSE_MAP\r\n\t\t\tdiffuse = texture2D(diffuseMap, vUv);\r\n\t\t\t#ifndef TRANSPARENT\r\n\t\t\t\tdiffuse.a = 1.0;\r\n\t\t\t#endif\r\n\t\t#endif\r\n\r\n\t\t#ifdef USE_NOISE_MAP\r\n\t\t\t// Sample the noise texture multiple times to create the tiling effect found in MBU textures. Code is taken from MBU shaders!\r\n\r\n\t\t\tvec2 noiseIndex;\r\n\t\t\tvec4 noiseColor[4];\r\n\t\t\tvec2 halfPixel = vec2(1.0 / 64.0, 1.0 / 64.0);\r\n\r\n\t\t\tnoiseIndex.x = floor(vUv.x - halfPixel.x) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseIndex.y = floor(vUv.y - halfPixel.y) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseColor[0] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\r\n\r\n\t\t\tnoiseIndex.x = floor(vUv.x - halfPixel.x) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseIndex.y = floor(vUv.y + halfPixel.y) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseColor[1] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\r\n\r\n\t\t\tnoiseIndex.x = floor(vUv.x + halfPixel.x) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseIndex.y = floor(vUv.y + halfPixel.y) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseColor[2] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\r\n\r\n\t\t\tnoiseIndex.x = floor(vUv.x + halfPixel.x) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseIndex.y = floor(vUv.y - halfPixel.y) / 63.0 + 0.5/64.0;\r\n\t\t\tnoiseColor[3] = texture2D(noiseMap, noiseIndex) * 1.0 - 0.5;\r\n\r\n\t\t\tvec4 finalNoiseCol = (noiseColor[0] + noiseColor[1] + noiseColor[2] + noiseColor[3]) / 4.0;\r\n\t\t\tdiffuse.rgb *= 1.0 + finalNoiseCol.r; // This isn't how MBU does it afaik but it looks good :o\r\n\t\t#endif\r\n\r\n\t\tdiffuse.a *= vOpacity; // Multiply the diffuse by the whole mesh's opacity (and the material's opacity)\r\n\r\n\t\tvec3 incomingLight = vec3(0.0);\r\n\t\tvec3 specularLight = vec3(0.0);\r\n\r\n\t\t#ifdef EMISSIVE\r\n\t\t\tincomingLight = vec3(1.0);\r\n\t\t#else\r\n\t\t\tincomingLight += ambientLight;\r\n\r\n\t\t\tvec3 normal = vNormal;\r\n\r\n\t\t\t#ifdef USE_NORMAL_MAP\r\n\t\t\t\t// Overwrite the normal with the sampled one\r\n\t\t\t\tvec3 map = texture2D(normalMap, secondaryMapUvFactor * vUv).xyz;\r\n\t\t\t\tmap = map * 255.0/127.0 - 128.0/127.0;\r\n\t\t\t\tnormal = vTbn * map; // Don't normalize here! Reduces aliasing effects\r\n\t\t\t#endif\r\n\r\n\t\t\tvec3 addedLight = directionalLightColor * lambert(normal, -directionalLightDirection);\r\n\r\n\t\t\t#ifdef SATURATE_INCOMING_LIGHT\r\n\t\t\t\t// MBG saturates the incoming light to be at most 1.0\r\n\t\t\t\taddedLight = min(vec3(1.0), incomingLight + addedLight) - incomingLight;\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef RECEIVE_SHADOWS\r\n\t\t\t\t// When the direction has zero length, we make the assumption that there is no directional light in the scene.\r\n\t\t\t\tbool hasDirectionalLight = dot(directionalLightDirection, directionalLightDirection) > 0.0;\r\n\t\t\t\tfloat intensity = getShadowIntensity(directionalLightShadowMap, vShadowPosition, 250);\r\n\t\t\t\tif (!hasDirectionalLight) intensity = 0.0;\r\n\r\n\t\t\t\taddedLight *= mix(1.0, 0.666, intensity);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\tincomingLight += addedLight;\r\n\r\n\t\t\t#ifdef USE_SPECULAR\r\n\t\t\t\tvec3 viewDir = normalize(eyePosition - vPosition.xyz);\r\n\t\t\t\tvec3 halfwayDir = normalize(-directionalLightDirection + viewDir); // Blinn-Phong\r\n\r\n\t\t\t\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\r\n\r\n\t\t\t\t#ifdef USE_SPECULAR_MAP\r\n\t\t\t\t\tspec *= texture2D(specularMap, secondaryMapUvFactor * vUv).r;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tspecularLight += vec3(specularIntensity * spec);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\r\n\t\tvec4 shaded = diffuse * vec4(incomingLight, 1.0);\r\n\t\tshaded.rgb += specularLight;\r\n\r\n\t\t#ifdef USE_ENV_MAP\r\n\t\t\t#ifdef USE_FRESNEL\r\n\t\t\t\t// Fresnel causes the reflectivity to increase with incresing angle of incidence\r\n\t\t\t\tvec3 viewDir = normalize(eyePosition - vPosition.xyz);\r\n\t\t\t\tfloat fac = fresnel(viewDir, normal, true);\r\n\t\t\t#else\r\n\t\t\t\tfloat fac = 1.0;\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef USE_ACCURATE_REFLECTION_RAY\r\n\t\t\t\t// The reflection ray tends to be much more accurate when computed using the interpolated normal rather than interpolating the reflection ray itself; but it's more expensive and sometimes looks too boring\r\n\t\t\t\tvec3 incidentRay = normalize(vPosition.xyz - eyePosition);\r\n\t\t\t\tvec3 reflectionRay = reflect(incidentRay, normalize(vNormal));\r\n\t\t\t#else\r\n\t\t\t\tvec3 reflectionRay = vReflect;\r\n\t\t\t#endif\r\n\r\n\t\t\tvec4 sampled = sampleCubeTexture(envMap, reflectionRay);\r\n\t\t\tsampled.a *= vOpacity;\r\n\t\t\t\r\n\t\t\tshaded = mix(shaded, sampled, fac * reflectivity);\r\n\t\t#endif\r\n\r\n\t\tgl_FragColor = shaded;\r\n\t\t#ifdef USE_PREMULTIPLIED_ALPHA\r\n\t\t\tgl_FragColor.rgb *= gl_FragColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}";

	/** A scene is responsible for holding the description of a renderable world and preparing it for efficient rendering. If you wanna know what all this static/dynamic mesh thing is about, check Mesh. */
	class Scene$1 extends Group {
	    constructor(renderer, maxDynamicVertices = 2 ** 18, maxDynamicMeshes = 256) {
	        super();
	        this.staticMeshes = [];
	        this.dynamicMeshes = [];
	        this.allDefineChunks = new Set();
	        this.ambientLights = [];
	        this.directionalLights = [];
	        this.particleManager = null;
	        this.firstUpdate = true;
	        this.compiled = false;
	        this.needsDynamicMeshRecompilation = true;
	        this.preparedForRender = false;
	        // Listen out for any changes in the scene graph to see if dynamic objects have changed
	        this.onDescendantChange = (object) => {
	            object.traverse(x => {
	                // Check if removing is a valid operation right now
	                if (!(x instanceof Mesh$1))
	                    return;
	                if (!x.dynamic && this.compiled)
	                    throw new Error("Cannot add/remove static mesh from scene after scene compilation!");
	                if (x.dynamic)
	                    this.needsDynamicMeshRecompilation = true;
	            });
	        };
	        this.renderer = renderer;
	        this.maxDynamicVertices = maxDynamicVertices;
	        this.maxDynamicMeshes = maxDynamicMeshes;
	        // Already create all dynamic vertex buffers but without any data
	        this.dynamicPositionBuffer = new VertexBuffer(this.renderer, new Float32Array(3 * maxDynamicVertices), { 'position': 3 });
	        this.dynamicNormalBuffer = new VertexBuffer(this.renderer, new Float32Array(3 * maxDynamicVertices), { 'normal': 3 });
	        this.dynamicTangentBuffer = new VertexBuffer(this.renderer, new Float32Array(4 * maxDynamicVertices), { 'tangent': 4 });
	        this.dynamicUvBuffer = new VertexBuffer(this.renderer, new Float32Array(2 * maxDynamicVertices), { 'uv': 2 });
	        this.dynamicMeshInfoIndexBuffer = new VertexBuffer(this.renderer, new Float32Array(1 * maxDynamicVertices), { 'meshInfoIndex': 1 });
	        this.dynamicBufferGroup = new VertexBufferGroup([
	            this.dynamicPositionBuffer,
	            this.dynamicNormalBuffer,
	            this.dynamicTangentBuffer,
	            this.dynamicUvBuffer,
	            this.dynamicMeshInfoIndexBuffer
	        ]);
	    }
	    addAmbientLight(light) {
	        this.ambientLights.push(light);
	    }
	    addDirectionalLight(light) {
	        this.directionalLights.push(light);
	    }
	    /**
	     * Compiles the scene and all its static meshes into neatly-packed buffers and draw calls for efficient rendering. After a scene has been
	     * compiled, no static meshes can be added to or removed from it. In a general 3D engine this would be a very hard limitation, however it
	     * it perfect for Marble Blast, as the number of objects is constant at all times. We can exploit this fact to do some heavy-lifting
	     * ahead-of-time to save on draw calls and massively reduce rendering CPU overhead, a common problem for WebGL applications.
	     *
	     * During the compilation, all meshes will be scanned for the materials they use, and data is arranged in such a way that a single draw
	     * call is enough to draw all geometry of a single material, eliminating the need for per-mesh draw calls. There is, however, some data
	     * about meshes that cannot be precomputed as it is dynamic; mainly their transform and opacity. We therefore store this data in a
	     * floating-point texture that the vertex shader will dynamically read from. Whenever meshes change, we only need to update this texture
	     * once and we're set.
	     *
	     * As is usual with 3D renderers, transparent objects need to get different treatment as they have to be rendered using the painter's
	     * algorithm (back-to-front) for correct layering. Scene compilation also checks materials for transparency and separates opaque and
	     * transparent objects. Transparent objects, however, cannot be neatly precompiled and preplanned as opaque objects do.
	     */
	    compile() {
	        let { gl } = this.renderer;
	        let allStaticMeshes = [];
	        this.traverse(obj => obj instanceof Mesh$1 && !obj.dynamic && allStaticMeshes.push(obj));
	        this.staticMeshes = allStaticMeshes;
	        let { positions, normals, tangents, uvs, meshInfoIndices, shadowCasterIndices, indices, opaqueMaterialGroups } = this.compileMeshes(allStaticMeshes);
	        this.staticOpaqueMaterialGroups = opaqueMaterialGroups;
	        // Create all vertex buffers for static meshes
	        this.staticPositionBuffer = new VertexBuffer(this.renderer, new Float32Array(positions), { 'position': 3 });
	        this.staticNormalBuffer = new VertexBuffer(this.renderer, new Float32Array(normals), { 'normal': 3 });
	        this.staticTangentBuffer = new VertexBuffer(this.renderer, new Float32Array(tangents), { 'tangent': 4 });
	        this.staticUvBuffer = new VertexBuffer(this.renderer, new Float32Array(uvs), { 'uv': 2 });
	        this.staticMeshInfoIndexBuffer = new VertexBuffer(this.renderer, new Float32Array(meshInfoIndices), { 'meshInfoIndex': 1 });
	        // Group the vertex buffers so they can be put into a single VAO
	        this.staticBufferGroup = new VertexBufferGroup([
	            this.staticPositionBuffer,
	            this.staticNormalBuffer,
	            this.staticTangentBuffer,
	            this.staticUvBuffer,
	            this.staticMeshInfoIndexBuffer
	        ]);
	        // Now, create our data textures to hold mesh information
	        this.staticMeshInfoTexture = this.createMeshInfoTexture(allStaticMeshes.length);
	        this.dynamicMeshInfoTexture = this.createMeshInfoTexture(this.maxDynamicMeshes);
	        // Now, allocate the index buffers
	        let opaqueIndexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, opaqueIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
	        this.staticOpaqueIndexBuffer = opaqueIndexBuffer;
	        this.staticShadowCasterIndices = shadowCasterIndices;
	        this.staticShadowCasterIndexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.staticShadowCasterIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(shadowCasterIndices), gl.STATIC_DRAW);
	        // Buffers for dynamic meshes, data will be written at another point
	        this.dynamicOpaqueIndexBuffer = gl.createBuffer();
	        this.dynamicShadowCasterIndexBuffer = gl.createBuffer();
	        // Set some values in the material groups
	        for (let group of this.staticOpaqueMaterialGroups) {
	            group.vertexBufferGroup = this.staticBufferGroup;
	            group.indexBuffer = opaqueIndexBuffer;
	            group.meshInfoTexture = this.staticMeshInfoTexture;
	        }
	        // Allocate the index buffer for transparent objects. Since technically, every mesh could become transparent at some point, we need to make this buffer big enough to fit all meshes.
	        let totalIndexCount = allStaticMeshes.map(x => x.geometry.indices.length).reduce((a, b) => a + b, 0);
	        totalIndexCount += this.maxDynamicVertices;
	        let transparentIndexBuffer = gl.createBuffer();
	        let transparentIndexBufferData = new Uint32Array(totalIndexCount);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, transparentIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, transparentIndexBufferData, gl.DYNAMIC_DRAW);
	        this.transparentIndexBuffer = transparentIndexBuffer;
	        this.transparentIndexBufferData = transparentIndexBufferData;
	        // Now, let's prepare the lights.
	        // Ambient light is simple: Simply condense all ambient lights into one by adding up their colors.
	        let totalAmbientLight = new Vector3$1();
	        this.ambientLights.forEach(x => totalAmbientLight.add(x.color));
	        this.ambientLightBuffer = new Float32Array(totalAmbientLight.toArray());
	        // For directional lights, there's no correct solution for more than one light, so we just average the direction vectors and sum the colors.
	        let totalDirectionalLight = new Vector3$1();
	        let directionalLightDirection = new Vector3$1();
	        for (let light of this.directionalLights) {
	            totalDirectionalLight.add(light.color);
	            directionalLightDirection.addScaledVector(light.direction, 1 / this.directionalLights.length);
	        }
	        this.directionalLightColorBuffer = new Float32Array(totalDirectionalLight.toArray());
	        this.directionalLightDirectionBuffer = new Float32Array(directionalLightDirection.toArray());
	        this.directionalLightTransformBuffer = new Float32Array(16);
	        this.compiled = true;
	    }
	    createMeshInfoTexture(meshCount) {
	        let { gl } = this.renderer;
	        let maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	        let textureWidth = Util$1.ceilPowerOf2(Math.min(4 * meshCount, maxTextureSize)); // (WebGL1) textures need to have power-of-two dimension
	        let textureHeight = Util$1.ceilPowerOf2(Math.ceil(4 * meshCount / Math.max(maxTextureSize, textureWidth)));
	        let internalFormat = (gl instanceof WebGLRenderingContext) ? gl.RGBA : gl.RGBA32F;
	        let buffer = new Float32Array(4 * textureWidth * textureHeight); // One mat4 per mesh
	        let texture = gl.createTexture();
	        gl.bindTexture(gl.TEXTURE_2D, texture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, textureWidth, textureHeight, 0, gl.RGBA, gl.FLOAT, null);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); // LINEAR would make no sense here
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        return { buffer, texture, width: textureWidth, height: textureHeight };
	    }
	    compileMeshes(meshes) {
	        let materialMap = new Map();
	        // Create the arrays that will form VBO data
	        let positions = [];
	        let normals = [];
	        let tangents = [];
	        let uvs = [];
	        let meshInfoIndices = [];
	        let shadowCasterIndices = [];
	        for (let [index, mesh] of meshes.entries()) {
	            let vertsAddedSoFar = meshInfoIndices.length;
	            mesh.geometry.validate();
	            mesh.vboOffset = vertsAddedSoFar;
	            mesh.compileMaterialIndices();
	            let verts = mesh.geometry.positions.length / 3;
	            Util$1.pushArray(positions, mesh.geometry.positions);
	            Util$1.pushArray(normals, mesh.geometry.normals);
	            Util$1.pushArray(uvs, mesh.geometry.uvs);
	            Util$1.pushArray(meshInfoIndices, Array(verts).fill(index));
	            let hasNormalMap = mesh.materials.some(x => x.normalMap);
	            if (hasNormalMap) {
	                // Normal map calculations require us to do operations in so-called "tangent space", for which we need an extra tangent vector in addition to the normal
	                Scene$1.computeTangents(mesh.geometry.positions, mesh.geometry.normals, mesh.geometry.uvs, tangents);
	            }
	            else {
	                // No normal maps are used, no reason to compute any tangents
	                Util$1.pushArray(tangents, Array(4 * verts).fill(0));
	            }
	            for (let data of mesh.materialIndices) {
	                let material = data.material;
	                let defineChunk = material.getDefineChunk();
	                this.allDefineChunks.add(defineChunk);
	                if (!this.renderer.materialShaders.has(defineChunk)) {
	                    // New material, create a shader for it
	                    let program = new Program(this.renderer, materialVert, materialFrag, defineChunk);
	                    this.renderer.materialShaders.set(defineChunk, program);
	                }
	                if (mesh.castShadows)
	                    Util$1.pushArray(shadowCasterIndices, data.indices);
	                if (material.transparent || material.opacity < 1) {
	                    mesh.hasTransparentMaterials = true;
	                    continue; // We do only opaque stuff here
	                }
	                Scene$1.updateMaterialGroup(materialMap, data);
	            }
	        }
	        let opaqueMaterialGroups = [...materialMap].map(x => x[1]);
	        // Group material groups by define chunk to minimize the amount of calls to gl.useProgram. Then, make sure materials with the lowest render order go first.
	        opaqueMaterialGroups.sort((a, b) => a.defineChunk.localeCompare(b.defineChunk)).sort((a, b) => a.material.renderOrder - b.material.renderOrder);
	        // Will form the data for our index buffer
	        let indices = [];
	        for (let group of opaqueMaterialGroups) {
	            group.offset = indices.length;
	            for (let data of group.indexGroups)
	                Util$1.pushArray(indices, data.indices);
	        }
	        return {
	            positions,
	            normals,
	            tangents,
	            uvs,
	            meshInfoIndices,
	            shadowCasterIndices,
	            indices,
	            opaqueMaterialGroups
	        };
	    }
	    recompileDynamicMeshes() {
	        let { gl } = this.renderer;
	        let allDynamicMeshes = [];
	        this.traverse(x => x instanceof Mesh$1 && x.dynamic && allDynamicMeshes.push(x));
	        this.dynamicMeshes = allDynamicMeshes;
	        if (allDynamicMeshes.length > this.maxDynamicMeshes)
	            throw new Error(`Can't have more than ${this.maxDynamicMeshes} dynamic meshes!`);
	        let { positions, normals, tangents, uvs, meshInfoIndices, shadowCasterIndices, indices, opaqueMaterialGroups } = this.compileMeshes(allDynamicMeshes);
	        for (let group of opaqueMaterialGroups) {
	            group.vertexBufferGroup = this.dynamicBufferGroup;
	            group.indexBuffer = this.dynamicOpaqueIndexBuffer;
	            group.meshInfoTexture = this.dynamicMeshInfoTexture;
	        }
	        this.dynamicOpaqueMaterialGroups = opaqueMaterialGroups;
	        this.dynamicPositionBuffer.set(positions);
	        this.dynamicNormalBuffer.set(normals);
	        this.dynamicTangentBuffer.set(tangents);
	        this.dynamicUvBuffer.set(uvs);
	        this.dynamicMeshInfoIndexBuffer.set(meshInfoIndices);
	        this.dynamicPositionBuffer.update();
	        this.dynamicNormalBuffer.update();
	        this.dynamicTangentBuffer.update();
	        this.dynamicUvBuffer.update();
	        this.dynamicMeshInfoIndexBuffer.update();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dynamicOpaqueIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.DYNAMIC_DRAW);
	        this.dynamicShadowCasterIndices = shadowCasterIndices;
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dynamicShadowCasterIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(shadowCasterIndices), gl.DYNAMIC_DRAW);
	        this.needsDynamicMeshRecompilation = false;
	    }
	    /** Updates (or creates) a material group and adds index data to it. */
	    static updateMaterialGroup(materialMap, data) {
	        let material = data.material;
	        let materialHash = material.getHash();
	        let materialGroup = materialMap.get(materialHash);
	        if (!materialGroup) {
	            materialGroup = {
	                material,
	                indexGroups: [],
	                defineChunk: material.getDefineChunk(),
	                // These two *have* to be set later on
	                vertexBufferGroup: null,
	                indexBuffer: null,
	                meshInfoTexture: null,
	                offset: 0,
	                count: 0,
	                minDistance: Infinity
	            };
	            materialMap.set(materialHash, materialGroup);
	        }
	        materialGroup.indexGroups.push(data);
	        materialGroup.count += data.indices.length;
	        return materialGroup;
	    }
	    // Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”. Terathon Software 3D Graphics Library, 2001. http://www.terathon.com/code/tangent.html https://www.cs.upc.edu/~virtual/G/1.%20Teoria/06.%20Textures/Tangent%20Space%20Calculation.pdf
	    static computeTangents(positions, normals, uvs, tangents) {
	        let verts = positions.length / 3;
	        let tris = verts / 3;
	        let v1 = new Vector3$1();
	        let v2 = new Vector3$1();
	        let v3 = new Vector3$1();
	        let w1 = new Vector2();
	        let w2 = new Vector2();
	        let w3 = new Vector2();
	        let sdir = new Vector3$1();
	        let tdir = new Vector3$1();
	        let normal = new Vector3$1();
	        let tangent = new Vector3$1();
	        for (let i = 0; i < tris; i++) {
	            v1.set(positions[9 * i + 0], positions[9 * i + 1], positions[9 * i + 2]);
	            v2.set(positions[9 * i + 3], positions[9 * i + 4], positions[9 * i + 5]);
	            v3.set(positions[9 * i + 6], positions[9 * i + 7], positions[9 * i + 8]);
	            w1.set(uvs[6 * i + 0], uvs[6 * i + 1]);
	            w2.set(uvs[6 * i + 2], uvs[6 * i + 3]);
	            w3.set(uvs[6 * i + 4], uvs[6 * i + 5]);
	            let x1 = v2.x - v1.x;
	            let x2 = v3.x - v1.x;
	            let y1 = v2.y - v1.y;
	            let y2 = v3.y - v1.y;
	            let z1 = v2.z - v1.z;
	            let z2 = v3.z - v1.z;
	            let s1 = w2.x - w1.x;
	            let s2 = w3.x - w1.x;
	            let t1 = w2.y - w1.y;
	            let t2 = w3.y - w1.y;
	            let r = 1 / (s1 * t2 - s2 * t1);
	            sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
	            tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
	            for (let j = 0; j < 3; j++) {
	                normal.set(normals[9 * i + 3 * j + 0], normals[9 * i + 3 * j + 1], normals[9 * i + 3 * j + 2]);
	                // Gram-Schmidt orthogonalize
	                tangent.copy(sdir).addScaledVector(normal, -normal.dot(sdir)).normalize();
	                // Calculate handedness
	                let w = (normal.cross(sdir).dot(tdir) < 0) ? -1 : 1;
	                tangents.push(tangent.x, tangent.y, tangent.z, w);
	            }
	        }
	    }
	    /**
	     * Prepares a scene for rendering by updating shadow maps and preparing transparent objects. Has to be called before each render.
	     * This is kept separate from `render` because a scene can be rendered multiple times per frame (for cubemaps, for example). It
	     * would be a waste to prepare the scene for each of those renders as the state hasn't changed.
	     */
	    prepareForRender(camera) {
	        var _a;
	        let { gl } = this.renderer;
	        if (this.needsDynamicMeshRecompilation)
	            this.recompileDynamicMeshes();
	        this.update();
	        (_a = this.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.renderShadowMap(this);
	        let temp = new Vector3$1();
	        let cameraPosition = camera.position;
	        let allMeshes = [...this.staticMeshes, ...this.dynamicMeshes];
	        let transparentMeshes = allMeshes.filter(x => x.hasTransparentMaterials || (x.opacity < 1 && x.opacity > 0)); // Find out which meshes are transparent so we don't sort opaque stuff too
	        // Compute the distances to the camera
	        for (let mesh of transparentMeshes) {
	            mesh.distanceToCamera = temp.setFromMatrixPosition(mesh.worldTransform).distanceToSquared(cameraPosition);
	        }
	        // Sort transparent meshes using the painter's algorithm, furthest first
	        let sortedMeshes = transparentMeshes.sort((a, b) => b.distanceToCamera - a.distanceToCamera);
	        let staticMaterialMap = new Map();
	        let dynamicMaterialMap = new Map();
	        // Create the material groups for the transparent objects
	        for (let mesh of sortedMeshes) {
	            for (let data of mesh.materialIndices) {
	                let material = data.material;
	                let effectiveOpacity = mesh.opacity * material.opacity;
	                if ((!material.transparent && effectiveOpacity === 1) || effectiveOpacity === 0)
	                    continue;
	                let group = Scene$1.updateMaterialGroup(mesh.dynamic ? dynamicMaterialMap : staticMaterialMap, data);
	                group.minDistance = Math.min(group.minDistance, mesh.distanceToCamera);
	            }
	        }
	        // Set some buffer pointers
	        for (let [, group] of staticMaterialMap) {
	            group.vertexBufferGroup = this.staticBufferGroup;
	            group.indexBuffer = this.transparentIndexBuffer;
	            group.meshInfoTexture = this.staticMeshInfoTexture;
	        }
	        for (let [, group] of dynamicMaterialMap) {
	            group.vertexBufferGroup = this.dynamicBufferGroup;
	            group.indexBuffer = this.transparentIndexBuffer;
	            group.meshInfoTexture = this.dynamicMeshInfoTexture;
	        }
	        // We also need to sort the individual material groups by distance to get more accurate results. This is because
	        // what we're doing is actually inaccurate, since we're drawing all geometry of a single material at once, which
	        // works fine for opaque objects where order doesn't matter, but falls apart for transparent objects where correct
	        // depth sorting is paramount. To reduce errors as much as possible, make sure we draw the materials with the furthest
	        // minimum distance to the camera first.
	        let materialGroups = [...staticMaterialMap, ...dynamicMaterialMap].map(x => x[1]);
	        materialGroups.sort((a, b) => b.minDistance - a.minDistance);
	        this.transparentMaterialGroups = materialGroups;
	        // Populate the index buffer
	        let offset = 0;
	        for (let group of materialGroups) {
	            group.offset = offset;
	            for (let data of group.indexGroups) {
	                this.transparentIndexBufferData.set(data.indexBuffer, offset); // We're using .set here which should cause a fast memcpy in the JS engine
	                offset += data.indices.length;
	            }
	        }
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.transparentIndexBuffer);
	        gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, this.transparentIndexBufferData.subarray(0, offset)); // subarray *way* faster than using the WebGL2 signature
	        this.preparedForRender = true;
	    }
	    /** Updates this scene and its meshes. */
	    update() {
	        let { gl } = this.renderer;
	        // Update the world transform of all meshes that need an update
	        this.updateWorldTransform();
	        // Check all static meshes
	        for (let i = 0; i < this.staticMeshes.length; i++) {
	            let mesh = this.staticMeshes[i];
	            if (mesh.needsVertexBufferUpdate) {
	                // Geomtry has changed, we need to update the VBOs
	                let offset = mesh.vboOffset;
	                this.staticPositionBuffer.set(mesh.geometry.positions, offset * 3);
	                this.staticNormalBuffer.set(mesh.geometry.normals, offset * 3);
	                this.staticUvBuffer.set(mesh.geometry.uvs, offset * 2);
	                mesh.needsVertexBufferUpdate = false;
	            }
	            if (this.firstUpdate || mesh.needsMeshInfoBufferUpdate) {
	                mesh.updateMeshInfoBuffer(this.staticMeshInfoTexture.buffer, 16 * i);
	            }
	        }
	        // Check all dynamic meshes
	        for (let i = 0; i < this.dynamicMeshes.length; i++) {
	            let mesh = this.dynamicMeshes[i];
	            if (mesh.needsVertexBufferUpdate) {
	                // Geomtry has changed, we need to update the VBOs
	                let offset = mesh.vboOffset;
	                this.dynamicPositionBuffer.set(mesh.geometry.positions, offset * 3);
	                this.dynamicNormalBuffer.set(mesh.geometry.normals, offset * 3);
	                this.dynamicUvBuffer.set(mesh.geometry.uvs, offset * 2);
	                mesh.needsVertexBufferUpdate = false;
	            }
	            if (this.firstUpdate || mesh.needsMeshInfoBufferUpdate) {
	                mesh.updateMeshInfoBuffer(this.dynamicMeshInfoTexture.buffer, 16 * i);
	            }
	        }
	        // Update the mesh info data textures
	        gl.bindTexture(gl.TEXTURE_2D, this.staticMeshInfoTexture.texture);
	        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.staticMeshInfoTexture.width, this.staticMeshInfoTexture.height, gl.RGBA, gl.FLOAT, this.staticMeshInfoTexture.buffer);
	        gl.bindTexture(gl.TEXTURE_2D, this.dynamicMeshInfoTexture.texture);
	        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.dynamicMeshInfoTexture.width, this.dynamicMeshInfoTexture.height, gl.RGBA, gl.FLOAT, this.dynamicMeshInfoTexture.buffer);
	        // Write the updated VBOs to the GPU. If nothing changed, these calls won't do anything.
	        this.staticPositionBuffer.update();
	        this.staticNormalBuffer.update();
	        this.staticUvBuffer.update();
	        this.dynamicPositionBuffer.update();
	        this.dynamicNormalBuffer.update();
	        this.dynamicUvBuffer.update();
	        // We also need to update the shadow camera transform
	        this.updateDirectionalLights();
	        this.firstUpdate = false;
	    }
	    updateDirectionalLights() {
	        let firstLight = this.directionalLights[0];
	        if (!firstLight)
	            return;
	        if (firstLight.camera) {
	            let mat4 = new Matrix4();
	            mat4.multiplyMatrices(firstLight.camera.projectionMatrix, firstLight.camera.matrixWorldInverse);
	            this.directionalLightTransformBuffer.set(mat4.elements, 0);
	        }
	    }
	    /** Disposes all GPU resources used by this scene. */
	    dispose() {
	        let { gl } = this.renderer;
	        this.staticPositionBuffer.dispose();
	        this.staticNormalBuffer.dispose();
	        this.staticTangentBuffer.dispose();
	        this.staticUvBuffer.dispose();
	        this.staticMeshInfoIndexBuffer.dispose();
	        gl.deleteTexture(this.staticMeshInfoTexture.texture);
	        gl.deleteTexture(this.dynamicMeshInfoTexture.texture);
	        gl.deleteBuffer(this.staticOpaqueIndexBuffer);
	        gl.deleteBuffer(this.transparentIndexBuffer);
	        gl.deleteBuffer(this.staticShadowCasterIndexBuffer);
	        this.particleManager.dispose();
	        for (let light of this.directionalLights)
	            light.dispose();
	    }
	}

	class MbpHud$1 extends Hud {
	    constructor() {
	        super(...arguments);
	        this.gemCountMinDigits = 3;
	        this.showClockBackground = true;
	        this.supportNumberColors = true;
	        this.supportFpsMeter = true;
	    }
	}
	//# sourceMappingURL=hud_mbp.js.map

	class PauseScreen {
	    constructor(menu) {
	        /** If true, can't be closed using the Escape key. */
	        this.preventClose = false;
	        this.initProperties();
	        menu.setupButton(this.yesButton, this.yesSrc, () => {
	            if (!G$1.game)
	                return;
	            G$1.game.stopAndExit();
	        });
	        menu.setupButton(this.noButton, this.noSrc, () => G$1.game.unpause());
	        menu.setupButton(this.restartButton, this.restartSrc, () => {
	            G$1.game.unpause();
	            G$1.game.signalRestartIntent();
	        });
	        window.addEventListener('keydown', (e) => {
	            if (!G$1.game)
	                return;
	            if (G$1.menu !== menu)
	                return;
	            if (e.key === 'Escape') {
	                if (G$1.game.paused) {
	                    if (!this.preventClose)
	                        this.noButton.src = menu.uiAssetPath + this.noSrc + '_d.png';
	                }
	                else {
	                    G$1.game.pause();
	                }
	            }
	            else if (e.code === StorageManager$1.data.settings.gameButtonMapping.restart && G$1.game.paused) {
	                // Restart the level if we press the restart button
	                this.restartButton.click();
	                //state.level.pressingRestart = true; // fixme Prevents the level from restarting again immediately (kinda hacky 😅)
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (!G$1.game)
	                return;
	            if (G$1.menu !== menu)
	                return;
	            if (G$1.game.paused && e.key === 'Escape' && this.noButton.src.endsWith('_d.png')) {
	                this.noButton.src = menu.uiAssetPath + this.noSrc + '_n.png';
	                G$1.game.unpause();
	            }
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        setEnterFullscreenButtonVisibility(true);
	    }
	    hide() {
	        this.div.classList.add('hidden');
	        setEnterFullscreenButtonVisibility(false);
	    }
	    async onReplayButtonClick(download) {
	        let level = G$1.level;
	        if (download) {
	            let serialized = await level.replay.serialize();
	            Replay$1.download(serialized, level.mission, false, true);
	            if (Util$1.isTouchDevice && Util$1.isInFullscreen())
	                G$1.menu.showAlertPopup('Downloaded', 'The .wrec has been downloaded.');
	        }
	        else {
	            let confirmed = await G$1.menu.showConfirmPopup('Confirm', "Do you want to watch this replay? Note that you can only watch it once. If you want to watch it more often, download it first. (alt-click (or long-press on touch devices))");
	            if (!confirmed)
	                return;
	            level.replay.mode = 'playback';
	            this.restartButton.click();
	        }
	    }
	    handleGamepadInput(gamepad) {
	        // A button to exit
	        if (gamepad.buttons[0].value > 0.5 && !previousButtonState[0]) {
	            G$1.level.stopAndExit();
	            AudioManager$1.play('buttonpress.wav');
	        }
	        // B button or pause button to continue
	        if (gamepad.buttons[1].value > 0.5 && !previousButtonState[1]) {
	            G$1.level.unpause();
	            AudioManager$1.play('buttonpress.wav');
	        }
	        if (gamepad.buttons[9].value > 0.5 && !previousButtonState[9]) {
	            G$1.level.unpause();
	            resetPressedFlag$1('pause');
	            AudioManager$1.play('buttonpress.wav');
	        }
	        // Restart button to restart
	        if (gamepad.buttons[8].value > 0.5 && !previousButtonState[8]) {
	            G$1.level.unpause();
	            G$1.level.restart(true);
	            G$1.level.pressingRestart = true;
	            AudioManager$1.play('buttonpress.wav');
	        }
	    }
	}
	//# sourceMappingURL=pause_screen.js.map

	class MbpPauseScreen$1 extends PauseScreen {
	    constructor(menu) {
	        super(menu);
	        this.jukeboxButton = document.querySelector('#mbp-pause-jukebox');
	        menu.setupButton(this.replayButton, 'play/replay', (e) => this.onReplayButtonClick(e.altKey));
	        Util$1.onLongTouch(this.replayButton, () => this.onReplayButtonClick(true));
	        this.jukebox = new Jukebox(menu);
	        menu.setupButton(this.jukeboxButton, 'jukebox/jb_pausemenu', () => {
	            this.jukebox.show();
	        }, undefined, undefined, false);
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-pause-screen');
	        this.yesButton = document.querySelector('#mbp-pause-yes');
	        this.noButton = document.querySelector('#mbp-pause-no');
	        this.restartButton = document.querySelector('#mbp-pause-restart');
	        this.replayButton = document.querySelector('#mbp-pause-replay');
	        this.yesSrc = 'exit/yes';
	        this.noSrc = 'exit/no';
	        this.restartSrc = 'exit/restart';
	    }
	}
	const SONGS = {
	    'astrolabe.ogg': 'Astrolabe',
	    'beach party.ogg': 'Beach Party',
	    'challenge.ogg': 'Challenge',
	    'classic vibe.ogg': 'Classic Vibe',
	    'comforting mystery.ogg': 'Comforting Mystery',
	    'endurance.ogg': 'Endurance',
	    'flanked.ogg': 'Flanked',
	    'groove police.ogg': 'Groove Police',
	    'grudge.ogg': 'Grudge',
	    'mbp old shell.ogg': 'MBP Old Shell',
	    'metropolis.ogg': 'Metropolis',
	    'pianoforte.ogg': 'Pianoforte',
	    'quiet lab.ogg': 'Quiet Lab',
	    'rising temper.ogg': 'Rising Temper',
	    'seaside revisited.ogg': 'Seaside Revisited',
	    'shell.ogg': 'Shell',
	    'the race.ogg': 'The Race',
	    'tim trance.ogg': 'Tim Trance',
	    'xmas trance.ogg': 'Xmas Trance'
	};
	class Jukebox {
	    constructor(menu) {
	        this.div = document.querySelector('#jukebox');
	        this.songsContainer = document.querySelector('#jukebox-songs');
	        this.textElement = document.querySelector('#jukebox-text');
	        this.closeButton = document.querySelector('#jukebox-close');
	        this.prevButton = document.querySelector('#jukebox-prev');
	        this.playButton = document.querySelector('#jukebox-play');
	        this.nextButton = document.querySelector('#jukebox-next');
	        this.selectedIndex = null;
	        this._playing = true;
	        this.menu = menu;
	        menu.setupButton(this.closeButton, 'jukebox/close', () => this.hide());
	        menu.setupButton(this.prevButton, 'play/prev', () => this.select(Object.keys(SONGS)[this.selectedIndex - 1]), true);
	        menu.setupVaryingButton(this.playButton, ['jukebox/stop', 'jukebox/play'], () => {
	            var _a, _b;
	            if (this.playing) {
	                (_a = G$1.level.music) === null || _a === void 0 ? void 0 : _a.stop();
	                this.playing = false;
	            }
	            else {
	                if (this.selectedIndex !== null)
	                    this.select(Object.keys(SONGS)[this.selectedIndex]);
	                else {
	                    // Restart the default song
	                    (_b = G$1.level.music) === null || _b === void 0 ? void 0 : _b.play();
	                    this.playing = true;
	                }
	            }
	            this.updateText();
	        });
	        menu.setupButton(this.nextButton, 'play/next', () => this.select(Object.keys(SONGS)[this.selectedIndex + 1]), true);
	        window.addEventListener('keydown', (e) => {
	            if (!this.div.classList.contains('hidden') && e.key === 'Escape') {
	                this.closeButton.src = menu.uiAssetPath + 'jukebox/close_d.png';
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (!this.div.classList.contains('hidden') && e.key === 'Escape') {
	                this.closeButton.src = menu.uiAssetPath + 'jukebox/close_n.png';
	                this.hide();
	            }
	        });
	        // Create all the elements for the songs
	        for (let key in SONGS) {
	            let element = document.createElement('div');
	            element.textContent = SONGS[key];
	            this.songsContainer.appendChild(element);
	            element.addEventListener('mousedown', () => this.select(key));
	        }
	    }
	    get playing() {
	        return this._playing;
	    }
	    set playing(state) {
	        this._playing = state;
	        this.menu.setButtonVariant(this.playButton, 1 - Number(state)); // Automagically✨ update the button too
	    }
	    /** Selects a given song and plays it. */
	    select(song) {
	        if (!SONGS[song])
	            return;
	        let index = Object.keys(SONGS).indexOf(song);
	        this.selectedIndex = index;
	        for (let i = 0; i < this.songsContainer.children.length; i++) {
	            this.songsContainer.children[i].classList.remove('selected');
	            if (i === index)
	                this.songsContainer.children[i].classList.add('selected');
	        }
	        let level = G$1.level;
	        if (level.music)
	            level.music.stop();
	        level.music = AudioManager$1.createAudioSource('music/' + song, AudioManager$1.musicGain, undefined, true);
	        level.music.setLoop(true);
	        level.music.play();
	        this.playing = true;
	        this.updateNextPrevButtons();
	        this.updateText();
	    }
	    updateNextPrevButtons() {
	        // Enable or disable the next button based on if there are still songs to come
	        if (this.selectedIndex === null || this.selectedIndex === Object.keys(SONGS).length - 1) {
	            this.nextButton.src = this.menu.uiAssetPath + 'play/next_i.png';
	            this.nextButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.nextButton.src.endsWith('i.png'))
	                this.nextButton.src = this.menu.uiAssetPath + 'play/next_n.png';
	            this.nextButton.style.pointerEvents = '';
	        }
	        // Enable or disable the prev button based on if there are still songs to come
	        if (this.selectedIndex === null || this.selectedIndex === 0) {
	            this.prevButton.src = this.menu.uiAssetPath + 'play/prev_i.png';
	            this.prevButton.style.pointerEvents = 'none';
	        }
	        else {
	            if (this.prevButton.src.endsWith('i.png'))
	                this.prevButton.src = this.menu.uiAssetPath + 'play/prev_n.png';
	            this.prevButton.style.pointerEvents = '';
	        }
	    }
	    updateText() {
	        if (this.selectedIndex === null)
	            this.textElement.innerHTML = '';
	        else
	            this.textElement.innerHTML = `Title: ${SONGS[Object.keys(SONGS)[this.selectedIndex]]}<br>${this.playing ? 'Playing' : 'Stopped'}`;
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        G$1.menu.pauseScreen.preventClose = true;
	        if (this.selectedIndex === null) {
	            // This runs if this was the first time in the current level that the jukebox was opened.
	            for (let child of this.songsContainer.children)
	                child.classList.remove('selected');
	            let index = Object.keys(SONGS).indexOf(G$1.level.originalMusicName);
	            if (index >= 0) {
	                this.songsContainer.children[index].classList.add('selected');
	                this.selectedIndex = index;
	            }
	            this.playing = true;
	            this.updateNextPrevButtons();
	            this.updateText();
	        }
	        // Scroll the current song into view
	        let selectedElem = [...this.songsContainer.children].find(x => x.classList.contains('selected'));
	        if (selectedElem)
	            selectedElem.scrollIntoView({ block: "nearest", inline: "nearest" });
	    }
	    hide() {
	        this.div.classList.add('hidden');
	        G$1.menu.pauseScreen.preventClose = false;
	    }
	    reset() {
	        this.selectedIndex = null;
	    }
	}
	//# sourceMappingURL=pause_screen_mbp.js.map

	const DEFAULT_ROOT_NODE_SIZE = 1;
	const MIN_DEPTH = -32;
	const MAX_DEPTH = 8;
	let v1$4 = new Vector3$1();
	let v2$1 = new Vector3$1();
	let b1 = new Box3();
	/** A dynamic, loose octree of bounding boxes for efficient spatial operations such as raytracing. Implemented without any cringe. */
	class Octree {
	    constructor() {
	        this.beforeOperation = null;
	        this.root = new OctreeNode(this, 0);
	        // Init the octree to a 1x1x1 cube
	        this.root.min.set(0, 0, 0);
	        this.root.size = DEFAULT_ROOT_NODE_SIZE;
	        this.objectToNode = new WeakMap();
	    }
	    insert(object) {
	        let node = this.objectToNode.get(object);
	        if (node)
	            return; // Don't insert if already contained in the tree
	        if (!object.boundingBox.min.equals(object.boundingBox.min) || !object.boundingBox.max.equals(object.boundingBox.max)) {
	            console.log("object");
	            console.warn(`Can't insert NaN bounding box object into octree, my guy!`);
	            return;
	        }
	        while (!this.root.largerThan(object) || !this.root.containsCenter(object)) {
	            // The root node does not fit the object; we need to grow the tree.
	            if (this.root.depth === MIN_DEPTH) {
	                console.log(object);
	                console.warn(`Can't insert ${this.root.largerThan(object) ? 'distant' : 'large'} object into octree; the octree has already expanded to its maximum size.`);
	                return;
	            }
	            this.grow(object);
	        }
	        let emptyBefore = this.root.count === 0;
	        this.root.insert(object);
	        if (emptyBefore)
	            this.shrink(); // See if we can fit the octree better now that we actually have an element in it
	    }
	    remove(object) {
	        let node = this.objectToNode.get(object);
	        if (!node)
	            return;
	        node.remove(object);
	        this.objectToNode.delete(object);
	        this.shrink(); // Try shrinking the octree
	    }
	    /** Updates an object in the tree whose bounding box has changed. */
	    update(object) {
	        // this.remove(object);
	        // this.insert(object);
	        // return;
	        let node = this.objectToNode.get(object);
	        if (!node) {
	            this.insert(object);
	            return;
	        }
	        let success = node.update(object);
	        if (!success) {
	            this.objectToNode.delete(object);
	            this.insert(object);
	        }
	    }
	    /** Expand the octree towards an object that doesn't fit in it. */
	    grow(towards) {
	        // We wanna grow towards all the vertices of the object's bounding box that lie outside the octree, so we determine the average position of those vertices:
	        let averagePoint = v1$4.set(0, 0, 0);
	        let count = 0;
	        for (let i = 0; i < 8; i++) {
	            let vec = v2$1;
	            vec.setComponent(0, (i & 0b001) ? towards.boundingBox.min.x : towards.boundingBox.max.x);
	            vec.setComponent(1, (i & 0b010) ? towards.boundingBox.min.y : towards.boundingBox.max.y);
	            vec.setComponent(2, (i & 0b100) ? towards.boundingBox.min.z : towards.boundingBox.max.z);
	            if (!this.root.containsPoint(vec)) {
	                averagePoint.add(vec);
	                count++;
	            }
	        }
	        averagePoint.multiplyScalar(1 / count); // count should be greater than 0, because that's why we're growing in the first place.
	        // Determine the direction from the root center to the determined point
	        let rootCenter = v2$1.copy(this.root.min).addScalar(this.root.size / 2);
	        let direction = averagePoint.sub(rootCenter); // Determine the "direction of growth"
	        // Create a new root. The current root will become a quadrant in this new root.
	        let newRoot = new OctreeNode(this, this.root.depth - 1);
	        newRoot.min.copy(this.root.min);
	        newRoot.size = this.root.size * 2;
	        if (direction.x < 0)
	            newRoot.min.x -= this.root.size;
	        if (direction.y < 0)
	            newRoot.min.y -= this.root.size;
	        if (direction.z < 0)
	            newRoot.min.z -= this.root.size;
	        if (this.root.count > 0) {
	            let octantIndex = ((direction.x < 0) ? 1 : 0) + ((direction.y < 0) ? 2 : 0) + ((direction.z < 0) ? 4 : 0);
	            newRoot.createOctants();
	            newRoot.octants[octantIndex] = this.root;
	            this.root.parent = newRoot;
	            newRoot.count = this.root.count;
	            newRoot.merge();
	        }
	        this.root = newRoot;
	    }
	    /** Tries to shrink the octree if large parts of the octree are empty. */
	    shrink() {
	        if (this.root.size < DEFAULT_ROOT_NODE_SIZE || this.root.objects.size > 0)
	            return;
	        if (this.root.count === 0) {
	            // Reset to default empty octree
	            this.root.min.set(0, 0, 0);
	            this.root.size = DEFAULT_ROOT_NODE_SIZE;
	            this.root.depth = 0;
	            return;
	        }
	        if (!this.root.octants)
	            return;
	        // Find the only non-empty octant
	        let nonEmptyOctant;
	        for (let i = 0; i < 8; i++) {
	            let octant = this.root.octants[i];
	            if (octant.count > 0) {
	                if (nonEmptyOctant)
	                    return; // There are more than two non-empty octants -> don't shrink.
	                else
	                    nonEmptyOctant = octant;
	            }
	        }
	        // Make the only non-empty octant the new root
	        this.root = nonEmptyOctant;
	        nonEmptyOctant.parent = null;
	        this.shrink();
	    }
	    intersectAabb(aabb) {
	        var _a;
	        (_a = this.beforeOperation) === null || _a === void 0 ? void 0 : _a.call(this);
	        let intersections = [];
	        this.root.intersectAabb(aabb, intersections);
	        return intersections;
	    }
	    intersectRay(rayOrigin, rayDirection, lambdaMax) {
	        v1$4.copy(rayDirection).normalize();
	        lambdaMax *= rayDirection.length();
	        let intersections = [];
	        this.root.intersectRay(rayOrigin, v1$4, lambdaMax, intersections);
	        return intersections;
	    }
	    // todo keep this?
	    intersectOctreeObject(object) {
	        let node = this.objectToNode.get(object);
	        if (!node)
	            return [];
	        let intersections = [];
	        while (node.parent) {
	            let strictBoundingBox = b1;
	            strictBoundingBox.min.copy(node.min);
	            strictBoundingBox.max.copy(node.min).addScalar(node.size);
	            if (strictBoundingBox.containsBox(object.boundingBox))
	                break;
	            node = node.parent;
	        }
	        node.intersectAabb(object.boundingBox, intersections);
	        while (node.parent) {
	            node = node.parent;
	            node.intersectAabb(object.boundingBox, intersections, false);
	        }
	        return intersections;
	    }
	}
	class OctreeNode {
	    constructor(octree, depth) {
	        this.parent = null;
	        /** The min corner of the bounding box. */
	        this.min = new Vector3$1();
	        this.octants = null;
	        /** A list of objects contained in this node. Note that the node doesn't need to be a leaf node for this set to be non-empty; since this is an octree of bounding boxes, some volumes cannot fit into an octant and therefore need to be stored in the node itself. */
	        this.objects = new Set();
	        /** The total number of objects in the subtree with this node as its root. */
	        this.count = 0;
	        this.octree = octree;
	        this.depth = depth;
	    }
	    insert(object) {
	        this.count++;
	        //this.intersectAabb2(object);
	        if (this.octants) {
	            // First we check if the object can fit into any of the octants (they all have the same size, so checking only one suffices)
	            if (this.octants[0].largerThan(object)) {
	                // Try to insert the object into one of the octants...
	                for (let i = 0; i < 8; i++) {
	                    let octant = this.octants[i];
	                    if (octant.containsCenter(object)) {
	                        octant.insert(object);
	                        return;
	                    }
	                }
	            }
	            // No octant fit the object, so add it to the list of objects instead
	            this.objects.add(object);
	            this.octree.objectToNode.set(object, this);
	        }
	        else {
	            this.objects.add(object);
	            this.octree.objectToNode.set(object, this);
	            this.split(); // Try splitting this node
	        }
	    }
	    split() {
	        if (this.objects.size <= 8 || this.depth === MAX_DEPTH)
	            return;
	        this.createOctants();
	        // Put the objects into the correct octants. Note that all objects that couldn't fit into any octant will remain in the set.
	        for (let object of this.objects) {
	            if (this.octants[0].largerThan(object)) {
	                for (let j = 0; j < 8; j++) {
	                    let octant = this.octants[j];
	                    if (octant.containsCenter(object)) {
	                        octant.insert(object);
	                        this.objects.delete(object);
	                    }
	                }
	            }
	        }
	        // Try recursively splitting each octant
	        for (let i = 0; i < 8; i++) {
	            this.octants[i].split();
	        }
	    }
	    createOctants() {
	        this.octants = [];
	        for (let i = 0; i < 8; i++) {
	            let newNode = new OctreeNode(this.octree, this.depth + 1);
	            newNode.parent = this;
	            newNode.size = this.size / 2;
	            newNode.min.set(this.min.x + newNode.size * ((i & 0b001) >> 0), // The x coordinate changes every index
	            this.min.y + newNode.size * ((i & 0b010) >> 1), // The y coordinate changes every 2 indices
	            this.min.z + newNode.size * ((i & 0b100) >> 2) // The z coordinate changes every 4 indices
	            );
	            this.octants.push(newNode);
	        }
	    }
	    // Note: The requirement for this method to be called is that `object` is contained directly in this node.
	    remove(object) {
	        this.objects.delete(object);
	        this.count--;
	        this.merge();
	        // Clean up all ancestors
	        let node = this.parent;
	        while (node) {
	            node.count--; // Reduce the count for all ancestor nodes up until the root
	            node.merge();
	            node = node.parent;
	        }
	    }
	    // Basically first performs a remove, then walks up the tree to find the closest ancestor that can fit the object, then inserts it.
	    update(object) {
	        this.objects.delete(object);
	        let node = this;
	        while (node) {
	            node.count--;
	            node.merge();
	            if (node.largerThan(object) && node.containsCenter(object)) {
	                node.insert(object);
	                return true;
	            }
	            node = node.parent;
	        }
	        return false; // Nothing worked, we need to properly grow the tree
	    }
	    merge() {
	        if (this.count > 8 || !this.octants)
	            return;
	        // Add all objects in the octants back to this node
	        for (let i = 0; i < 8; i++) {
	            let octant = this.octants[i];
	            for (let object of octant.objects) {
	                this.objects.add(object);
	                this.octree.objectToNode.set(object, this);
	            }
	        }
	        this.octants = null; // ...then delete the octants
	    }
	    largerThan(object) {
	        let box = object.boundingBox;
	        return this.size > (box.max.x - box.min.x) &&
	            this.size > (box.max.y - box.min.y) &&
	            this.size > (box.max.z - box.min.z);
	    }
	    containsCenter(object) {
	        let box = object.boundingBox;
	        let x = box.min.x + (box.max.x - box.min.x) / 2;
	        let y = box.min.y + (box.max.y - box.min.y) / 2;
	        let z = box.min.z + (box.max.z - box.min.z) / 2;
	        return this.min.x <= x && x < (this.min.x + this.size) &&
	            this.min.y <= y && y < (this.min.y + this.size) &&
	            this.min.z <= z && z < (this.min.z + this.size);
	    }
	    containsPoint(point) {
	        let { x, y, z } = point;
	        return this.min.x <= x && x < (this.min.x + this.size) &&
	            this.min.y <= y && y < (this.min.y + this.size) &&
	            this.min.z <= z && z < (this.min.z + this.size);
	    }
	    intersectAabb(aabb, intersections, recurse = false) {
	        let looseBoundingBox = b1;
	        looseBoundingBox.min.copy(this.min).addScalar(-this.size / 2);
	        looseBoundingBox.max.copy(this.min).addScalar(this.size * 3 / 2);
	        if (!aabb.intersectsBox(looseBoundingBox))
	            return;
	        // Test all objects for intersection
	        if (this.objects.size > 0)
	            for (let object of this.objects) {
	                if (aabb.intersectsBox(object.boundingBox))
	                    intersections.push(object);
	            }
	        // Recurse into the octants
	        if (this.octants)
	            for (let i = 0; i < 8; i++) {
	                let octant = this.octants[i];
	                if (octant.count === 0)
	                    continue;
	                octant.intersectAabb(aabb, intersections);
	            }
	    }
	    intersectRay(rayOrigin, rayDirection, lambdaMax, intersections) {
	        // Construct the loose bounding box of this node (2x in size, with the regular bounding box in the center)
	        let looseBoundingBox = b1;
	        looseBoundingBox.min.copy(this.min).addScalar(-this.size / 2);
	        looseBoundingBox.max.copy(this.min).addScalar(this.size * 3 / 2);
	        if (!Util$1.rayIntersectsBox(rayOrigin, rayDirection, lambdaMax, looseBoundingBox))
	            return; // The ray doesn't hit the node's loose bounding box; we can stop
	        // Test all objects for intersection
	        if (this.objects.size > 0)
	            for (let object of this.objects) {
	                if (Util$1.rayIntersectsBox(rayOrigin, rayDirection, lambdaMax, object.boundingBox)) {
	                    intersections.push(object);
	                }
	            }
	        // Recurse into the octants
	        if (this.octants)
	            for (let i = 0; i < 8; i++) {
	                let octant = this.octants[i];
	                octant.intersectRay(rayOrigin, rayDirection, lambdaMax, intersections);
	            }
	    }
	    intersectAabb2(object) {
	        let aabb = object.boundingBox;
	        let looseBoundingBox = b1;
	        looseBoundingBox.min.copy(this.min).addScalar(-this.size / 2);
	        looseBoundingBox.max.copy(this.min).addScalar(this.size * 3 / 2);
	        if (!aabb.intersectsBox(looseBoundingBox))
	            return;
	        // Test all objects for intersection
	        if (this.objects.size > 0)
	            for (let otherObject of this.objects) {
	                if (aabb.intersectsBox(otherObject.boundingBox)) {
	                    object.adjacent.add(otherObject);
	                    otherObject.adjacent.add(object);
	                }
	            }
	        // Recurse into the octants
	        if (this.octants)
	            for (let i = 0; i < 8; i++) {
	                let octant = this.octants[i];
	                if (octant.count === 0)
	                    continue;
	                octant.intersectAabb2(object);
	            }
	    }
	}
	//# sourceMappingURL=octree.js.map

	let v1$5 = new Vector3$1();
	let q1$3 = new Quaternion$1();
	/** Represents a collision between two shapes. */
	class Collision {
	    constructor(s1, s2) {
	        /** The time of impact assuming linear translation of both shapes. */
	        this.timeOfImpact = 1;
	        this.s1MaterialOverride = null;
	        this.s2MaterialOverride = null;
	        this.customVelocitySolver = null;
	        this.s1 = s1;
	        this.s2 = s2;
	        this.friction = s1.friction * s2.friction;
	        this.restitution = s1.restitution * s2.restitution;
	        this.s1Friction = s1.friction;
	        this.s1Restitution = s1.restitution;
	        this.s2Friction = s2.friction;
	        this.s2Restitution = s2.restitution;
	    }
	    supplyCollisionPlane(plane) {
	        this.normal = plane.normal.clone(); // Make sure to clone it here so no funky stuff happens
	        this.depth = plane.constant;
	        this.point1 = this.s1.support(new Vector3$1(), v1$5.copy(this.normal).negate()); // Horribly wrong in the general case, but gives the correct result if s1 is a ball
	        this.point2 = this.point1.clone().addScaledVector(this.normal, this.depth);
	        this.point = this.point1.clone().add(this.point2).multiplyScalar(0.5);
	    }
	    /** Updates the collision's friction and restitution if necessary. */
	    updateMaterialProperties() {
	        if (!this.normal)
	            return;
	        // Check for material overrides (check CollisionShape for more explanation on why)
	        if (this.s1.materialOverrides.size > 0 || this.s2.materialOverrides.size > 0) {
	            let s1Friction = this.s1.friction;
	            let s2Friction = this.s2.friction;
	            let s1Restitution = this.s1.restitution;
	            let s2Restitution = this.s2.restitution;
	            let max = -Infinity;
	            let min = Infinity;
	            let transformedNormal = v1$5;
	            q1$3.copy(this.s1.body.orientation).conjugate();
	            transformedNormal.copy(this.normal).applyQuaternion(q1$3);
	            // Find the override for s1
	            for (let [vec, material] of this.s1.materialOverrides) {
	                let dot = vec.dot(transformedNormal);
	                if (dot < min) {
	                    min = dot;
	                    s1Friction = material.friction;
	                    s1Restitution = material.restitution;
	                    this.s1MaterialOverride = vec;
	                }
	            }
	            q1$3.copy(this.s2.body.orientation).conjugate();
	            transformedNormal.copy(this.normal).applyQuaternion(q1$3);
	            // Find the override for s2
	            for (let [vec, material] of this.s2.materialOverrides) {
	                let dot = vec.dot(transformedNormal);
	                if (dot > max) {
	                    max = dot;
	                    s2Friction = material.friction;
	                    s2Restitution = material.restitution;
	                    this.s2MaterialOverride = vec;
	                }
	            }
	            // Compute the final friction and restitution
	            this.friction = s1Friction * s2Friction;
	            this.restitution = s1Restitution * s2Restitution;
	            this.s1Friction = s1Friction;
	            this.s1Restitution = s1Restitution;
	            this.s2Friction = s2Friction;
	            this.s2Restitution = s2Restitution;
	        }
	    }
	}
	//# sourceMappingURL=collision.js.map

	const maxIterations = 64;
	const maxEpaFaces = 64;
	const epaTolerance = 10 * Number.EPSILON;
	const maxEpaLooseEdges = 64;
	const maxEpaIterations = 64;
	// Global algorithm state
	/** The points of the current simplex. Only points with index < numPoints are valid. */
	let points = [new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1()];
	/** The amount of points in the current simplex. */
	let numPoints = 0;
	let support = new Vector3$1();
	let direction = new Vector3$1();
	let ao = new Vector3$1();
	let bo = new Vector3$1();
	let co = new Vector3$1();
	let ab = new Vector3$1();
	let ac = new Vector3$1();
	let ad = new Vector3$1();
	let bc = new Vector3$1();
	let bd = new Vector3$1();
	let abc = new Vector3$1();
	let acd = new Vector3$1();
	let adb = new Vector3$1();
	let bdc = new Vector3$1();
	let v1$6 = new Vector3$1();
	let v2$2 = new Vector3$1();
	let translation = new Vector3$1();
	let actualPosition1 = new Vector3$1();
	let actualPosition2 = new Vector3$1();
	let x = new Vector3$1();
	let n = new Vector3$1();
	let w = new Vector3$1();
	/** Indicates if the current triangle (3-point simplex) needs to have its winding order reversed. */
	let requireFlip = 0;
	let lastS1 = null;
	let lastS2 = null;
	let o = new Vector3$1(0, 0, 0);
	let singletonShape = new SingletonCollisionShape();
	let singletonBody = new RigidBody();
	singletonBody.addCollisionShape(singletonShape);
	// EPA state
	let faces = [];
	let looseEdges = [];
	for (let i = 0; i < maxEpaIterations; i++) {
	    faces.push([new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1()]);
	}
	for (let i = 0; i < maxEpaLooseEdges; i++) {
	    looseEdges.push([new Vector3$1(), new Vector3$1()]);
	}
	/** Provides methods for testing for intersection of convex shapes. */
	class CollisionDetection {
	    /** Joined support function; returns the support function of the Minkowski difference of shape 1 and 2. */
	    static support(dst, s1, s2, direction) {
	        return s1.support(dst, direction).sub(s2.support(v1$6, v2$2.copy(direction).negate()));
	    }
	    /** Returns true iff `s1` and `s2` intersect. */
	    static checkIntersection(s1, s2) {
	        // Remember the shapes for later
	        lastS1 = s1;
	        lastS2 = s2;
	        if (s1 instanceof BallCollisionShape && s2 instanceof BallCollisionShape) {
	            // Since this case is trivial, we have a special method for it to process it quickly
	            return this.checkBallBallIntersection(s1, s2);
	        }
	        else if (s1 instanceof BallCollisionShape) {
	            // This case is less trivial and does require GJK but does *not* require EPA later on, so use a special method for this also
	            return this.checkBallConvexIntersection(s1, s2);
	        }
	        else {
	            // Otherwise, do general GJK
	            return this.checkConvexConvexIntersection(s1, s2);
	        }
	    }
	    static checkBallBallIntersection(s1, s2) {
	        // Simply compare distance and radius sum
	        return s1.body.position.distanceTo(s2.body.position) <= s1.radius + s2.radius;
	    }
	    static checkBallConvexIntersection(s1, s2) {
	        singletonBody.position.copy(s1.body.position);
	        // All we need to do is compute the closest point on s2 to s1's center. After that, a simple comparison with the radius will suffice.
	        let closestPoint = this.determineClosestPoint(new Vector3$1(), s2, singletonShape);
	        let distanceSq = closestPoint.lengthSq();
	        return distanceSq <= s1.radius ** 2;
	    }
	    /** Check for intersection of two shapes using the boolean Gilbert-Johnson-Keerthi (GJK) algorithm. */
	    static checkConvexConvexIntersection(s1, s2) {
	        direction.copy(s2.body.position).sub(s1.body.position).normalize(); // Can really be anything but this is a good start
	        this.support(support, s1, s2, direction);
	        numPoints = 1;
	        points[0].copy(support);
	        direction.copy(support).negate(); // ao
	        for (let i = 0; i < maxIterations; i++) {
	            this.support(support, s1, s2, direction);
	            if (support.dot(direction) <= 0) {
	                // No collision
	                return false;
	            }
	            // Update the simplex
	            this.addPointToSimplex(support);
	            this.updateSimplexFast();
	            if (numPoints === 4) {
	                // We managed to enclose the origin in a tetrahedron, meaning we're intersecting
	                return true;
	            }
	        }
	        return false;
	    }
	    /** Computes the closest point to the origin in the Minkowski difference of s1 and s2. */
	    static determineClosestPoint(dst, s1, s2) {
	        direction.copy(s2.body.position).sub(s1.body.position);
	        numPoints = 0;
	        for (let i = 0; i < maxIterations; i++) {
	            this.support(support, s1, s2, direction);
	            if (direction.lengthSq() + direction.dot(support) <= 10 * Number.EPSILON)
	                break;
	            this.addPointToSimplex(support);
	            this.updateSimplexAndClosestPoint(direction);
	            direction.negate();
	            if (numPoints === 4)
	                break;
	        }
	        return dst.copy(direction).negate();
	    }
	    /** Determines the time of impact of two moving shapes by simply linearly translating the shapes between their last and current position. */
	    static determineTimeOfImpact(s1, s2, eps = 0.03) {
	        s1.body.getRelativeMotionVector(translation, s2.body); // We assume s2 is stationary and s1's movement is now relative to s2's frame
	        let translationLength = translation.length();
	        // Remember the positions and revert the shapes back one position
	        actualPosition1.copy(s1.body.position);
	        actualPosition2.copy(s2.body.position);
	        s1.body.position.copy(s1.body.prevPosition);
	        s2.body.position.copy(s2.body.prevPosition);
	        // A simple ray cast on the Minkowski difference will return the time of impact
	        let res = this.castRay(s2, s1, o, translation, 1);
	        // Reset the position
	        s1.body.position.copy(actualPosition1);
	        s2.body.position.copy(actualPosition2);
	        if (!res)
	            return null;
	        // To ensure that collision is actually detected, nudge the point of impact a little bit forward so the shapes definitely intersect.
	        let toAdd = Math.min(eps * translationLength, eps / translationLength); // Don't ask, there's no clean derivation for this
	        res.lambda += toAdd;
	        res.lambda = Util$1.clamp(res.lambda, 0, 1);
	        return res.lambda;
	    }
	    /** Performs a GJK ray cast on the Minkowski difference of two shapes. Uses the method described by Gino van den Bergen in http://dtecta.com/papers/jgt04raycast.pdf. */
	    static castRay(s1, s2, rayOrigin, rayDirection, lambdaMax) {
	        direction.copy(s2.body.position).sub(s1.body.position).normalize();
	        this.support(support, s1, s2, direction);
	        numPoints = 0;
	        x.copy(rayOrigin); // x will be the point of impact
	        n.setScalar(0); // n will be the surface normal at the point of impact
	        let lambda = 0; // lambda will be the number such that origin + lambda * direction = x
	        direction.copy(x).sub(support);
	        for (let i = 0; i < maxIterations; i++) {
	            this.support(support, s1, s2, direction);
	            w.copy(x).sub(support);
	            if (direction.dot(w) > 0) {
	                if (direction.dot(rayDirection) >= 0)
	                    return null;
	                // Nudge forward
	                let delta = direction.dot(w) / direction.dot(rayDirection);
	                lambda -= delta;
	                if (lambda > lambdaMax)
	                    return null;
	                x.copy(rayOrigin).addScaledVector(rayDirection, lambda);
	                n.copy(direction);
	            }
	            this.addPointToSimplex(support);
	            // Offset the entire simplex temporarily
	            for (let i = 0; i < numPoints; i++)
	                points[i].negate().add(x);
	            // This now finds the feature of the simplex closest to x, not the origin anymore, because we offset the simplex.
	            this.updateSimplexAndClosestPoint(direction);
	            let maxDist2 = 0;
	            for (let i = 0; i < numPoints; i++) {
	                maxDist2 = Math.max(maxDist2, points[i].distanceToSquared(x));
	            }
	            if (direction.lengthSq() < 10 * Number.EPSILON * maxDist2) {
	                return { point: x.clone(), lambda, normal: n.clone().normalize() };
	            }
	            // Offset the simplex back
	            for (let i = 0; i < numPoints; i++)
	                points[i].sub(x).negate();
	        }
	        return null;
	    }
	    /** Expands the current simplex by one point. */
	    static addPointToSimplex(p) {
	        // Check if the point is already contained in the simplex, and if so, don't add it
	        for (let i = 0; i < numPoints; i++) {
	            if (p.distanceToSquared(points[i]) < 10 * Number.EPSILON)
	                return;
	        }
	        // Shift all points one to the right
	        for (let i = numPoints; i > 0; i--) {
	            points[i].copy(points[i - 1]);
	        }
	        // Add the point at the front
	        points[0].copy(p);
	        numPoints++;
	    }
	    /** Updates the simplex and search direction quickly, meaning it doesn't perform a thourough search for the precise closest feature but just gets the general direction right. Uses the approach from https://blog.winter.dev/2020/gjk-algorithm/. */
	    static updateSimplexFast() {
	        switch (numPoints) {
	            case 2: return this.updateLine();
	            case 3: return this.updateTriangle();
	            case 4: return this.updateTetrahedron();
	            default: throw new Error("Shouldn't happen: " + numPoints);
	        }
	    }
	    static updateLine() {
	        let a = points[0];
	        let b = points[1];
	        ab.copy(b).sub(a);
	        ao.copy(a).negate();
	        if (ab.dot(ao) > 0) {
	            // Keep searching perpendicular to the line
	            direction.copy(ab).cross(ao).cross(ab);
	        }
	        else {
	            // Discard point B
	            numPoints--;
	            direction.copy(ao);
	        }
	    }
	    static updateTriangle() {
	        let a = points[0];
	        let b = points[1];
	        let c = points[2];
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ao.copy(a).negate();
	        abc.copy(ab).cross(ac);
	        if (v1$6.copy(abc).cross(ac).dot(ao) > 0) {
	            if (ac.dot(ao) > 0) {
	                // We're on the AC side
	                b.copy(c);
	                numPoints--;
	                direction.copy(ac).cross(ao).cross(ac);
	            }
	            else {
	                // We're on the AB side
	                numPoints--;
	                return this.updateLine();
	            }
	        }
	        else {
	            if (v1$6.copy(ab).cross(abc).dot(ao) > 0) {
	                // We're on the AB side
	                numPoints--;
	                return this.updateLine();
	            }
	            else {
	                // Origin must be above or below the triangle, figure out the direction
	                if (abc.dot(ao) > 0) {
	                    direction.copy(abc);
	                }
	                else {
	                    v1$6.copy(c);
	                    c.copy(b);
	                    b.copy(v1$6);
	                    direction.copy(abc).negate();
	                }
	            }
	        }
	    }
	    static updateTetrahedron() {
	        let a = points[0];
	        let b = points[1];
	        let c = points[2];
	        let d = points[3];
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ad.copy(d).sub(a);
	        ao.copy(a).negate();
	        abc.copy(ab).cross(ac);
	        acd.copy(ac).cross(ad);
	        adb.copy(ad).cross(ab);
	        // Simply do a triangle case with the face that's pointing towards the origin
	        if (abc.dot(ao) > 0) {
	            numPoints--;
	            return this.updateTriangle();
	        }
	        else if (acd.dot(ao) > 0) {
	            b.copy(c);
	            c.copy(d);
	            numPoints--;
	            return this.updateTriangle();
	        }
	        else if (adb.dot(ao) > 0) {
	            c.copy(b);
	            b.copy(d);
	            numPoints--;
	            return this.updateTriangle();
	        }
	        // If we're here, the origin is enclosed!
	    }
	    /** Computes the closest point to the origin on the current simplex and reduces the simplex to the smallest feature that contains that point. Method somewhat inspired by BulletPhysics. */
	    static updateSimplexAndClosestPoint(dst) {
	        let used; // A 4-bit number where the i'th bit represents if the i'th point (order: A, B, C, D) is present in the reduced feature.
	        requireFlip = 0;
	        switch (numPoints) {
	            case 1:
	                used = this.closestPointPoint(dst, points[0]);
	                break;
	            case 2:
	                used = this.closestPointLineSegment(dst, points[0], points[1]);
	                break;
	            case 3:
	                used = this.closestPointTriangle(dst, points[0], points[1], points[2]);
	                break;
	            case 4:
	                used = this.closestPointTetrahedron(dst, points[0], points[1], points[2], points[3]);
	                break;
	            default: throw new Error("Shouldn't get here! " + numPoints);
	        }
	        // Do the whole point assignerino based on whatever points make up the closest feature
	        let i = 0;
	        for (let j = 0; j < 4; j++) {
	            if (used & (1 << j)) {
	                points[i].copy(points[j]);
	                i++;
	            }
	        }
	        numPoints = i;
	        // Flip winding order of triangle if needed
	        if (requireFlip) {
	            v1$6.copy(points[1]);
	            points[1].copy(points[2]);
	            points[2].copy(v1$6);
	        }
	    }
	    static closestPointPoint(dst, a) {
	        dst.copy(a);
	        return 0b0001;
	    }
	    static closestPointLineSegment(dst, a, b) {
	        ab.copy(b).sub(a);
	        ao.copy(a).negate();
	        let t = Util$1.clamp(ab.dot(ao) / ab.dot(ab), 0, 1); // Clamp to the line segment
	        if (t === 0) {
	            dst.copy(a);
	            return 0b0001;
	        }
	        else if (t === 1) {
	            dst.copy(b);
	            return 0b0010;
	        }
	        else {
	            dst.copy(a).addScaledVector(ab, t);
	            return 0b0011;
	        }
	    }
	    static closestPointTriangle(dst, a, b, c) {
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ao.copy(a).negate();
	        let d1 = ab.dot(ao);
	        let d2 = ac.dot(ao);
	        if (d1 <= 0 && d2 <= 0) {
	            dst.copy(a);
	            return 0b0001;
	        }
	        bo.copy(b).negate();
	        let d3 = ab.dot(bo);
	        let d4 = ac.dot(bo);
	        if (d3 >= 0 && d4 <= d3) {
	            dst.copy(b);
	            return 0b0010;
	        }
	        let vc = d1 * d4 - d3 * d2;
	        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
	            let v = d1 / (d1 - d3);
	            dst.copy(a).addScaledVector(ab, v);
	            return 0b0011;
	        }
	        co.copy(c).negate();
	        let d5 = ab.dot(co);
	        let d6 = ac.dot(co);
	        if (d6 >= 0 && d5 <= d6) {
	            dst.copy(c);
	            return 0b0100;
	        }
	        let vb = d5 * d2 - d1 * d6;
	        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
	            let w = d2 / (d2 - d6);
	            dst.copy(a).addScaledVector(ac, w);
	            return 0b0101;
	        }
	        let va = d3 * d6 - d5 * d4;
	        if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
	            bc.copy(c).sub(b);
	            let w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
	            dst.copy(b).addScaledVector(bc, w);
	            return 0b0110;
	        }
	        let denom = 1 / (va + vb + vc);
	        let v = vb * denom;
	        let w = vc * denom;
	        dst.copy(a).addScaledVector(ab, v).addScaledVector(ac, w);
	        abc.copy(ab).cross(ac);
	        if (abc.dot(dst) > 0) {
	            requireFlip ^= 1;
	        }
	        return 0b0111;
	    }
	    static closestPointTetrahedron(dst, a, b, c, d) {
	        ab.copy(b).sub(a);
	        ac.copy(c).sub(a);
	        ad.copy(d).sub(a);
	        bc.copy(c).sub(b);
	        bd.copy(d).sub(b);
	        ao.copy(a).negate();
	        bo.copy(b).negate();
	        abc.copy(ab).cross(ac);
	        acd.copy(ac).cross(ad);
	        adb.copy(ad).cross(ab);
	        bdc.copy(bd).cross(bc);
	        // Figure out which faces we need to check
	        let outsideABC = abc.dot(ao) > 0;
	        let outsideACD = acd.dot(ao) > 0;
	        let outsideADB = adb.dot(ao) > 0;
	        let outsideBDC = bdc.dot(bo) > 0;
	        let minDist = Infinity;
	        let used;
	        let flip; // The face winding flip of the face with the min dist
	        // We simply do 4 triangle cases, one for each face of the tetrahedron, and the min wins.
	        if (outsideABC) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$6, a, b, c);
	            let len = v1$6.lengthSq();
	            dst.copy(v1$6);
	            minDist = len;
	            used = res;
	            flip = requireFlip;
	        }
	        if (outsideACD) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$6, a, c, d);
	            let len = v1$6.lengthSq();
	            if (len < minDist) {
	                dst.copy(v1$6);
	                minDist = len;
	                used = (res & 0b1) | ((res & 0b10) << 1) | ((res & 0b100) << 1); // Shift the bits around so they match the passed points
	                flip = requireFlip;
	            }
	        }
	        if (outsideADB) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$6, a, d, b);
	            let len = v1$6.lengthSq();
	            if (len < minDist) {
	                dst.copy(v1$6);
	                minDist = len;
	                used = (res & 0b1) | ((res & 0b10) << 2) | ((res & 0b100) >> 1);
	                flip = requireFlip ^ 1; // Requires one additional flip
	            }
	        }
	        if (outsideBDC) {
	            requireFlip = 0;
	            let res = this.closestPointTriangle(v1$6, b, d, c);
	            let len = v1$6.lengthSq();
	            if (len < minDist) {
	                dst.copy(v1$6);
	                minDist = len;
	                used = ((res & 0b1) << 1) | ((res & 0b10) << 2) | ((res & 0b100));
	                flip = requireFlip ^ 1; // Also requires one additional flip
	            }
	        }
	        if (minDist === Infinity) {
	            // The origin is inside the tetrahedron!
	            dst.setScalar(0);
	            used = 0b1111;
	            flip = 0;
	        }
	        requireFlip = flip;
	        return used;
	    }
	    /** Given the last two intersecting shapes s1 and s2, returns the plane whose normal is the collision normal and whose offset represents the smallest amount s1 has to be moved along the collision normal such that s1 and s2 no longer intersect. Note that this method has to be called right after calling `checkIntersection`! */
	    static determineCollisionPlane(dst) {
	        if (lastS1 instanceof BallCollisionShape && lastS2 instanceof BallCollisionShape) {
	            return this.determineBallBallCollisionPlane(dst);
	        }
	        else if (lastS1 instanceof BallCollisionShape) {
	            return this.determineBallConvexCollisionPlane(dst);
	        }
	        else {
	            return this.determineConvexConvexCollisionPlane(dst);
	        }
	    }
	    static determineBallBallCollisionPlane(dst) {
	        let len = lastS1.radius + lastS2.radius - lastS1.body.position.distanceTo(lastS2.body.position);
	        dst.normal.copy(lastS1.body.position).sub(lastS2.body.position).normalize();
	        dst.constant = len;
	        return dst;
	    }
	    static determineBallConvexCollisionPlane(dst) {
	        let len = direction.length();
	        if (len === 0)
	            return this.determineConvexConvexCollisionPlane(dst); // The ball's center is contained inside the convex hull; we'll need to do EPA
	        // The collision normal is simply given by the vector from the closest point in the CSO (configuration space obstacle) to the origin
	        dst.normal.copy(direction).normalize();
	        dst.constant = lastS1.radius - len;
	        return dst;
	    }
	    static determineConvexConvexCollisionPlane(dst) {
	        // EPA code taken from https://github.com/kevinmoran/GJK/blob/master/GJK.h
	        let a = points[0];
	        let b = points[1];
	        let c = points[2];
	        let d = points[3];
	        faces[0][0].copy(a);
	        faces[0][1].copy(b);
	        faces[0][2].copy(c);
	        faces[0][3].copy(b).sub(a).cross(v1$6.copy(c).sub(a)).normalize();
	        faces[1][0].copy(a);
	        faces[1][1].copy(c);
	        faces[1][2].copy(d);
	        faces[1][3].copy(c).sub(a).cross(v1$6.copy(d).sub(a)).normalize();
	        faces[2][0].copy(a);
	        faces[2][1].copy(d);
	        faces[2][2].copy(b);
	        faces[2][3].copy(d).sub(a).cross(v1$6.copy(b).sub(a)).normalize();
	        faces[3][0].copy(b);
	        faces[3][1].copy(d);
	        faces[3][2].copy(c);
	        faces[3][3].copy(d).sub(b).cross(v1$6.copy(c).sub(b)).normalize();
	        let numFaces = 4;
	        let closestFace = 0;
	        for (let iteration = 0; iteration < maxEpaIterations; iteration++) {
	            // Find face that's closest to origin
	            let minDist = faces[0][0].dot(faces[0][3]);
	            closestFace = 0;
	            for (let i = 1; i < numFaces; i++) {
	                let dist = faces[i][0].dot(faces[i][3]);
	                if (dist < minDist) {
	                    minDist = dist;
	                    closestFace = i;
	                }
	            }
	            // search normal to face that's closest to origin
	            direction.copy(faces[closestFace][3]);
	            this.support(support, lastS1, lastS2, direction);
	            let dot = support.dot(direction);
	            dst.constant = Math.abs(dot);
	            if (faces[closestFace][3].lengthSq() > 0) {
	                dst.normal.copy(faces[closestFace][3]).multiplyScalar(Math.sign(dot) || 1).negate();
	            }
	            if (dot - minDist < epaTolerance) {
	                // Convergence (new point is not significantly further from origin)
	                return dst;
	            }
	            let numLooseEdges = 0;
	            // Find all triangles that are facing p
	            let i = 0;
	            while (i < numFaces) {
	                if (faces[i][3].dot(v1$6.copy(support).sub(faces[i][0])) > 0) { // triangle i faces p, remove it
	                    // Add removed triangle's edges to loose edge list.
	                    // If it's already there, remove it (both triangles it belonged to are gone)
	                    for (let j = 0; j < 3; j++) { // Three edges per face
	                        let currentEdge = [faces[i][j], faces[i][(j + 1) % 3]];
	                        let foundEdge = false;
	                        for (let k = 0; k < numLooseEdges; k++) { // Check if current edge is already in list
	                            if (looseEdges[k][1].equals(currentEdge[0]) && looseEdges[k][0].equals(currentEdge[1])) {
	                                // Edge is already in the list, remove it
	                                // THIS ASSUMES EDGE CAN ONLY BE SHARED BY 2 TRIANGLES (which should be true)
	                                // THIS ALSO ASSUMES SHARED EDGE WILL BE REVERSED IN THE TRIANGLES (which
	                                // should be true provided every triangle is wound CCW)
	                                looseEdges[k][0].copy(looseEdges[numLooseEdges - 1][0]); // Overwrite current edge
	                                looseEdges[k][1].copy(looseEdges[numLooseEdges - 1][1]); // with last edge in list
	                                numLooseEdges--;
	                                foundEdge = true;
	                                break;
	                                // exit loop because edge can only be shared once
	                            }
	                        } // endfor loose_edges
	                        if (!foundEdge) { // add current edge to list
	                            if (numLooseEdges >= maxEpaLooseEdges)
	                                break;
	                            looseEdges[numLooseEdges][0].copy(currentEdge[0]);
	                            looseEdges[numLooseEdges][1].copy(currentEdge[1]);
	                            numLooseEdges++;
	                        }
	                    }
	                    // Remove triangle i from list
	                    faces[i][0].copy(faces[numFaces - 1][0]);
	                    faces[i][1].copy(faces[numFaces - 1][1]);
	                    faces[i][2].copy(faces[numFaces - 1][2]);
	                    faces[i][3].copy(faces[numFaces - 1][3]);
	                    numFaces--;
	                    i--;
	                } // endif p can see triangle i
	                i++;
	            } // endfor num_faces
	            // Reconstruct polytope with p added
	            for (let i = 0; i < numLooseEdges; i++) {
	                if (numFaces >= maxEpaFaces)
	                    break;
	                faces[numFaces][0].copy(looseEdges[i][0]);
	                faces[numFaces][1].copy(looseEdges[i][1]);
	                faces[numFaces][2].copy(support);
	                faces[numFaces][3].copy(looseEdges[i][0]).sub(looseEdges[i][1]).cross(v1$6.copy(looseEdges[i][0]).sub(support)).normalize();
	                // Check for wrong normal to maintain CCW winding
	                let bias = 0.000001; // in case dot result is only slightly < 0 (because origin is on face)
	                if (faces[numFaces][0].dot(faces[numFaces][3]) + bias < 0) {
	                    let temp = faces[numFaces][0];
	                    faces[numFaces][0].copy(faces[numFaces][1]);
	                    faces[numFaces][1].copy(temp);
	                    faces[numFaces][3].negate();
	                }
	                numFaces++;
	            }
	        }
	        let dot = faces[closestFace][0].dot(faces[closestFace][3]);
	        dst.constant = Math.abs(dot);
	        dst.normal.copy(faces[closestFace][3]).multiplyScalar(Math.sign(dot) || 1).negate();
	        return dst;
	    }
	}
	//# sourceMappingURL=collision_detection.js.map

	let c_1 = new Vector3$1();
	let c_2 = new Vector3$1();
	let r_1 = new Vector3$1();
	let r_2 = new Vector3$1();
	let x$1 = new Vector3$1();
	let y = new Vector3$1();
	let z = new Vector3$1();
	let B = new Matrix3();
	let BInv = new Matrix3();
	let M_1 = new Matrix3();
	let M_2 = new Matrix3();
	let R_1 = new Matrix3();
	let R_2 = new Matrix3();
	let K_world = new Matrix3();
	let K_contact = new Matrix3();
	let K_contactInv = new Matrix3();
	let theta_1 = new Vector3$1();
	let theta_2 = new Vector3$1();
	let deltaDeltaTheta_12 = new Vector3$1();
	let deltaJ = new Vector3$1();
	let deltaI = new Vector3$1();
	let m1$3 = new Matrix3();
	/** Provides methods for performing an impulse-based collision response. Approach taken from https://www10.cs.fau.de/publications/theses/2010/Schornbaum_DA_2010.pdf. */
	class CollisionResponse {
	    /** Fixes interpenetration of two shapes. */
	    static solvePosition(collision) {
	        let threshold = 0.002; // This seems to be the lowest we can go?
	        let remainingPenetration = 0.5;
	        if (collision.depth < threshold)
	            return;
	        let distance = collision.depth - remainingPenetration * threshold;
	        collision.s1.body.position.addScaledVector(collision.normal, distance); // Always move the first body
	    }
	    /** Adjusts linear and angular velocities of the collision shapes. */
	    static solveVelocity(collision) {
	        if (collision.customVelocitySolver) {
	            collision.customVelocitySolver();
	            return;
	        }
	        collision.s1.getCenter(c_1);
	        collision.s2.getCenter(c_2);
	        r_1.copy(collision.point).sub(c_1);
	        r_2.copy(collision.point).sub(c_2);
	        x$1.copy(collision.normal);
	        if (x$1.z === 0)
	            y.set(x$1.y, -x$1.x, 0);
	        else
	            y.set(0, x$1.z, -x$1.y);
	        y.normalize();
	        z.copy(x$1).cross(y);
	        // This here forms the contact basis, where the first column represents the direction along the normal
	        B.set(x$1.x, y.x, z.x, x$1.y, y.y, z.y, x$1.z, y.z, z.z);
	        BInv.copy(B).transpose(); // B is orthonormal - BInv converts from contact space back into world space
	        M_1.identity().multiplyScalar(1 / collision.s1.mass);
	        M_2.identity().multiplyScalar(1 / collision.s2.mass);
	        R_1.set(0, -r_1.z, r_1.y, r_1.z, 0, -r_1.x, -r_1.y, r_1.x, 0);
	        R_2.set(0, -r_2.z, r_2.y, r_2.z, 0, -r_2.x, -r_2.y, r_2.x, 0);
	        K_world.copy(M_1).sub(m1$3.copy(R_1).multiply(collision.s1.invInertia).multiply(R_1)).add(M_2).sub(m1$3.copy(R_2).multiply(collision.s2.invInertia).multiply(R_2));
	        K_contact.copy(BInv).multiply(K_world).multiply(B); // Change of basis thang
	        K_contactInv.copy(K_contact).invert();
	        let b1 = collision.s1.body;
	        let b2 = collision.s2.body;
	        theta_1.copy(b1.angularVelocity).cross(r_1).add(b1.linearVelocity).applyMatrix3(BInv);
	        theta_2.copy(b2.angularVelocity).cross(r_2).add(b2.linearVelocity).applyMatrix3(BInv);
	        // Relative velocity along the normal
	        let deltaTheta = theta_1.x - theta_2.x;
	        if (deltaTheta > -0.0001)
	            return; // Not a "closing contact"
	        let res = collision.restitution;
	        if (deltaTheta > -0.5)
	            res = 0; // Set the restitution to 0 for low-impact collisions, allowing for objects to rest on the floor.
	        deltaDeltaTheta_12.set(-(1 + res) * (theta_1.x - theta_2.x), -(theta_1.y - theta_2.y), -(theta_1.z - theta_2.z));
	        deltaJ.copy(deltaDeltaTheta_12).applyMatrix3(K_contactInv);
	        let alpha = deltaJ.y ** 2 + deltaJ.z ** 2;
	        // Handle friction
	        let staticFriction = collision.friction;
	        if (alpha > staticFriction ** 2 * deltaJ.x ** 2) {
	            let beta = collision.friction / Math.sqrt(alpha);
	            deltaJ.x = deltaDeltaTheta_12.x / (K_contact.elements[0] + beta * (K_contact.elements[3] * deltaJ.y + K_contact.elements[6] * deltaJ.z));
	            let lambda = beta * deltaJ.x;
	            deltaJ.y *= lambda;
	            deltaJ.z *= lambda;
	        }
	        deltaI.copy(deltaJ).applyMatrix3(B);
	        // Finally, adjust the velocities
	        b1.linearVelocity.addScaledVector(deltaI, 1 / collision.s1.mass);
	        b1.angularVelocity.add(r_1.cross(deltaI).applyMatrix3(collision.s1.invInertia));
	        b2.linearVelocity.addScaledVector(deltaI, -1 / collision.s2.mass);
	        b2.angularVelocity.sub(r_2.cross(deltaI).applyMatrix3(collision.s2.invInertia));
	    }
	}
	//# sourceMappingURL=collision_response.js.map

	const MAX_SUBSTEPS = 10;
	let v1$7 = new Vector3$1();
	let v2$3 = new Vector3$1();
	let v3$1 = new Vector3$1();
	let p1 = new Plane$1();
	let rayCastAabb = new Box3();
	let singletonShape$1 = new SingletonCollisionShape();
	let combinedCollisionShape = new CombinedCollisionShape(null, null);
	let utilBody = new RigidBody();
	utilBody.addCollisionShape(singletonShape$1);
	utilBody.addCollisionShape(combinedCollisionShape);
	/** Represents a physics simulation world. */
	class World$1 {
	    constructor() {
	        this.bodies = [];
	        this.octree = new Octree();
	        /** This cache can speed up broadphase lookups by reusing results. */
	        this.cachedBroadphaseResults = new Map();
	    }
	    add(body) {
	        if (body.world) {
	            throw new Error("RigidBody already belongs to a world.");
	        }
	        if (body.evaluationOrder === undefined) {
	            console.log(body);
	            throw new Error("RigidBody has undefined evaluation order.");
	        }
	        Util$1.insertSorted(this.bodies, body, (a, b) => a.evaluationOrder - b.evaluationOrder);
	        body.world = this;
	        body.syncShapes();
	    }
	    /** Steps the physics world by `dt` seconds. */
	    step(dt) {
	        this.substep(dt, 0, 0);
	    }
	    substep(dt, startT, depth) {
	        // Roughly follows Algorithm 4 from https://www10.cs.fau.de/publications/theses/2010/Schornbaum_DA_2010.pdf.
	        if (dt < 0.00001 || depth >= MAX_SUBSTEPS)
	            return;
	        let dynamicShapes = [];
	        // Integrate all the bodies
	        for (let i = 0; i < this.bodies.length; i++) {
	            let body = this.bodies[i];
	            if (!body.enabled)
	                continue;
	            body.storePrevious();
	            body.onBeforeIntegrate(dt);
	            body.integrate(dt);
	            body.onAfterIntegrate(dt);
	            body.collisions.length = 0;
	            if (body.type === RigidBodyType.Dynamic) {
	                dynamicShapes.push(...body.shapes);
	            }
	        }
	        this.cachedBroadphaseResults.clear();
	        // Check for CCD collisions
	        //let ccdCollisions = this.computeCollisions(dynamicShapes, true);
	        let t = 1;
	        let cumT = startT + t * (1 - startT); // coom (it means cumulative incase you don't know)
	        // Now, revert all the bodies back according to the CCD result
	        for (let i = 0; i < this.bodies.length; i++) {
	            let body = this.bodies[i];
	            if (!body.enabled)
	                continue;
	            body.revert(t);
	            body.collisions.length = 0;
	            body.inContactCcd = body.newInContactCcd;
	            body.newInContactCcd = new Set();
	            if (body.type !== RigidBodyType.Dynamic)
	                continue;
	            // Add external forces
	            let externalForce = v1$7.set(0, 0, 0);
	            externalForce.add(body.gravity);
	            body.linearVelocity.addScaledVector(externalForce, dt * t);
	        }
	        // Now, compute the regular collisions
	        let collisions = this.computeCollisions(dynamicShapes, false);
	        let collidingBodies = [];
	        // Get a list of all bodies that are encountering a collision
	        for (let i = 0; i < collisions.length; i++) {
	            let collision = collisions[i];
	            if (!collidingBodies.includes(collision.s1.body))
	                collidingBodies.push(collision.s1.body);
	            if (!collidingBodies.includes(collision.s2.body))
	                collidingBodies.push(collision.s2.body);
	        }
	        collidingBodies.sort((a, b) => a.evaluationOrder - b.evaluationOrder);
	        for (let i = 0; i < collidingBodies.length; i++)
	            collidingBodies[i].onBeforeCollisionResponse(cumT, dt * t);
	        // Now, solve all the collisions
	        for (let i = 0; i < collisions.length; i++) {
	            let collision = collisions[i];
	            if ((collision.s1.collisionResponseMask & collision.s2.collisionResponseMask) === 0)
	                continue; // The masks don't match, don't do collision response
	            CollisionResponse.solvePosition(collision);
	            CollisionResponse.solveVelocity(collision);
	        }
	        for (let i = 0; i < collidingBodies.length; i++)
	            collidingBodies[i].onAfterCollisionResponse(cumT, dt * t);
	        this.substep(dt * (1 - t), cumT, depth + 1);
	    }
	    /** Computes all collision for a set of dynamic shapes. */
	    computeCollisions(dynamicShapes, isCcdPass) {
	        let collisions = [];
	        for (let i = 0; i < dynamicShapes.length; i++) {
	            let shape = dynamicShapes[i];
	            if (!shape.body.enabled)
	                continue;
	            // Figure out which shape to use for the broadphase
	            let broadphaseShape = shape.broadphaseShape || shape;
	            let collisionCandidates = this.cachedBroadphaseResults.get(broadphaseShape);
	            let shapeCollisions = [];
	            if (!collisionCandidates) {
	                // Query the octree for AABB intersections
	                collisionCandidates = this.octree.intersectAabb(broadphaseShape.boundingBox);
	                this.cachedBroadphaseResults.set(broadphaseShape, collisionCandidates);
	            }
	            // Now, loop over all possible candidates
	            outer: for (let j = 0; j < collisionCandidates.length; j++) {
	                let candidate = collisionCandidates[j];
	                if (shape === candidate)
	                    continue;
	                if ((shape.collisionDetectionMask & candidate.collisionDetectionMask) === 0)
	                    continue;
	                if (!candidate.body.enabled)
	                    continue;
	                // Check if this pair of shapes is already colliding
	                for (let k = 0; k < collisions.length; k++) {
	                    let c = collisions[k];
	                    if (c.s1 === candidate && c.s2 === shape)
	                        continue outer; // No double collisions
	                }
	                if (isCcdPass) {
	                    // Compute the time of impact of the two shapes
	                    let timeOfImpact = CollisionDetection.determineTimeOfImpact(shape, candidate);
	                    if (timeOfImpact === null)
	                        continue;
	                    let collision = new Collision(shape, candidate);
	                    collision.timeOfImpact = timeOfImpact;
	                    collisions.push(collision);
	                    shape.body.newInContactCcd.add(candidate);
	                }
	                else {
	                    // First, let's check if the two shapes actually intersect
	                    let collides = CollisionDetection.checkIntersection(shape, candidate);
	                    if (!collides)
	                        continue;
	                    let collision = new Collision(shape, candidate);
	                    let isMainCollisionShape = !!(shape.collisionDetectionMask & 1); // Meaning, no aux stuff, no triggers, whatever
	                    if (isMainCollisionShape) {
	                        // Compute the plane of collision
	                        let collisionPlane = CollisionDetection.determineCollisionPlane(p1);
	                        collision.supplyCollisionPlane(collisionPlane);
	                    }
	                    // Perform a collision correction step: Sometimes, shapes can collide with internal edges, i.e. edges that aren't visible to the outside, leading to incorrect results. We try to catch and correct these cases here.
	                    if (isMainCollisionShape)
	                        for (let k = 0; k < shapeCollisions.length; k++) {
	                            let c2 = shapeCollisions[k];
	                            let distSq = collision.point2.distanceToSquared(c2.point2);
	                            if (distSq >= 0.1 ** 2)
	                                continue; // Heuristic: If the two collision points are really close, the two shapes themselves are touching and we've hit at least one internal edge
	                            // Create a new collision shape that's the convex hull of the two individual shapes
	                            combinedCollisionShape.s1 = c2.s2;
	                            combinedCollisionShape.s2 = candidate;
	                            // Perform an intersection test on this combined shape. Our hope is that this gives us a good idea of what the actual collision normal should be.
	                            CollisionDetection.checkIntersection(shape, combinedCollisionShape);
	                            CollisionDetection.determineCollisionPlane(p1);
	                            let combinedNormal = v3$1.copy(p1.normal);
	                            if (collision.normal.dot(combinedNormal) <= 0 || c2.normal.dot(combinedNormal) <= 0)
	                                break; // Incase the result is totally out of wack
	                            let size;
	                            // Now, along the combined collision normal from above, perform a ray cast onto both shapes to figure out the "correct" normal of the face that's actually visible and part of the collision (as opposed to the internal edge we can't see). Note that sometimes this method fails and doesn't hit the right face, but that's usually caught later.
	                            size = candidate.boundingBox.min.distanceTo(candidate.boundingBox.max);
	                            let hit1 = CollisionDetection.castRay(candidate, singletonShape$1, candidate.getCenter(v1$7).addScaledVector(combinedNormal, size), v2$3.copy(combinedNormal).negate(), size);
	                            size = c2.s2.boundingBox.min.distanceTo(c2.s2.boundingBox.max);
	                            let hit2 = CollisionDetection.castRay(c2.s2, singletonShape$1, c2.s2.getCenter(v1$7).addScaledVector(combinedNormal, size), v2$3.copy(combinedNormal).negate(), size);
	                            // If we've hit the shapes, see if we should replace the collision normals of the collisions
	                            if (hit1 && hit1.normal.dot(combinedNormal) >= collision.normal.dot(combinedNormal)) { // Only replace if the hit normal is an improvement over the old normal
	                                collision.supplyCollisionPlane(p1.set(hit1.normal, collision.depth));
	                            }
	                            if (hit2 && hit2.normal.dot(combinedNormal) >= c2.normal.dot(combinedNormal)) {
	                                c2.supplyCollisionPlane(p1.set(hit2.normal, c2.depth));
	                            }
	                            break;
	                        }
	                    collisions.push(collision);
	                    shapeCollisions.push(collision);
	                    shape.body.collisions.push(collision);
	                    collision.s2.body.collisions.push(collision);
	                }
	            }
	        }
	        // We need to update the material properties at the end because here, all the normals are computed
	        for (let i = 0; i < collisions.length; i++)
	            collisions[i].updateMaterialProperties();
	        return collisions;
	    }
	    /** Casts a ray into the world and returns all intersections. */
	    castRay(rayOrigin, rayDirection, lambdaMax, collisionDetectionMask = 0b1) {
	        // Build the AABB of the ray
	        // todo remove these?
	        rayCastAabb.makeEmpty();
	        rayCastAabb.expandByPoint(rayOrigin);
	        rayCastAabb.expandByPoint(v1$7.copy(rayOrigin).addScaledVector(rayDirection, lambdaMax));
	        // Query the octree for possible candidates
	        let candidates = this.octree.intersectRay(rayOrigin, rayDirection, lambdaMax);
	        let hits = [];
	        for (let candidate of candidates) {
	            if ((candidate.collisionDetectionMask & collisionDetectionMask) === 0)
	                continue;
	            // Perform a GJK ray cast
	            let hit = CollisionDetection.castRay(candidate, singletonShape$1, rayOrigin, rayDirection, lambdaMax);
	            if (hit)
	                hits.push({ ...hit, shape: candidate });
	        }
	        return hits.sort((a, b) => a.lambda - b.lambda);
	    }
	    /** Performs convex casting of a given shape: Translates a shape from its current position linearly along a direction (swept volume) and returns all intersections with other shapes.  */
	    castShape(shape, direction, lambdaMax) {
	        // Build the AABB of the swept volume
	        rayCastAabb.makeEmpty();
	        rayCastAabb.expandByPoint(shape.boundingBox.min);
	        rayCastAabb.expandByPoint(shape.boundingBox.max);
	        rayCastAabb.expandByPoint(v1$7.copy(shape.boundingBox.min).addScaledVector(direction, lambdaMax));
	        rayCastAabb.expandByPoint(v1$7.copy(shape.boundingBox.max).addScaledVector(direction, lambdaMax));
	        // Query the octree for possible candidates
	        let candidates = this.octree.intersectAabb(rayCastAabb);
	        let hits = [];
	        let negDirection = v2$3.copy(direction).negate();
	        for (let candidate of candidates) {
	            if (shape === candidate)
	                continue;
	            if ((shape.collisionDetectionMask & candidate.collisionDetectionMask) === 0)
	                continue;
	            if (!candidate.body.enabled)
	                continue;
	            if (candidate.body.linearVelocity.lengthSq() > 0)
	                continue;
	            // Perform a GJK ray cast on the Minkowski difference
	            let hit = CollisionDetection.castRay(shape, candidate, v1$7.setScalar(0), negDirection, lambdaMax);
	            if (hit)
	                hits.push({ ...hit, shape: candidate });
	        }
	        return hits.sort((a, b) => a.lambda - b.lambda);
	    }
	}
	//# sourceMappingURL=world.js.map

	const GAME_PLAYBACK_SPEED = 1; // Major attack surface for cheaters here 😟
	class GameSimulator {
	    constructor(game) {
	        this.advanceTimes = [];
	        this.nonDuplicatableEventFrames = new DefaultMap(() => -1);
	        this.isReconciling = false;
	        this.maxExecutedRestartFrame = -Infinity;
	        this.game = game;
	        this.world = new World$1();
	    }
	    update() {
	        this.advance();
	    }
	    advance() {
	        let { game } = this;
	        game.state.frame++;
	        game.state.maxFrame = Math.max(game.state.frame, game.state.maxFrame);
	        if (game.state.restartFrames.includes(game.state.frame)) {
	            game.state.restart(game.state.frame);
	            this.maxExecutedRestartFrame = Math.max(game.state.frame, this.maxExecutedRestartFrame);
	        }
	        for (let entity of game.entities)
	            entity.update();
	        this.world.step(1 / GAME_UPDATE_RATE);
	        for (let entity of game.entities)
	            entity.postUpdate();
	        game.state.saveStates();
	        this.advanceTimes.push(performance.now());
	    }
	    executeNonDuplicatableEvent(fn, eventId, addSafetyMargin = false) {
	        if (this.nonDuplicatableEventFrames.get(eventId) >= this.game.state.frame)
	            return;
	        this.nonDuplicatableEventFrames.set(eventId, this.game.state.maxFrame + (addSafetyMargin ? GAME_UPDATE_RATE / 5 : 0));
	        fn();
	    }
	}
	//# sourceMappingURL=game_simulator.js.map

	// Used for frame rate limiting working correctly
	const decoyCanvas$1 = document.querySelector('#decoy-canvas');
	const decoyCtx$1 = decoyCanvas$1.getContext('2d');
	/** The vertical offsets of overlay shapes to get them all visually centered. */
	const SHAPE_OVERLAY_OFFSETS$1 = {
	    "shapes/images/helicopter.dts": -67,
	    "shapes/items/superjump.dts": -70,
	    "shapes/items/superbounce.dts": -55,
	    "shapes/items/superspeed.dts": -53,
	    "shapes/items/shockabsorber.dts": -53,
	    "shapes/items/megamarble.dts": -70,
	};
	const SHAPE_OVERLAY_SCALES$1 = {
	    "shapes/items/megamarble.dts": 60,
	};
	class GameRenderer {
	    constructor(game) {
	        /** The shapes used for drawing HUD overlay (powerups in the corner) */
	        this.overlayShapes = [];
	        this.lastHeldPowerUp = null;
	        this.lastFrameTime = null;
	        /** The maximum time that has been displayed in the current attempt. */
	        this.maxDisplayedTime = 0;
	        /** The time state at the last point the help text was updated. */
	        this.helpTextTimeState = null;
	        /** The time state at the last point the alert text was updated. */
	        this.alertTextTimeState = null;
	        this.lastVerticalTranslation = new Vector3$1();
	        this.game = game;
	        this.scene = new Scene$1(mainRenderer$1);
	        this.particles = new ParticleManager$1(() => game.state.time * 1000);
	    }
	    async init() {
	        await this.initScene();
	        await this.particles.init(mainRenderer$1);
	        this.scene.particleManager = this.particles;
	    }
	    async initScene() {
	        let { game } = this;
	        let addedShadow = false;
	        // There could be multiple suns, so do it for all of them
	        for (let element of game.mission.allElements) {
	            if (element._type !== MissionElementType$1.Sun)
	                continue;
	            let directionalColor = MisUtils.parseVector4(element.color);
	            let ambientColor = MisUtils.parseVector4(element.ambient);
	            let sunDirection = MisUtils.parseVector3(element.direction);
	            // Create the ambient light
	            this.scene.addAmbientLight(new AmbientLight$1(new Vector3$1(ambientColor.x, ambientColor.y, ambientColor.z)));
	            // Create the sunlight
	            let directionalLight = new DirectionalLight$1(mainRenderer$1, new Vector3$1(directionalColor.x, directionalColor.y, directionalColor.z), sunDirection.clone());
	            this.scene.addDirectionalLight(directionalLight);
	            if (!addedShadow) {
	                addedShadow = true;
	                let shadowCamera = new OrthographicCamera$1(-1, 1, 1, -1, 0, 10);
	                directionalLight.enableShadowCasting(256, shadowCamera);
	            }
	        }
	        let skyElement = game.mission.allElements.find((element) => element._type === MissionElementType$1.Sky);
	        let fogColor = MisUtils.parseVector4(skyElement.fogcolor);
	        // Uber strange way Torque maps these values:
	        if (fogColor.x > 1)
	            fogColor.x = 1 - (fogColor.x - 1) % 256 / 256;
	        if (fogColor.y > 1)
	            fogColor.y = 1 - (fogColor.y - 1) % 256 / 256;
	        if (fogColor.z > 1)
	            fogColor.z = 1 - (fogColor.z - 1) % 256 / 256;
	        let skySolidColor = MisUtils.parseVector4(skyElement.skysolidcolor);
	        // This is kind of a weird situation here. It seems as if when the skysolidcolor isn't the default value, it's used as the skycolor; otherwise, fog color is used. Strange.
	        if (skySolidColor.x !== 0.6 || skySolidColor.y !== 0.6 || skySolidColor.z !== 0.6)
	            fogColor = skySolidColor;
	        mainRenderer$1.setClearColor(fogColor.x, fogColor.y, fogColor.z, 1);
	        this.camera = new PerspectiveCamera$1(StorageManager$1.data.settings.fov, window.innerWidth / window.innerHeight, 0.01, MisParser$1.parseNumber(skyElement.visibledistance));
	        this.originalCameraFar = this.camera.far;
	        if (skyElement.useskytextures === "1") {
	            // Create the skybox
	            let skyboxCubeTexture = await this.createSkyboxCubeTexture(skyElement.materiallist.slice(skyElement.materiallist.indexOf('data/') + 'data/'.length), true);
	            if (skyboxCubeTexture) {
	                let material = new Material$1();
	                material.isSky = true;
	                material.envMap = skyboxCubeTexture;
	                material.depthWrite = false;
	                material.renderOrder = -1000; // Render before everything else
	                let geometry = new Geometry$1();
	                geometry.positions.push(-1, -1, 0);
	                geometry.positions.push(3, -1, 0);
	                geometry.positions.push(-1, 3, 0);
	                geometry.materials.push(0, 0, 0);
	                geometry.indices.push(0, 1, 2);
	                geometry.fillRest();
	                let mesh = new Mesh$1(geometry, [material]);
	                this.scene.add(mesh);
	            }
	        }
	        let envmapCubeTexture = await this.createSkyboxCubeTexture('skies/sky_day.dml', false, 128); // Always the default MBG skybox
	        // Use the skybox as the environment map. Don't use the actual envmap image file because its projection requires like three PhDs in mathematics.
	        this.envMap = envmapCubeTexture;
	    }
	    async createSkyboxCubeTexture(dmlPath, increaseLoading, downsampleTo) {
	        let { game } = this;
	        let { initter } = game;
	        let dmlDirectoryPath = dmlPath.slice(0, dmlPath.lastIndexOf('/'));
	        let dmlFile = await game.mission.getResource(dmlPath);
	        if (dmlFile) {
	            // Get all skybox images
	            let lines = (await ResourceManager$1.readBlobAsText(dmlFile)).split('\n').map(x => x.trim().toLowerCase());
	            let skyboxImages = [];
	            for (let i = 0; i < 6; i++) {
	                let line = lines[i];
	                let filename = game.mission.getFullNamesOf(dmlDirectoryPath + '/' + line)[0];
	                if (!filename) {
	                    skyboxImages.push(new Image());
	                }
	                else {
	                    let image = await game.mission.getImage(dmlDirectoryPath + '/' + filename);
	                    skyboxImages.push(image);
	                }
	                if (increaseLoading)
	                    initter.loadingState.loaded++;
	            }
	            // Reorder them to the proper order
	            skyboxImages = Util$1.remapIndices(skyboxImages, [1, 3, 4, 5, 0, 2]);
	            if (downsampleTo)
	                skyboxImages = await Promise.all(skyboxImages.map(x => Util$1.downsampleImage(x, downsampleTo, downsampleTo)));
	            let skyboxTexture = new CubeTexture$1(mainRenderer$1, skyboxImages);
	            return skyboxTexture;
	        }
	        else {
	            if (increaseLoading)
	                initter.loadingState.loaded += 6;
	            return null;
	        }
	    }
	    async initHud() {
	        let { game } = this;
	        // Load all necessary UI image elements
	        await G$1.menu.hud.load();
	        // Set up the HUD overlay
	        this.overlayScene = new Scene$1(mainRenderer$1);
	        let overlayLight = new AmbientLight$1(new Vector3$1().setScalar(1));
	        this.overlayScene.addAmbientLight(overlayLight);
	        this.overlayCamera = new OrthographicCamera$1(-window.innerWidth / 2, window.innerWidth / 2, -window.innerHeight / 2, window.innerHeight / 2, 1, 1000);
	        this.overlayCamera.up.set(0, 0, -1);
	        this.overlayCamera.lookAt(new Vector3$1(1, 0, 0));
	        let hudOverlayShapePaths = new Set();
	        for (let shape of game.shapes) {
	            if (shape instanceof PowerUp$1 || shape instanceof Gem$1) {
	                if (shape instanceof PowerUp$1 && shape.autoUse)
	                    continue; // Can't collect these aye
	                // We need to display the gem and powerup shapes in the HUD
	                if (!(shape instanceof RandomPowerUp$1)) {
	                    hudOverlayShapePaths.add(shape.dtsPath);
	                }
	            }
	        }
	        for (let path of hudOverlayShapePaths) {
	            let shape = new Shape$1();
	            shape.dtsPath = path;
	            shape.ambientRotate = true;
	            shape.showSequences = false;
	            // MBP's UI gem color is randomized
	            if (path.includes("gem") && G$1.menu.hud instanceof MbpHud$1)
	                shape.matNamesOverride['base.gem'] = Gem$1.pickRandomColor() + '.gem';
	            await shape.init(game);
	            this.overlayShapes.push(shape);
	            this.overlayScene.add(shape.group);
	            if (path.includes("gem")) {
	                shape.ambientSpinFactor /= -2; // Gems spin the other way apparently
	            }
	            else {
	                shape.ambientSpinFactor /= 2;
	                shape.setOpacity(0);
	            }
	        }
	        if (game.totalGems > 0) {
	            // Show the gem overlay
	            G$1.menu.hud.setGemVisibility(true);
	        }
	        else {
	            // Hide the gem UI
	            G$1.menu.hud.setGemVisibility(false);
	        }
	        this.overlayScene.compile();
	        if (G$1.menu.pauseScreen instanceof MbpPauseScreen$1)
	            G$1.menu.pauseScreen.jukebox.reset();
	    }
	    render() {
	        var _a;
	        let { game } = this;
	        if (game.stopped)
	            return;
	        let time = performance.now();
	        if (this.lastFrameTime === null) {
	            this.lastFrameTime = time;
	        }
	        else {
	            let cap = FRAME_RATE_OPTIONS$1[StorageManager$1.data.settings.frameRateCap];
	            // When FPS is unlocked in the browser but limited in-game, for some browser frames, the game won't draw anything. This makes the browser think it's okay to slow down the rate of requestAnimationFrame, which is not desirable in this case. Therefore we trick the browser into thinking the GPU is doing something by continuously clearing a 1x1 canvas each frame.
	            if (isFinite(cap))
	                decoyCtx$1.clearRect(0, 0, 1, 1);
	            // Take care of frame rate limiting:
	            let elapsed = time - this.lastFrameTime;
	            let required = 1000 / cap;
	            if (elapsed < required)
	                return;
	            this.lastFrameTime += required;
	            this.lastFrameTime = Math.max(this.lastFrameTime, time - 2 * required); // To avoid the last frame time from lagging behind
	        }
	        let gameFrameLength = 1000 / GAME_UPDATE_RATE;
	        let completion = Util$1.clamp((time - game.lastGameUpdateTime) / gameFrameLength * GAME_PLAYBACK_SPEED, 0, 1);
	        game.state.subframeCompletion =  0 ; // temp!!
	        for (let entity of game.entities)
	            entity.render();
	        this.particles.render();
	        this.updateCamera();
	        this.camera.updateMatrixWorld();
	        let marble = game.localPlayer.controlledMarble;
	        // Update the shadow camera
	        (_a = this.scene.directionalLights[0]) === null || _a === void 0 ? void 0 : _a.updateCamera(marble.group.position.clone(), -1);
	        // Render the scene
	        this.scene.prepareForRender(this.camera);
	        marble.renderReflection();
	        mainRenderer$1.render(this.scene, this.camera);
	        // This might seem a bit strange, but the time we display is actually a few milliseconds in the PAST (unless the user is currently in TT or has finished), for the reason that time was able to go backwards upon finishing or collecting TTs due to CCD time correction. That felt wrong, so we accept this inaccuracy in displaying time for now.
	        /*
	        let timeToDisplay = tempTimeState.gameplayClock;
	        if (simulator.finishTime) timeToDisplay = simulator.finishTime.gameplayClock;
	        if (simulator.currentTimeTravelBonus === 0 && !simulator.finishTime) timeToDisplay = Math.max(timeToDisplay - 1000 / PHYSICS_TICK_RATE, 0);
	        this.maxDisplayedTime = Math.max(timeToDisplay, this.maxDisplayedTime);
	        if (simulator.currentTimeTravelBonus === 0 && !simulator.finishTime) timeToDisplay = this.maxDisplayedTime;
	        */
	        this.renderHud();
	        game.state.subframeCompletion = 0;
	    }
	    /** Updates the position of the camera based on marble position and orientation. */
	    updateCamera() {
	        let { game } = this;
	        let { simulator } = game;
	        if (game.state.lastRestartFrame === -Infinity) {
	            let pos = new Vector3$1(game.orbitSphere.radius * 2, 0, 0);
	            pos.applyAxisAngle(new Vector3$1(0, 1, 0), -Math.PI / 6);
	            pos.applyAxisAngle(new Vector3$1(0, 0, 1), -game.state.time / 10);
	            pos.add(game.orbitSphere.center);
	            this.camera.up.set(0, 0, 1);
	            this.camera.position.copy(pos);
	            this.camera.lookAt(game.orbitSphere.center);
	            this.camera.far = Math.max(game.orbitSphere.radius * 4, this.originalCameraFar);
	            this.camera.updateProjectionMatrix();
	            return;
	        }
	        this.camera.far = this.originalCameraFar;
	        this.camera.updateProjectionMatrix();
	        let marble = game.localPlayer.controlledMarble;
	        let marblePosition = marble.group.position;
	        let orientationQuat = marble.getInterpolatedOrientationQuat();
	        let up = new Vector3$1(0, 0, 1).applyQuaternion(orientationQuat);
	        let directionVector = new Vector3$1(1, 0, 0);
	        // The camera is translated up a bit so it looks "over" the marble
	        let cameraVerticalTranslation = new Vector3$1(0, 0, 0.3);
	        let { pitch, yaw } = marble.currentControlState;
	        /*
	        if (game.replay.mode === 'playback') {
	            let indexLow = Math.max(0, game.replay.currentTickIndex - 1);
	            let indexHigh = game.replay.currentTickIndex;

	            // Smoothly interpolate pitch and yaw between the last two keyframes
	            simulator.pitch = Util.lerp(game.replay.cameraOrientations[indexLow].pitch, game.replay.cameraOrientations[indexHigh].pitch, timeState.physicsTickCompletion);
	            simulator.pitch = Math.max(-Math.PI/2 + Math.PI/4, Math.min(Math.PI/2 - 0.0001, simulator.pitch)); // This bounds thing might have gotten inaccurate in the conversion from float64 to float32, so do it here again
	            simulator.yaw = Util.lerp(game.replay.cameraOrientations[indexLow].yaw, game.replay.cameraOrientations[indexHigh].yaw, timeState.physicsTickCompletion);
	        }
	        */
	        if (marble.finishCameraAnimationStart !== null) {
	            // Make the camera spin around slowly
	            let timeElapsed = this.game.state.time - marble.finishCameraAnimationStart;
	            pitch = Util$1.lerp(marble.finishPitch, DEFAULT_PITCH$1, Util$1.clamp(timeElapsed / 0.333, 0, 1));
	            yaw = marble.finishYaw - timeElapsed * 0.6;
	        }
	        if (marble.outOfBoundsFrame === null) {
	            directionVector.applyAxisAngle(new Vector3$1(0, 1, 0), pitch);
	            directionVector.applyAxisAngle(new Vector3$1(0, 0, 1), yaw);
	            directionVector.applyQuaternion(orientationQuat);
	            cameraVerticalTranslation.applyAxisAngle(new Vector3$1(0, 1, 0), pitch);
	            cameraVerticalTranslation.applyAxisAngle(new Vector3$1(0, 0, 1), yaw);
	            cameraVerticalTranslation.applyQuaternion(orientationQuat);
	            this.camera.up = up;
	            this.camera.position.copy(marblePosition).sub(directionVector.clone().multiplyScalar(2.5));
	            this.camera.lookAt(marblePosition);
	            this.camera.position.add(cameraVerticalTranslation);
	            // Handle wall intersections:
	            const closeness = 0.1;
	            let rayCastOrigin = marblePosition;
	            let processedShapes = new Set();
	            for (let i = 0; i < 3; i++) {
	                // Shoot rays from the marble to the postiion of the camera
	                let rayCastDirection = this.camera.position.clone().sub(rayCastOrigin);
	                rayCastDirection.addScaledVector(rayCastDirection.clone().normalize(), 2);
	                let length = rayCastDirection.length();
	                let hits = simulator.world.castRay(rayCastOrigin, rayCastDirection.normalize(), length);
	                let firstHit = hits.find(x => !(x.shape instanceof BallCollisionShape)); // Ignore all marbles with the ray
	                if (firstHit) {
	                    processedShapes.add(firstHit.shape);
	                    // Construct a plane at the point of ray impact based on the normal
	                    let plane = new Plane$1();
	                    let normal = firstHit.normal;
	                    let position = firstHit.point;
	                    plane.setFromNormalAndCoplanarPoint(normal, position);
	                    // Project the camera position onto the plane
	                    let target = new Vector3$1();
	                    let projected = plane.projectPoint(this.camera.position, target);
	                    // If the camera is too far from the plane anyway, break
	                    let dist = plane.distanceToPoint(this.camera.position);
	                    if (dist >= closeness)
	                        break;
	                    // Go the projected point and look at the marble
	                    this.camera.position.copy(projected.add(normal.multiplyScalar(closeness)));
	                    Util$1.cameraLookAtDirect(this.camera, marblePosition);
	                    let rotationAxis = new Vector3$1(1, 0, 0);
	                    rotationAxis.applyQuaternion(this.camera.orientation);
	                    let theta = Math.atan(0.3 / 2.5); // 0.3 is the vertical translation, 2.5 the distance away from the marble.
	                    // Rotate the camera back upwards such that the marble is in the same visual location on screen as before
	                    let rot = new Quaternion$1().setFromAxisAngle(rotationAxis, theta);
	                    this.camera.orientation.premultiply(rot);
	                    continue;
	                }
	                break;
	            }
	            this.lastVerticalTranslation = cameraVerticalTranslation;
	        }
	        else {
	            // Simply look at the marble
	            this.camera.position.copy(marble.outOfBoundsCameraPosition);
	            this.camera.position.sub(this.lastVerticalTranslation);
	            this.camera.lookAt(marblePosition);
	            this.camera.position.add(this.lastVerticalTranslation);
	        }
	    }
	    renderHud() {
	        var _a;
	        let { game } = this;
	        let hud = G$1.menu.hud;
	        if (game.localPlayer.controlledMarble.outOfBoundsFrame !== null) {
	            hud.setCenterText('outofbounds');
	        }
	        else {
	            let timeSinceRestart = (game.state.frame - game.state.lastRestartFrame) / GAME_UPDATE_RATE;
	            if (timeSinceRestart < READY_TIME || timeSinceRestart > 5.5 || game.state.lastRestartFrame === -Infinity) {
	                hud.setCenterText('none');
	            }
	            else if (timeSinceRestart > GO_TIME$1) {
	                hud.setCenterText('go');
	            }
	            else if (timeSinceRestart > SET_TIME) {
	                hud.setCenterText('set');
	            }
	            else {
	                hud.setCenterText('ready');
	            }
	        }
	        let gemCount = 0;
	        for (let i = 0; i < this.game.entities.length; i++) {
	            let entity = this.game.entities[i];
	            if (entity instanceof Gem$1 && entity.pickedUpBy)
	                gemCount++;
	        }
	        hud.displayGemCount(gemCount, this.game.totalGems);
	        hud.displayBlastMeterFullness(this.game.localPlayer.controlledMarble.blastAmount);
	        hud.displayFps();
	        hud.helpElement.textContent = '';
	        hud.alertElement.textContent = '';
	        if (game.state.restartFrames.length > 0 && game.state.frame < Util$1.last(game.state.restartFrames)) {
	            let frameDifference = Util$1.last(game.state.restartFrames) - game.state.frame;
	            let secondsUntil = frameDifference / GAME_UPDATE_RATE;
	            let decimalPlaces = secondsUntil < 2 ? 1 : 0;
	            hud.announcementElement.textContent = `Game ${game.state.lastRestartFrame === -Infinity ? 'starting' : 'restarting'} in ${(Math.trunc(secondsUntil * 10 ** decimalPlaces) / 10 ** decimalPlaces).toFixed(decimalPlaces)} seconds...`;
	        }
	        else {
	            hud.announcementElement.textContent = '';
	        }
	        for (let i = hud.helpMessages.length - 1; i >= 0; i--) {
	            let helpMessage = hud.helpMessages[i];
	            let message = helpMessage.getMessage();
	            if (message === null)
	                continue;
	            let completion = Util$1.clamp(game.state.time - helpMessage.frame / GAME_UPDATE_RATE - 3, 0, 1) ** 2;
	            hud.helpElement.style.opacity = (1 - completion).toString();
	            if (completion === 1)
	                break;
	            hud.helpElement.style.filter = `brightness(${Util$1.lerp(1, 0.25, completion)})`;
	            hud.helpElement.textContent = Hud.processHelpMessage(message);
	            break;
	        }
	        for (let i = hud.alerts.length - 1; i >= 0; i--) {
	            let alert = hud.alerts[i];
	            let message = alert.getMessage();
	            if (message === null)
	                continue;
	            let completion = Util$1.clamp(game.state.time - alert.frame / GAME_UPDATE_RATE - 3, 0, 1) ** 2;
	            hud.alertElement.style.opacity = (1 - completion).toString();
	            if (completion === 1)
	                break;
	            hud.alertElement.style.filter = `brightness(${Util$1.lerp(1, 0.25, completion)})`;
	            hud.alertElement.textContent = message;
	            break;
	        }
	        let heldPowerUp = this.game.localPlayer.controlledMarble.heldPowerUp;
	        if (this.lastHeldPowerUp !== heldPowerUp) {
	            this.lastHeldPowerUp = heldPowerUp;
	            for (let overlayShape of this.overlayShapes) {
	                if (overlayShape.dtsPath.includes("gem"))
	                    continue;
	                // Show the corresponding icon in the HUD
	                overlayShape.setOpacity(Number(overlayShape.dtsPath === (heldPowerUp === null || heldPowerUp === void 0 ? void 0 : heldPowerUp.dtsPath)));
	            }
	        }
	        // Update the overlay
	        for (let overlayShape of this.overlayShapes) {
	            overlayShape.group.position.x = 500; // Make sure the shape is between the near and far planes of the camera
	            overlayShape.render();
	            if (overlayShape.dtsPath.includes("gem")) {
	                overlayShape.group.scale.setScalar(45 / SCALING_RATIO$1);
	                overlayShape.group.position.y = 25 / SCALING_RATIO$1;
	                overlayShape.group.position.z = -35 / SCALING_RATIO$1;
	            }
	            else {
	                overlayShape.group.scale.setScalar(((_a = SHAPE_OVERLAY_SCALES$1[overlayShape.dtsPath]) !== null && _a !== void 0 ? _a : 40) / SCALING_RATIO$1);
	                overlayShape.group.position.y = window.innerWidth - 55 / SCALING_RATIO$1;
	                overlayShape.group.position.z = SHAPE_OVERLAY_OFFSETS$1[overlayShape.dtsPath] / SCALING_RATIO$1;
	            }
	            overlayShape.group.recomputeTransform();
	        }
	        // Render the overlay
	        this.overlayCamera.updateMatrixWorld();
	        this.overlayScene.prepareForRender(this.overlayCamera);
	        mainRenderer$1.render(this.overlayScene, this.overlayCamera, null, false);
	    }
	    onResize() {
	        if (!this.camera || !this.overlayCamera)
	            return;
	        this.camera.aspect = window.innerWidth / window.innerHeight;
	        this.overlayCamera.left = 0;
	        this.overlayCamera.right = window.innerWidth;
	        this.overlayCamera.top = 0;
	        this.overlayCamera.bottom = window.innerHeight;
	        this.overlayCamera.updateProjectionMatrix();
	    }
	    dispose() {
	        this.scene.dispose();
	        mainRenderer$1.cleanUp();
	    }
	}

	class Player extends Entity {
	    constructor(game, id) {
	        super(game);
	        this.restartable = true;
	        this.sessionId = null;
	        this.updateOrder = -1;
	        this.applyUpdatesBeforeAdvance = true;
	        this.sendAllUpdates = true;
	        this.pitch = DEFAULT_PITCH;
	        this.yaw = DEFAULT_YAW;
	        this.jumping = false;
	        this.using = false;
	        this.blasting = false;
	        this.controlState = Marble$1.getPassiveControlState();
	        this.previousMouseMovementDistance = 0;
	        this.inputHistory = new Map();
	        this.lastRemoteStateFrame = -Infinity;
	        this.hasRestartIntent = false;
	        this.id = id;
	    }
	    onButtonsChange() {
	        this.checkButtons();
	    }
	    onMouseMove(e) {
	        Util$1.assert(this === this.game.localPlayer);
	        let totalDistance = Math.hypot(e.movementX, e.movementY);
	        // Strangely enough, Chrome really bugs out sometimes and flings the mouse into a random direction quickly. We try to catch that here and ignore the mouse movement if we detect it.
	        if (totalDistance > 350 && this.previousMouseMovementDistance * 4 < totalDistance) {
	            this.previousMouseMovementDistance *= 1.5; // Make the condition harder to hit the next time
	            return;
	        }
	        this.previousMouseMovementDistance = totalDistance;
	        let factor = Util$1.lerp(1 / 2500, 1 / 100, StorageManager$1.data.settings.mouseSensitivity);
	        let xFactor = (StorageManager$1.data.settings.invertMouse & 0b01) ? -1 : 1;
	        let yFactor = (StorageManager$1.data.settings.invertMouse & 0b10) ? -1 : 1;
	        let freeLook = StorageManager$1.data.settings.alwaysFreeLook || isPressed$1('freeLook');
	        if (freeLook)
	            this.pitch += e.movementY * factor * yFactor;
	        this.yaw -= e.movementX * factor * xFactor;
	    }
	    checkButtons() {
	        Util$1.assert(this === this.game.localPlayer);
	        if (isPressed$1('jump') && getPressedFlag$1('jump'))
	            this.jumping = true;
	        if (isPressed$1('use') && getPressedFlag$1('use'))
	            this.using = true;
	        if (isPressed$1('blast') && getPressedFlag$1('blast'))
	            this.blasting = true;
	    }
	    update() {
	        if (this === this.game.localPlayer) {
	            this.affectedBy.add(this);
	            this.affect(this.controlledMarble);
	            this.stateNeedsStore = true;
	            if (this.inputHistory.has(this.game.state.frame)) {
	                this.controlState = this.inputHistory.get(this.game.state.frame);
	            }
	            else {
	                this.checkButtons();
	                let allowUserInput = !G$1.menu.finishScreen.showing && G$1.menu.pauseScreen.div.classList.contains('hidden') && document.activeElement !== G$1.menu.hud.chatInput;
	                let movement = new Vector2();
	                if (allowUserInput) {
	                    if (isPressed$1('up'))
	                        movement.add(new Vector2(1, 0));
	                    if (isPressed$1('down'))
	                        movement.add(new Vector2(-1, 0));
	                    if (isPressed$1('left'))
	                        movement.add(new Vector2(0, 1));
	                    if (isPressed$1('right'))
	                        movement.add(new Vector2(0, -1));
	                    // Add gamepad input
	                    movement.add(new Vector2(-gamepadAxes$1.marbleY, -gamepadAxes$1.marbleX));
	                    // Add touch joystick input
	                    if (normalizedJoystickHandlePosition)
	                        movement.add(new Vector2(-Util$1.signedSquare(normalizedJoystickHandlePosition.y), -Util$1.signedSquare(normalizedJoystickHandlePosition.x)));
	                    // Restrict movement to [-1, 1]^2
	                    movement.clampScalar(-1, 1);
	                    if (!allowUserInput)
	                        movement.multiplyScalar(0);
	                    this.checkButtons();
	                    let yawChange = 0.0;
	                    let pitchChange = 0.0;
	                    let freeLook = StorageManager$1.data.settings.alwaysFreeLook || isPressed$1('freeLook');
	                    let amount = Util$1.lerp(1, 6, StorageManager$1.data.settings.keyboardSensitivity);
	                    if (isPressed$1('cameraLeft'))
	                        yawChange += amount;
	                    if (isPressed$1('cameraRight'))
	                        yawChange -= amount;
	                    if (isPressed$1('cameraUp'))
	                        pitchChange -= amount;
	                    if (isPressed$1('cameraDown'))
	                        pitchChange += amount;
	                    yawChange -= gamepadAxes$1.cameraX * Util$1.lerp(0.5, 10, StorageManager$1.data.settings.mouseSensitivity);
	                    if (freeLook)
	                        pitchChange += gamepadAxes$1.cameraY * Util$1.lerp(0.5, 10, StorageManager$1.data.settings.mouseSensitivity);
	                    this.yaw += yawChange / GAME_UPDATE_RATE;
	                    this.pitch += pitchChange / GAME_UPDATE_RATE;
	                    this.pitch = Util$1.clamp(this.pitch, -Math.PI / 2 + Math.PI / 4, Math.PI / 2 - 0.0001); // The player can't look straight up
	                }
	                let res = {
	                    movement,
	                    yaw: this.yaw,
	                    pitch: this.pitch,
	                    jumping: allowUserInput && this.jumping,
	                    using: allowUserInput && this.using,
	                    blasting: allowUserInput && this.blasting
	                };
	                this.controlState = res;
	                this.inputHistory.set(this.game.state.frame, res);
	            }
	            this.jumping = false;
	            this.using = false;
	            this.blasting = false;
	        }
	        else {
	            if (this.game.state.frame === this.lastRemoteStateFrame) {
	                this.affectedBy.add(this);
	                this.affect(this.controlledMarble); // Is this clean?
	            }
	            if (this.inputHistory.has(this.game.state.frame)) {
	                this.controlState = this.inputHistory.get(this.game.state.frame);
	            }
	            else if (!this.lastRemoteState) {
	                this.controlState = Marble$1.getPassiveControlState();
	            }
	            else if (this.game.state.frame - this.lastRemoteStateFrame >= this.game.state.frameGap * 2) {
	                this.controlState = Marble$1.getPassiveControlState();
	            }
	            else {
	                this.controlState = { ...this.lastRemoteState.controlState, movement: new Vector2() };
	            }
	        }
	    }
	    restart() {
	        // We override the normal restarting behavior aqui
	        this.hasRestartIntent = false;
	    }
	    getInitialState() {
	        return {
	            entityType: 'player',
	            controlState: Marble$1.getPassiveControlState()
	        };
	    }
	    getState() {
	        var _a;
	        return {
	            entityType: 'player',
	            controlState: (_a = this.inputHistory.get(this.game.state.frame)) !== null && _a !== void 0 ? _a : Marble$1.getPassiveControlState()
	        };
	    }
	    loadState(state, { frame, remote }) {
	        if (this === this.game.localPlayer)
	            return; // Don't care
	        this.inputHistory.set(frame, {
	            ...state.controlState,
	            movement: new Vector2().fromObject(state.controlState.movement)
	        });
	        if (remote) {
	            if (frame > this.lastRemoteStateFrame) {
	                this.lastRemoteStateFrame = frame;
	                this.lastRemoteState = state;
	            }
	        }
	    }
	    render() { }
	    stop() { }
	}
	//# sourceMappingURL=player.js.map

	class Game {
	    constructor(mission) {
	        this.id = Util$1.uuid();
	        this.seed = Math.floor(Math.random() * 2 ** 32);
	        this.entities = [];
	        this.entityMap = new Map();
	        this.marbles = [];
	        this.interiors = [];
	        this.shapes = [];
	        this.triggers = [];
	        this.players = [];
	        this.localPlayer = null;
	        this.totalGems = 0;
	        this.started = false;
	        this.paused = false;
	        /** If the game is stopped, it shouldn't be used anymore. */
	        this.stopped = false;
	        this.pausable = true;
	        this.lastGameUpdateTime = null;
	        this.tickDurations = [];
	        this.mission = mission;
	        this.createState();
	        this.createInitter();
	        this.createSimulator();
	        this.createRenderer();
	    }
	    createState() { this.state = new GameState(this); }
	    createInitter() { this.initter = new GameInitter(this); }
	    createSimulator() { this.simulator = new GameSimulator(this); }
	    createRenderer() { this.renderer = new GameRenderer(this); }
	    addEntity(entity) {
	        if (entity.id === undefined)
	            throw new Error("Entity has no ID.");
	        Util$1.insertSorted(this.entities, entity, (a, b) => {
	            if (a.updateOrder === b.updateOrder)
	                return a.id - b.id;
	            return a.updateOrder - b.updateOrder;
	        });
	        this.entityMap.set(entity.id, entity);
	    }
	    getEntityById(id) {
	        var _a;
	        return (_a = this.entityMap.get(id)) !== null && _a !== void 0 ? _a : null;
	    }
	    async addPlayer(data) {
	        let player = new Player(this, data.id);
	        player.sessionId = data.sessionId;
	        let marble = new Marble$1(this, data.marbleId, data.checkpointStateId);
	        this.players.push(player);
	        this.addEntity(player);
	        await marble.init();
	        this.marbles.push(marble);
	        this.addEntity(marble);
	        this.addEntity(marble.checkpointState);
	        player.controlledMarble = marble;
	        marble.controllingPlayer = player;
	    }
	    async init() {
	        await this.initter.init();
	    }
	    async start() {
	        if (this.stopped)
	            return;
	        this.started = true;
	        for (let interior of this.interiors)
	            await interior.onLevelStart();
	        for (let shape of this.shapes)
	            await shape.onLevelStart();
	        resize$1(false); // To update renderer
	        mainCanvas$1.classList.remove('hidden');
	        maybeShowTouchControls$1();
	        this.onFrame();
	        this.tickInterval = workerSetInterval(this.tick.bind(this));
	    }
	    onFrame() {
	        if (this.stopped)
	            return false;
	        requestAnimationFrame(this.onFrame.bind(this));
	        this.tick();
	        this.renderer.render();
	    }
	    tick(time, gameUpdateRate = GAME_UPDATE_RATE) {
	        if (this.stopped)
	            return;
	        if (this.paused && this.pausable)
	            return;
	        if (time === undefined)
	            time = performance.now();
	        if (this.lastGameUpdateTime === null) {
	            // If there hasn't been a physics tick yet, ensure there is one now
	            this.lastGameUpdateTime = time - 1000 / gameUpdateRate * 1.1 / GAME_PLAYBACK_SPEED;
	        }
	        /** Time in milliseconds since the last physics tick */
	        let elapsed = time - this.lastGameUpdateTime;
	        elapsed *= GAME_PLAYBACK_SPEED;
	        if (elapsed >= 1000) {
	            // Cap it
	            elapsed = 1000;
	            this.lastGameUpdateTime = time - 1000;
	        }
	        let start = performance.now();
	        while (elapsed >= 1000 / gameUpdateRate) {
	            elapsed -= 1000 / gameUpdateRate;
	            this.lastGameUpdateTime += 1000 / gameUpdateRate;
	            this.simulator.update();
	        }
	        let duration = performance.now() - start;
	        this.tickDurations.push({ start, duration });
	        AudioManager$1.updatePositionalAudio();
	    }
	    onButtonChange() {
	        var _a;
	        if (!this.started || !document.pointerLockElement || this.paused)
	            return;
	        (_a = this.localPlayer) === null || _a === void 0 ? void 0 : _a.onButtonsChange();
	    }
	    onMouseMove(e) {
	        var _a;
	        if (!this.started || !document.pointerLockElement || this.paused)
	            return;
	        (_a = this.localPlayer) === null || _a === void 0 ? void 0 : _a.onMouseMove(e);
	    }
	    /** Pauses the game. */
	    pause() {
	        var _a;
	        if (this.paused || G$1.menu.finishScreen.scheduled)
	            return;
	        (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	        releaseAllButtons$1(); // Safety measure to prevent keys from getting stuck
	        G$1.menu.pauseScreen.show();
	        hideTouchControls$1();
	        G$1.menu.hud.closeChat();
	        this.paused = true;
	    }
	    /** Unpauses the game. */
	    unpause() {
	        this.paused = false;
	        if (!Util$1.isTouchDevice)
	            Util$1.requestPointerLock();
	        G$1.menu.pauseScreen.hide();
	        maybeShowTouchControls$1();
	        this.lastGameUpdateTime = performance.now();
	    }
	    /** Ends the level irreversibly. */
	    stop() {
	        this.stopped = true;
	        workerClearTimeoutOrInterval(this.tickInterval);
	        this.dispose();
	        this.music.stop();
	        for (let entity of this.entities)
	            entity.stop();
	        AudioManager$1.stopAllAudio();
	    }
	    /** Stops and destroys the current level and returns back to the menu. */
	    stopAndExit() {
	        var _a;
	        this.stop();
	        G$1.game = null;
	        mainCanvas$1.classList.add('hidden');
	        G$1.menu.pauseScreen.hide();
	        G$1.menu.levelSelect.show();
	        G$1.menu.levelSelect.displayBestTimes(); // Potentially update best times having changed
	        G$1.menu.finishScreen.hide();
	        G$1.menu.hideGameUi();
	        G$1.menu.closeAllPopups(); // This is necessary in some multiplayer scenarios
	        G$1.menu.show();
	        (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	    }
	    dispose() {
	        this.renderer.dispose();
	        for (let marble of this.marbles)
	            marble.dispose();
	    }
	}
	//# sourceMappingURL=game.js.map

	const NAME_TAG_HEIGHT = 18;
	class MultiplayerGameRenderer extends GameRenderer {
	    constructor() {
	        super(...arguments);
	        this.networkStatTimeout = 0;
	    }
	    renderHud() {
	        super.renderHud();
	        G$1.menu.hud.displayScoreboard();
	        hudCtx.clearRect(0, 0, hudCtx.canvas.width, hudCtx.canvas.height);
	        for (let marble of this.game.marbles) {
	            if (!marble.addedToGame)
	                continue;
	            let player = marble.controllingPlayer;
	            if (!player || player === this.game.localPlayer)
	                continue;
	            let socket = G$1.lobby.sockets.find(x => x.id === player.sessionId);
	            if (!socket)
	                continue;
	            let pos = marble.group.position.clone().addScaledVector(this.camera.up, 0.5); // Use the visual position, not the physics one
	            let projected = pos.clone().applyMatrix4(this.camera.matrixWorldInverse).applyMatrix4(this.camera.projectionMatrix);
	            projected.addScalar(1).multiplyScalar(0.5);
	            if (projected.z < 0 || projected.z > 1)
	                continue; // Not inside the view frustum
	            let hits = this.game.simulator.world.castRay(this.camera.position, marble.group.position.clone().sub(this.camera.position), 1);
	            let inLineOfSight = !hits.some(x => !(x.shape instanceof BallCollisionShape));
	            hudCtx.globalAlpha = inLineOfSight ? 1 : 0.5;
	            let screenPos = new Vector2(Math.floor(hudCtx.canvas.width * projected.x), Math.floor(hudCtx.canvas.height * (1 - projected.y)));
	            hudCtx.textAlign = 'center';
	            hudCtx.textBaseline = 'middle';
	            hudCtx.font = '12px Nunito';
	            let name = socket.name;
	            let nameTagWidth = Util$1.roundToMultiple(hudCtx.measureText(name).width + 20, 2);
	            hudCtx.fillStyle = 'rgba(0,0,0,0.333)';
	            Util$1.roundRect(hudCtx, screenPos.x - nameTagWidth / 2, screenPos.y - NAME_TAG_HEIGHT / 2, nameTagWidth, NAME_TAG_HEIGHT, 5);
	            hudCtx.fill();
	            hudCtx.fillStyle = 'black';
	            hudCtx.fillText(name, screenPos.x + 1, screenPos.y + 1);
	            hudCtx.fillStyle = 'white';
	            hudCtx.fillText(name, screenPos.x, screenPos.y);
	        }
	        if (--this.networkStatTimeout <= 0) {
	            this.displayNetworkStats();
	            this.networkStatTimeout = 3;
	        }
	    }
	    displayNetworkStats() {
	        let { game } = this;
	        if (!game.started)
	            return;
	        let now = performance.now();
	        while (game.recentRtts.length > 0 && now - game.recentRtts[0].timestamp > 2000)
	            game.recentRtts.shift();
	        while (game.incomingTimes.length > 0 && now - game.incomingTimes[0][0] > 1000)
	            game.incomingTimes.shift();
	        while (game.outgoingTimes.length > 0 && now - game.outgoingTimes[0][0] > 1000)
	            game.outgoingTimes.shift();
	        while (game.tickDurations.length > 0 && now - game.tickDurations[0].start > 1000)
	            game.tickDurations.shift();
	        while (game.simulator.advanceTimes.length > 0 && now - game.simulator.advanceTimes[0] > 1000)
	            game.simulator.advanceTimes.shift();
	        while (game.simulator.reconciliationDurations.length > 0 && now - game.simulator.reconciliationDurations[0].start > 1000)
	            game.simulator.reconciliationDurations.shift();
	        //let medianRtt = Util.computeMedian(game.recentRtts.map(x => x.value));
	        let averageRtt = game.recentRtts.map(x => x.value).reduce((a, b) => a + b, 0) / game.recentRtts.length;
	        let jitter = game.recentRtts.map(x => Math.abs(x.value - averageRtt)).reduce((a, b) => a + b, 0) / game.recentRtts.length;
	        let averageTickDuration = game.tickDurations.map(x => x.duration).reduce((a, b) => a + b, 0) / game.tickDurations.length;
	        let averageReconciliationDuration = game.simulator.reconciliationDurations.map(x => x.duration).reduce((a, b) => a + b, 0) / game.simulator.reconciliationDurations.length;
	        G$1.menu.hud.networkStats.textContent = `
			Ping: ${isNaN(averageRtt) ? 'N/A' : averageRtt.toFixed(1) + ' ms'}
			Jitter: ${isNaN(jitter) ? 'N/A' : jitter.toFixed(1) + ' ms'}
			Incoming packets/s: ${game.incomingTimes.length}
			Outgoing packets/s: ${game.outgoingTimes.length}
			Downstream: ${(game.incomingTimes.map(x => x[1]).reduce((a, b) => a + b, 0) / 1000).toFixed(1)} kB/s
			Upstream: ${(game.outgoingTimes.map(x => x[1]).reduce((a, b) => a + b, 0) / 1000).toFixed(1)} kB/s
			Server frame: ${game.state.serverFrame}
			Client frame: ${game.state.frame}
			Target frame: ${game.state.targetFrame}
			Frames ahead server: ${game.state.frame - game.state.serverFrame}
			Frames ahead target: ${game.state.frame - game.state.targetFrame}
			Server update rate: ${GAME_UPDATE_RATE} Hz
			Client update rate: ${game.lastUpdateRate | 0} Hz
			Advancements/s: ${game.simulator.advanceTimes.length}
			Tick duration: ${averageTickDuration.toFixed(2)} ms
			Reconciliation duration: ${isNaN(averageReconciliationDuration) ? 'N/A' : averageReconciliationDuration.toFixed(2) + ' ms'}
			Reconciliation frames: ${game.simulator.lastReconciliationFrames}
			Send timeout: idk
		`;
	        //document.body.style.filter = sendTimeout <= 0 ? '' : 'saturate(0.25)';
	    }
	}
	//# sourceMappingURL=multiplayer_game_renderer.js.map

	class MultiplayerGameSimulator extends GameSimulator {
	    constructor() {
	        super(...arguments);
	        this.queuedServerBundles = [];
	        this.reconciliationDurations = [];
	        this.lastPlayerUpdates = new DefaultMap(() => -1);
	        this.lastReconciliationFrames = 0;
	        this.lastServerFrame = -1;
	    }
	    update() {
	        let { game } = this;
	        let { state } = game;
	        let bundles = this.queuedServerBundles;
	        if (bundles.length === 0) {
	            // Acts like a singleplayer game
	            super.update();
	            return;
	        }
	        let start = performance.now();
	        for (let entity of game.entities)
	            entity.beforeReconciliation();
	        this.isReconciling = true;
	        // Join up all the updates and base states
	        let reconciliationUpdates = bundles.map(x => x.entityUpdates).flat();
	        let baseState = bundles.map(x => x.baseState).flat();
	        let entitiesAffectedByBaseState = new Set();
	        if (baseState.length > 0) {
	            // Add the base states updates to the other reconciliation updates
	            reconciliationUpdates.push(...baseState.map(x => x.update));
	            // Now, loop over all the entities affected by the base states and process them a bit
	            for (let { update } of baseState) {
	                let entity = game.getEntityById(update.entityId);
	                const prepareForBaseState = (e) => {
	                    let next = new Set();
	                    for (let edge of state.affectionGraph)
	                        if (edge.from === e)
	                            next.add(edge.to);
	                    e.clearInteractions(); // Because it's a base state
	                    entitiesAffectedByBaseState.add(e);
	                    for (let e2 of next)
	                        prepareForBaseState(e2);
	                };
	                prepareForBaseState(entity);
	            }
	        }
	        for (let entity of game.entities) {
	            if (entity.affectedBy.size === 1 && entity.affectedBy.has(game.localPlayer))
	                entity.clearInteractions();
	        }
	        if (reconciliationUpdates.length > 0) {
	            reconciliationUpdates.sort((a, b) => a.frame - b.frame);
	            // Determine the start and end frames of the reconciliation process
	            let startFrame = reconciliationUpdates[0].frame;
	            let endFrame = state.frame;
	            if (baseState.length > 0) {
	                let rewindCap = Math.min(...baseState.map(x => x.responseFrame));
	                startFrame = Math.max(startFrame, rewindCap);
	            }
	            else {
	                let rewindCap = bundles[0].serverFrame - 16; // 16 should give us plenty of room for outsiders
	                startFrame = Math.max(startFrame, rewindCap);
	            }
	            // Some updates need to be applied one frame before their actual frame (so that they're applied by the beginning of the next frame), so check that here
	            if (reconciliationUpdates.some(x => x.frame === reconciliationUpdates[0].frame && game.getEntityById(x.entityId).applyUpdatesBeforeAdvance)) {
	                startFrame--;
	            }
	            // Roll back the entire game start to the start of the reconciliation window
	            state.rollBackToFrame(startFrame);
	            this.clearLocallyPredictedUpdates(reconciliationUpdates, entitiesAffectedByBaseState);
	            // Execute any restarts we missed
	            if (state.lastRestartFrame > this.maxExecutedRestartFrame) {
	                state.restart(state.lastRestartFrame);
	                this.maxExecutedRestartFrame = state.lastRestartFrame;
	            }
	            // Apply the oldest updates first
	            this.applyReconciliationUpdates(reconciliationUpdates, true);
	            // Finally, the core reconciliation loop: As quickly as possible, advance back to the frame we started at, applying any server changes along the way.
	            while (state.frame < endFrame) {
	                this.applyEarlyReconciliationUpdates(reconciliationUpdates);
	                this.advance();
	                this.applyReconciliationUpdates(reconciliationUpdates);
	            }
	            this.lastReconciliationFrames = endFrame - startFrame;
	        }
	        else {
	            this.lastReconciliationFrames = 0;
	        }
	        this.isReconciling = false;
	        for (let entity of game.entities)
	            entity.afterReconciliation();
	        this.lastServerFrame = Util$1.last(bundles).serverFrame;
	        this.queuedServerBundles.length = 0;
	        this.advance();
	        let duration = performance.now() - start;
	        this.reconciliationDurations.push({ start, duration });
	    }
	    /** Undoes all locally predicted state updates performed by players other than the local one. We do this because unless they are conflicts, we have no real say about what the other players update. */
	    clearLocallyPredictedUpdates(reconciliationUpdates, entititesAffectedByBaseState) {
	        var _a;
	        let { game } = this;
	        let { state } = game;
	        // First, do some base state clean-up stuff
	        for (let entity of entititesAffectedByBaseState) {
	            // Remove all of the new local changes to the entity
	            let history = state.stateHistory.get(entity.id);
	            let can = history && !history.some(x => x.frame >= this.lastServerFrame && game.remoteUpdates.has(x));
	            if (can)
	                state.rollBackEntityToFrame(entity, this.lastServerFrame);
	        }
	        // Figure out from which players we've gotten updates (we use the Player entity state as am indicator for that)
	        let playerUpdates = [...new Set(reconciliationUpdates.filter(x => { var _a; return ((_a = x.state) === null || _a === void 0 ? void 0 : _a.entityType) === 'player'; }).map(x => x.entityId))];
	        let newLastPlayerUpdates = new DefaultMap(() => -1);
	        for (let update of reconciliationUpdates) {
	            if (((_a = update.state) === null || _a === void 0 ? void 0 : _a.entityType) !== 'player')
	                continue;
	            let player = game.players.find(x => x.id === update.entityId);
	            newLastPlayerUpdates.set(player, Math.max(update.frame, newLastPlayerUpdates.get(player)));
	        }
	        for (let entity of game.entities) {
	            if (entity.affectedBy.size !== 1)
	                continue;
	            for (let playerId of playerUpdates) {
	                let player = game.getEntityById(playerId);
	                if (!entity.affectedBy.has(player))
	                    continue;
	                entity.clearInteractions();
	                let rangeMin = this.lastPlayerUpdates.get(player) + 1;
	                let rangeMax = newLastPlayerUpdates.get(player);
	                let history = state.stateHistory.get(entity.id);
	                let can = !history.some(x => x.frame >= rangeMin && x.frame <= rangeMax && game.remoteUpdates.has(x));
	                if (can)
	                    state.rollBackEntityToFrame(entity, rangeMax);
	                break;
	            }
	        }
	        for (let [key, value] of newLastPlayerUpdates) {
	            this.lastPlayerUpdates.set(key, value);
	        }
	    }
	    applyReconciliationUpdates(updates, applyOlder = false) {
	        let state = this.game.state;
	        let currentFrame = state.frame;
	        for (let update of updates) {
	            if (applyOlder ? update.frame > currentFrame : update.frame !== currentFrame)
	                continue;
	            let entity = this.game.getEntityById(update.entityId);
	            if (entity.applyUpdatesBeforeAdvance && !applyOlder)
	                continue;
	            this.game.applyRemoteEntityUpdate(update);
	        }
	    }
	    applyEarlyReconciliationUpdates(updates) {
	        let state = this.game.state;
	        let currentFrame = state.frame;
	        for (let update of updates) {
	            if (update.frame !== currentFrame + 1)
	                continue;
	            let entity = this.game.getEntityById(update.entityId);
	            if (!entity.applyUpdatesBeforeAdvance)
	                continue;
	            this.game.applyRemoteEntityUpdate(update);
	        }
	    }
	}
	//# sourceMappingURL=multiplayer_game_simulator.js.map

	class MultiplayerGameState extends GameState {
	    constructor() {
	        super(...arguments);
	        this.serverFrame = null;
	        this.targetFrame = null;
	    }
	    supplyServerTimeState(serverFrame, targetFrame) {
	        if (this.serverFrame === null) {
	            // This is the first time state we get from the server
	            this.frame = targetFrame - 1;
	        }
	        this.serverFrame = serverFrame;
	        this.targetFrame = targetFrame;
	    }
	    get frameGap() {
	        return this.targetFrame - this.serverFrame;
	    }
	}
	//# sourceMappingURL=multiplayer_game_state.js.map

	let sendTimeout = 0;
	// todo make sure to remove this eventually
	window.addEventListener('keydown', e => {
	    if (e.code === 'KeyG' && e.altKey) {
	        sendTimeout = 200;
	        console.log("activated timeout");
	    }
	});
	class MultiplayerGame extends Game {
	    constructor(mission, gameServer) {
	        super(mission);
	        this.type = 'multiplayer';
	        this.pausable = false;
	        this.lastServerTickTime = null;
	        this.lastServerStateBundle = null;
	        this.awaitingGameStartResolve = null;
	        this.recentRtts = [];
	        this.incomingTimes = [];
	        this.outgoingTimes = [];
	        this.queuedEntityUpdates = [];
	        this.lastQueuedFrame = -1;
	        this.lastSentServerFrame = -1;
	        this.maxReceivedBaseStateId = -1;
	        this.maxReceivedServerUpdateId = -1;
	        this.loneEntityTimeout = new DefaultMap(() => -Infinity);
	        this.remoteUpdates = new WeakSet();
	        this.baseStateUpdates = new WeakSet();
	        this.gameServer = gameServer;
	        this.connection = gameServer.connection;
	        this.connection.beforeTick = this.tickConnection.bind(this);
	        this.connection.onIncomingPacket = (len) => this.incomingTimes.push([performance.now(), len]);
	        this.connection.onOutgoingPacket = (len) => this.outgoingTimes.push([performance.now(), len]);
	    }
	    createState() { this.state = new MultiplayerGameState(this); }
	    createSimulator() { this.simulator = new MultiplayerGameSimulator(this); }
	    createRenderer() { this.renderer = new MultiplayerGameRenderer(this); }
	    async start() {
	        this.connection.queueCommand({
	            command: 'join',
	            gameId: this.id
	        }, Reliability.Urgent);
	        await new Promise(resolve => this.awaitingGameStartResolve = resolve);
	    }
	    async onGameJoinInfo(data) {
	        console.log(data);
	        this.state.supplyServerTimeState(data.serverFrame, data.clientFrame);
	        for (let playerData of data.players) {
	            await this.addPlayer(playerData);
	        }
	        this.localPlayer = this.players.find(x => x.id === data.localPlayerId);
	        //this.localPlayer.controlledMarble.addToGame();
	        for (let entity of this.entities) {
	            // temp this is probably temp
	            entity.loadState(entity.getInitialState(), { frame: 0, remote: false });
	        }
	        for (let update of data.entityStates) {
	            this.applyRemoteEntityUpdate(update);
	        }
	        await super.start();
	        this.awaitingGameStartResolve();
	        // Tell the servers that we're down loading and running the game, but do it with a delay so that this only runs once we actually have some CPU idle time.
	        setTimeout(() => {
	            Socket.send('loadingCompletion', 1);
	            this.connection.queueCommand({ command: 'running' }, Reliability.Urgent);
	        }, 500);
	    }
	    tick() {
	        if (this.stopped)
	            return;
	        let time = performance.now();
	        if (this.lastServerTickTime === null) {
	            this.lastServerTickTime = time;
	        }
	        let serverElapsed = time - this.lastServerTickTime;
	        while (serverElapsed >= 1000 / GAME_UPDATE_RATE) {
	            serverElapsed -= 1000 / GAME_UPDATE_RATE;
	            this.lastServerTickTime += 1000 / GAME_UPDATE_RATE;
	            this.state.serverFrame++;
	            this.state.targetFrame++;
	        }
	        let updateRateDelta = Util$1.signedSquare((this.state.targetFrame - this.state.frame) / 2) * 2;
	        updateRateDelta = Util$1.clamp(updateRateDelta, -90, 500); // Kinda ridiculous tbh, but let's see if it's fine
	        let gameUpdateRate = GAME_UPDATE_RATE + updateRateDelta;
	        this.lastUpdateRate = gameUpdateRate;
	        super.tick(time, gameUpdateRate);
	    }
	    async onServerStateBundle(data) {
	        if (sendTimeout > 0)
	            return;
	        this.lastServerStateBundle = data;
	        this.simulator.queuedServerBundles.push(data); // Queue it up for a later simulation step
	        // Mark the incoming updates as being remote
	        for (let update of data.entityUpdates)
	            this.remoteUpdates.add(update);
	        for (let { update } of data.baseState)
	            this.remoteUpdates.add(update), this.baseStateUpdates.add(update);
	        // Remove the updates already received by the server
	        Util$1.filterInPlace(this.queuedEntityUpdates, x => x.frame > data.maxReceivedClientUpdateFrame);
	        // Remove the updates we already received
	        Util$1.filterInPlace(data.entityUpdates, x => x.updateId > this.maxReceivedServerUpdateId);
	        if (data.entityUpdates.length > 0)
	            this.maxReceivedServerUpdateId = Math.max(...data.entityUpdates.map(x => x.updateId));
	        // Remove the base states we already received
	        Util$1.filterInPlace(data.baseState, x => x.id > this.maxReceivedBaseStateId);
	        if (data.baseState.length > 0)
	            this.maxReceivedBaseStateId = Math.max(...data.baseState.map(x => x.id));
	    }
	    tickConnection() {
	        if (!this.started)
	            return;
	        let timestamp = performance.now();
	        this.connection.queueCommand({ command: 'ping', timestamp }, Reliability.Unreliable);
	        // Will contain the entities we suspect are conflicting with other players' states.
	        let conflictingEntities = [];
	        for (let [entityId, history] of this.state.stateHistory) {
	            let entity = this.getEntityById(entityId);
	            if (entity.affectedBy.size > 1) {
	                // The entity was affected by more than one player.
	                conflictingEntities.push(entity);
	                continue;
	            }
	            if (entity.requireServerConfirmation) {
	                conflictingEntities.push(entity);
	                continue;
	            }
	            let last = Util$1.last(history);
	            if (!last || last.frame <= this.lastQueuedFrame)
	                continue;
	            // We call an entity \textit{expired} if it has been recently changing state but we haven't received a message from its last affecting player in a while.
	            let isExpiredEntity = false;
	            if (entity.affectedBy.size === 1 && this.lastServerStateBundle && this.state.frame - this.lastServerStateBundle.serverFrame < GAME_UPDATE_RATE) {
	                let affector = entity.affectedBy.keys().next().value;
	                if (affector !== this.localPlayer && last.frame - affector.lastRemoteStateFrame >= GAME_UPDATE_RATE) {
	                    isExpiredEntity = true;
	                }
	            }
	            // We periodically mark lone entities (not affected by any player but still changing) and expired entities so that we get base states for them and keep them updates and synchronized.
	            if (entity.affectedBy.size === 0 || isExpiredEntity) {
	                if (this.state.frame - this.loneEntityTimeout.get(entity) < GAME_UPDATE_RATE)
	                    continue;
	                conflictingEntities.push(entity);
	                this.loneEntityTimeout.set(entity, this.state.frame);
	                continue;
	            }
	            if (!entity.affectedBy.has(this.localPlayer))
	                continue; // We only wanna send entities the local player affected
	            // Remove previously queued updates for this entity
	            Util$1.filterInPlace(this.queuedEntityUpdates, x => x.entityId !== entityId);
	            if (entity.sendAllUpdates) {
	                this.queuedEntityUpdates.push(...history.filter(x => x.frame > this.lastQueuedFrame));
	            }
	            else {
	                this.queuedEntityUpdates.push(last);
	            }
	        }
	        Util$1.filterInPlace(this.queuedEntityUpdates, x => !this.remoteUpdates.has(x)); // Just to be sure
	        this.lastQueuedFrame = this.state.frame;
	        // Prepare the affection graph
	        let affectionGraph = this.state.affectionGraph.filter(x => this.lastServerStateBundle &&
	            x.frame > this.lastServerStateBundle.maxReceivedClientUpdateFrame &&
	            this.queuedEntityUpdates.some(y => x.from.id === y.entityId || x.to.id === y.entityId));
	        // Remove any duplicate edges (same source and target node) and keep only the last one
	        let processedAffectionGraph = affectionGraph.filter((x, i1) => !affectionGraph.some((y, i2) => i2 > i1 && x.from === y.from && x.to === y.to)).map(x => ({ from: x.from.id, to: x.to.id }));
	        let bundle = {
	            command: 'clientStateBundle',
	            serverFrame: this.state.serverFrame,
	            clientFrame: this.state.frame,
	            entityUpdates: this.queuedEntityUpdates,
	            affectionGraph: processedAffectionGraph,
	            possibleConflictingEntities: conflictingEntities.map(x => x.id),
	            baseState: null,
	            maxReceivedServerUpdateId: this.maxReceivedServerUpdateId,
	            maxReceivedBaseStateId: this.maxReceivedBaseStateId
	        };
	        if (this.lastServerStateBundle && this.lastServerStateBundle.baseStateRequests.length > 0 && this.simulator.queuedServerBundles.length === 0) {
	            // Compile a base state to send over to the server
	            let baseState = {
	                frame: this.lastServerStateBundle.serverFrame,
	                updates: []
	            };
	            // It is fine to only look at the last server bundle
	            for (let id of this.lastServerStateBundle.baseStateRequests) {
	                // Get the update closest to the last-received server frame
	                let update = this.state.getLastEntityUpdate(this.getEntityById(id), baseState.frame);
	                baseState.updates.push(update);
	            }
	            bundle.baseState = baseState;
	        }
	        if (sendTimeout-- > 0)
	            return;
	        this.connection.queueCommand(bundle, Reliability.Unreliable);
	    }
	    applyRemoteEntityUpdate(update) {
	        var _a;
	        let entity = this.getEntityById(update.entityId);
	        if (!entity)
	            return;
	        if (!this.baseStateUpdates.has(update) && entity.affectedBy.size > 1)
	            return;
	        let history = this.state.stateHistory.get(entity.id);
	        while (history.length > 0 && Util$1.last(history).frame >= update.frame) {
	            history.pop();
	        }
	        entity.loadState((_a = update.state) !== null && _a !== void 0 ? _a : entity.getInitialState(), { frame: update.frame, remote: true });
	        history.push(update);
	        if (this.baseStateUpdates.has(update))
	            entity.requireServerConfirmation = false;
	    }
	    signalRestartIntent() {
	        if (this.localPlayer.hasRestartIntent)
	            return;
	        this.connection.queueCommand({ command: 'restartIntent' }, Reliability.Urgent);
	        this.localPlayer.hasRestartIntent = true;
	    }
	    stop() {
	        super.stop();
	        this.connection.beforeTick = null;
	        this.connection.onIncomingPacket = null;
	        this.connection.onOutgoingPacket = null;
	        this.connection.queueCommand({ command: 'leave' }, Reliability.Urgent);
	    }
	    async stopAndExit(callSuper = false) {
	        if (callSuper)
	            return super.stopAndExit(); // Kinda ug but whatever
	        if (G$1.lobby.localSessionIsOwner()) {
	            let confirmed = await G$1.menu.showConfirmPopup("End Game and Return to Lobby", "Are you sure you want to end this multiplayer game for all players and return to the lobby?");
	            if (!confirmed)
	                return;
	            Socket.send('endGameRequest', null);
	        }
	        else {
	            let confirmed = await G$1.menu.showConfirmPopup("Leave Game and Lobby", "Are you sure you want to leave this multiplayer game? You will also leave the lobby by doing so.");
	            if (!confirmed)
	                return;
	            super.stopAndExit();
	            G$1.lobby.leave();
	            G$1.menu.levelSelect.hide();
	        }
	    }
	}
	//# sourceMappingURL=multiplayer_game.js.map

	class SingleplayerGame extends Game {
	    constructor() {
	        super(...arguments);
	        this.type = 'singleplayer';
	    }
	    async init() {
	        await super.init();
	        await this.addPlayer({
	            id: -1,
	            sessionId: null,
	            marbleId: -2,
	            checkpointStateId: -3
	        });
	        this.localPlayer = this.players[0];
	        this.state.restartFrames.push(0);
	    }
	    signalRestartIntent() {
	        this.state.restartFrames.push(this.state.frame + 1);
	    }
	}
	//# sourceMappingURL=singleplayer_game.js.map

	class LoadingScreen {
	    constructor(menu) {
	        this.loadingIndex = 0;
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.cancelButton, 'loading/cancel', () => {
	            // Cancel the loading progress and return to level select
	            this.hide();
	            menu.levelSelect.show();
	            this.loadingIndex++;
	            clearInterval(this.refresher);
	        });
	    }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    async loadMission(mission, createGame) {
	        if (G$1.game)
	            throw new Error("There's already a game running!");
	        this.show();
	        let indexAtStart = this.loadingIndex; // Remember the index at the start. If it changes later, that means that loading was cancelled.
	        this.levelNameElement.textContent = mission.title;
	        this.progressBar.style.width = '0px';
	        // Give the UI a bit of time to breathe before we begin to load the level.
	        await Util$1.wait(50);
	        try {
	            await mission.load();
	            if (this.loadingIndex !== indexAtStart)
	                return;
	            let lastSendTime = -Infinity;
	            this.refresher = setInterval(() => {
	                // Constantly refresh the loading bar's width
	                let completion = game.initter.getLoadingCompletion();
	                this.progressBar.style.width = (completion * this.maxProgressBarWidth) + 'px';
	                if (game instanceof MultiplayerGame && performance.now() - lastSendTime > 1000) {
	                    lastSendTime = performance.now();
	                    Socket.send('loadingCompletion', Math.min(completion, 0.99));
	                }
	            });
	            let game = createGame();
	            G$1.game = game;
	            await game.init();
	            /*
	            if (getReplay) {
	                let replay = getReplay();
	                // Load the replay
	                level.replay = replay;
	                replay.level = level;
	                replay.mode = 'playback';
	            }
	            */
	            if (this.loadingIndex !== indexAtStart) {
	                game.dispose();
	                return;
	            }
	            clearInterval(this.refresher);
	            // Fake some second loading pass
	            let start = performance.now();
	            this.refresher = setInterval(() => {
	                let completion = Util$1.clamp((performance.now() - start) / 100, 0, 1);
	                this.progressBar.style.width = (completion * this.maxProgressBarWidth) + 'px';
	            });
	            await Util$1.wait(150);
	            if (this.loadingIndex !== indexAtStart) {
	                game.dispose();
	                return;
	            }
	            clearInterval(this.refresher);
	            // Loading has finished, hop into gameplay.
	            await game.start();
	            this.hide();
	            this.menu.hide();
	            this.menu.showGameUi();
	        }
	        catch (e) {
	            console.error(e);
	            this.cancelButton.click();
	            G$1.game = null;
	            G$1.menu.showAlertPopup('Error', "There was an error due to which the level couldn't be loaded.");
	        }
	    }
	    loadMissionSingleplayer(mission) {
	        return this.loadMission(mission, () => new SingleplayerGame(mission));
	    }
	    loadMissionMultiplayer(mission, lobby, gameId, seed) {
	        let gameServer = gameServers$1.find(x => x.id === lobby.settings.gameServer);
	        return this.loadMission(mission, () => {
	            let game = new MultiplayerGame(mission, gameServer);
	            game.id = gameId;
	            game.seed = seed;
	            return game;
	        });
	    }
	}
	//# sourceMappingURL=loading.js.map

	class MbgLoadingScreen extends LoadingScreen {
	    constructor() {
	        super(...arguments);
	        this.maxProgressBarWidth = 252;
	    }
	    initProperties() {
	        this.div = document.querySelector('#loading');
	        this.levelNameElement = document.querySelector('#loading-level-name');
	        this.cancelButton = document.querySelector('#loading-cancel');
	        this.progressBar = document.querySelector('#loading-progress');
	    }
	}
	//# sourceMappingURL=loading_mbg.js.map

	class MbgOptionsScreen extends OptionsScreen {
	    constructor(menu) {
	        super(menu);
	        this.trackLength = 235; // The total draggable length of the slider
	        this.musicVolumeKnobLeft = 155; // The left-most position of the knob
	        this.soundVolumeKnobLeft = 157;
	        this.mouseSensitivityKnobLeft = 148;
	        this.draggingMusicVolume = false;
	        this.draggingSoundVolume = false;
	        this.draggingMouseSensitivity = false;
	        this.soundTestingSound = null;
	        menu.setupButton(this.resolution640, 'options/graf640', () => this.selectResolutionButton(this.resolution640, 0));
	        menu.setupButton(this.resolution800, 'options/graf800', () => this.selectResolutionButton(this.resolution800, 1));
	        menu.setupButton(this.resolution1024, 'options/graf1024', () => this.selectResolutionButton(this.resolution1024, 2));
	        menu.setupButton(this.openGl, 'options/grafopgl', () => this.selectVideoDriverButton(this.openGl, 0));
	        menu.setupButton(this.direct3D, 'options/grafdir3d', () => this.selectVideoDriverButton(this.direct3D, 1));
	        menu.setupButton(this.windowedButton, 'options/grafwindo', () => this.selectScreenStyleButton(this.windowedButton, 0));
	        menu.setupButton(this.fullButton, 'options/grafful', () => this.selectScreenStyleButton(this.fullButton, 1));
	        menu.setupButton(this.depth16, 'options/graf16bt', () => this.selectColorDepthButton(this.depth16, 0));
	        menu.setupButton(this.depth32, 'options/graf32bt', () => this.selectColorDepthButton(this.depth32, 1));
	        menu.setupButton(this.shadowsCheckbox, 'options/graf_chkbx', () => {
	            StorageManager$1.data.settings.shadows = !this.shadowsCheckbox.hasAttribute('data-locked');
	            StorageManager$1.store();
	            // Toggle the checkbox
	            if (!this.shadowsCheckbox.hasAttribute('data-locked')) {
	                this.shadowsCheckbox.setAttribute('data-locked', '');
	                this.shadowsCheckbox.src = './assets/ui/options/graf_chkbx_d.png';
	            }
	            else {
	                this.shadowsCheckbox.removeAttribute('data-locked');
	                this.shadowsCheckbox.src = './assets/ui/options/graf_chkbx_h.png';
	            }
	        });
	        menu.setupButton(this.graphicsApply, 'options/grafapply', () => { });
	        const handler = () => {
	            if (!this.draggingMusicVolume && !this.draggingSoundVolume && !this.draggingMouseSensitivity)
	                return;
	            // Release all dragging things
	            this.draggingMusicVolume = this.draggingSoundVolume = this.draggingMouseSensitivity = false;
	            StorageManager$1.store();
	            if (this.soundTestingSound) {
	                // Stop the sound
	                this.soundTestingSound.stop();
	                this.soundTestingSound = null;
	            }
	        };
	        window.addEventListener('mouseup', handler);
	        window.addEventListener('touchend', handler);
	        this.musicVolumeTrack.addEventListener('mousedown', () => this.draggingMusicVolume = true);
	        this.musicVolumeTrack.addEventListener('touchstart', () => this.draggingMusicVolume = true);
	        this.musicVolumeKnob.addEventListener('mousedown', () => this.draggingMusicVolume = true);
	        this.musicVolumeKnob.addEventListener('touchstart', () => this.draggingMusicVolume = true);
	        this.soundVolumeTrack.addEventListener('mousedown', () => this.draggingSoundVolume = true);
	        this.soundVolumeTrack.addEventListener('touchstart', () => this.draggingSoundVolume = true);
	        this.soundVolumeKnob.addEventListener('mousedown', () => this.draggingSoundVolume = true);
	        this.soundVolumeKnob.addEventListener('touchstart', () => this.draggingSoundVolume = true);
	        requestAnimationFrame(() => this.updateSliders());
	        menu.setupButton(this.marbleTab, '', () => this.selectControlsTab('marble'));
	        menu.setupButton(this.cameraTab, '', () => this.selectControlsTab('camera'));
	        menu.setupButton(this.mouseTab, '', () => this.selectControlsTab('mouse'));
	        menu.setupButton(this.buttonMarbleLeft, 'options/cntr_mrb_lft', () => this.changeKeybinding('left'));
	        menu.setupButton(this.buttonMarbleRight, 'options/cntr_mrb_rt', () => this.changeKeybinding('right'));
	        menu.setupButton(this.buttonMarbleUp, 'options/cntr_mrb_fw', () => this.changeKeybinding('up'));
	        menu.setupButton(this.buttonMarbleDown, 'options/cntr_mrb_bak', () => this.changeKeybinding('down'));
	        menu.setupButton(this.buttonMarbleUse, 'options/cntr_mrb_pwr', () => this.changeKeybinding('use'));
	        menu.setupButton(this.buttonMarbleJump, 'options/cntr_mrb_jmp', () => this.changeKeybinding('jump'));
	        menu.setupButton(this.buttonCameraLeft, 'options/cntr_cam_lft', () => this.changeKeybinding('cameraLeft'));
	        menu.setupButton(this.buttonCameraRight, 'options/cntr_cam_rt', () => this.changeKeybinding('cameraRight'));
	        menu.setupButton(this.buttonCameraUp, 'options/cntr_cam_up', () => this.changeKeybinding('cameraUp'));
	        menu.setupButton(this.buttonCameraDown, 'options/cntr_cam_dwn', () => this.changeKeybinding('cameraDown'));
	        this.mouseSensitivityKnob.addEventListener('mousedown', () => this.draggingMouseSensitivity = true);
	        this.mouseSensitivityKnob.addEventListener('touchstart', () => this.draggingMouseSensitivity = true);
	        menu.setupButton(this.invertY, 'options/cntrl_mous_invrt', () => {
	            StorageManager$1.data.settings.invertMouse &= ~0b10;
	            StorageManager$1.data.settings.invertMouse |= Number(!this.invertY.hasAttribute('data-locked')) << 1;
	            StorageManager$1.store();
	            // Toggle the checkbox
	            if (!this.invertY.hasAttribute('data-locked')) {
	                this.invertY.setAttribute('data-locked', '');
	                this.invertY.src = './assets/ui/options/cntrl_mous_invrt_d.png';
	            }
	            else {
	                this.invertY.removeAttribute('data-locked');
	                this.invertY.src = './assets/ui/options/cntrl_mous_invrt_h.png';
	            }
	        });
	        menu.setupButton(this.alwaysFreeLook, 'options/cntrl_mous_freel', () => {
	            StorageManager$1.data.settings.alwaysFreeLook = !this.alwaysFreeLook.hasAttribute('data-locked');
	            StorageManager$1.store();
	            // Toggle the checkbox
	            if (!this.alwaysFreeLook.hasAttribute('data-locked')) {
	                this.alwaysFreeLook.setAttribute('data-locked', '');
	                this.alwaysFreeLook.src = './assets/ui/options/cntrl_mous_freel_d.png';
	            }
	            else {
	                this.alwaysFreeLook.removeAttribute('data-locked');
	                this.alwaysFreeLook.src = './assets/ui/options/cntrl_mous_freel_h.png';
	            }
	        });
	        menu.setupButton(this.freeLookKey, 'options/cntrl_mous_bttn', () => this.changeKeybinding('freeLook'));
	        menu.setupButton(this.chooseMarbleTexture, 'options/cntr_cam_up', async () => {
	            await this.showMarbleTexturePicker();
	            this.setResetMarbleTextureState(true);
	        });
	        menu.setupButton(this.resetMarbleTexture, 'options/cntr_cam_dwn', () => {
	            StorageManager$1.databaseDelete('keyvalue', 'marbleTexture');
	            this.setResetMarbleTextureState(false);
	        });
	        menu.setupButton(this.buttonRestartLevel, 'options/cntr_cam_dwn', () => this.changeKeybinding('restart'));
	        menu.setupButton(this.reflectiveMarbleCheckbox, 'options/cntrl_mous_freel', () => {
	            StorageManager$1.data.settings.marbleReflectivity = (!this.reflectiveMarbleCheckbox.hasAttribute('data-locked')) ? 2 : 0;
	            StorageManager$1.store();
	            // Toggle the checkbox
	            if (!this.reflectiveMarbleCheckbox.hasAttribute('data-locked')) {
	                this.reflectiveMarbleCheckbox.setAttribute('data-locked', '');
	                this.reflectiveMarbleCheckbox.src = './assets/ui/options/cntrl_mous_freel_d.png';
	            }
	            else {
	                this.reflectiveMarbleCheckbox.removeAttribute('data-locked');
	                this.reflectiveMarbleCheckbox.src = './assets/ui/options/cntrl_mous_freel_h.png';
	            }
	        });
	    }
	    initProperties() {
	        this.div = document.querySelector('#options');
	        this.homeButton = document.querySelector('#options-home');
	        this.rebindDialog = document.querySelector('#rebind-dialog');
	        this.rebindConfirm = document.querySelector('#rebind-confirm');
	        this.rebindConfirmYes = document.querySelector('#rebind-confirm-yes');
	        this.rebindConfirmNo = document.querySelector('#rebind-confirm-no');
	        this.homeButtonSrc = 'options/mainm';
	        this.rebindConfirmYesSrc = 'common/yes';
	        this.rebindConfirmNoSrc = 'common/no';
	        this.tabGraphics = document.querySelector('#tab-graphics');
	        this.tabAudio = document.querySelector('#tab-audio');
	        this.tabControls = document.querySelector('#tab-controls');
	        this.graphicsDiv = document.querySelector('#options-graphics');
	        this.audioDiv = document.querySelector('#options-audio');
	        this.controlsDiv = document.querySelector('#options-controls');
	        this.resolution640 = document.querySelector('#graphics-640');
	        this.resolution800 = document.querySelector('#graphics-800');
	        this.resolution1024 = document.querySelector('#graphics-1024');
	        this.openGl = document.querySelector('#graphics-opengl');
	        this.direct3D = document.querySelector('#graphics-direct3d');
	        this.windowedButton = document.querySelector('#graphics-windowed');
	        this.fullButton = document.querySelector('#graphics-full');
	        this.depth16 = document.querySelector('#graphics-depth16');
	        this.depth32 = document.querySelector('#graphics-depth32');
	        this.shadowsCheckbox = document.querySelector('#graphics-shadows');
	        this.graphicsApply = document.querySelector('#graphics-apply');
	        this.musicVolumeTrack = document.querySelector('#audio-music-track');
	        this.musicVolumeKnob = document.querySelector('#audio-music-knob');
	        this.soundVolumeTrack = document.querySelector('#audio-sound-track');
	        this.soundVolumeKnob = document.querySelector('#audio-sound-knob');
	        this.controlsBackground = document.querySelector('#controls-background');
	        this.marbleTab = document.querySelector('#tab-marble'); // it's not
	        this.cameraTab = document.querySelector('#tab-camera');
	        this.mouseTab = document.querySelector('#tab-mouse');
	        this.marbleControlsDiv = document.querySelector('#controls-marble');
	        this.cameraControlsDiv = document.querySelector('#controls-camera');
	        this.mouseControlsDiv = document.querySelector('#controls-mouse');
	        this.buttonMarbleLeft = document.querySelector('#button-marble-left');
	        this.buttonMarbleRight = document.querySelector('#button-marble-right');
	        this.buttonMarbleUp = document.querySelector('#button-marble-up');
	        this.buttonMarbleDown = document.querySelector('#button-marble-down');
	        this.buttonMarbleUse = document.querySelector('#button-marble-use');
	        this.buttonMarbleJump = document.querySelector('#button-marble-jump');
	        this.buttonMarbleLeftContent = document.querySelector('#button-marble-left-content');
	        this.buttonMarbleRightContent = document.querySelector('#button-marble-right-content');
	        this.buttonMarbleUpContent = document.querySelector('#button-marble-up-content');
	        this.buttonMarbleDownContent = document.querySelector('#button-marble-down-content');
	        this.buttonMarbleUseContent = document.querySelector('#button-marble-use-content');
	        this.buttonMarbleJumpContent = document.querySelector('#button-marble-jump-content');
	        this.buttonCameraLeft = document.querySelector('#button-camera-left');
	        this.buttonCameraRight = document.querySelector('#button-camera-right');
	        this.buttonCameraUp = document.querySelector('#button-camera-up');
	        this.buttonCameraDown = document.querySelector('#button-camera-down');
	        this.buttonCameraLeftContent = document.querySelector('#button-camera-left-content');
	        this.buttonCameraRightContent = document.querySelector('#button-camera-right-content');
	        this.buttonCameraUpContent = document.querySelector('#button-camera-up-content');
	        this.buttonCameraDownContent = document.querySelector('#button-camera-down-content');
	        this.mouseSensitivityKnob = document.querySelector('#sensitivity-knob');
	        this.invertY = document.querySelector('#invert-y');
	        this.alwaysFreeLook = document.querySelector('#always-free-look');
	        this.freeLookKey = document.querySelector('#free-look-key');
	        this.freeLookKeyContent = document.querySelector('#free-look-key-content');
	        this.chooseMarbleTexture = document.querySelector('#graphics-marble-texture-choose');
	        this.resetMarbleTexture = document.querySelector('#graphics-marble-texture-reset');
	        this.buttonRestartLevel = document.querySelector('#button-restart-level');
	        this.buttonRestartLevelContent = document.querySelector('#button-restart-level-content');
	        this.reflectiveMarbleCheckbox = document.querySelector('#graphics-reflective-marble');
	    }
	    show() {
	        super.show();
	        this.updateAllElements();
	    }
	    async init() {
	        super.init();
	        this.setupTab(this.tabGraphics, 'graphics');
	        this.setupTab(this.tabAudio, 'audio');
	        this.setupTab(this.tabControls, 'controls');
	        // Default selection
	        this.selectControlsTab('marble');
	        this.selectTab('graphics');
	        await ResourceManager$1.loadImages(['cntrl_marb_bse.png', 'cntrl_cam_bse.png', 'cntrl_mous_base.png'].map(x => './assets/ui/options/' + x));
	        await this.updateAllElements();
	    }
	    async updateAllElements() {
	        this.selectResolutionButton([this.resolution640, this.resolution800, this.resolution1024][StorageManager$1.data.settings.resolution], StorageManager$1.data.settings.resolution);
	        this.selectVideoDriverButton([this.openGl, this.direct3D][StorageManager$1.data.settings.videoDriver], StorageManager$1.data.settings.videoDriver);
	        this.selectScreenStyleButton([this.windowedButton, this.fullButton][StorageManager$1.data.settings.screenStyle], StorageManager$1.data.settings.videoDriver);
	        this.selectColorDepthButton([this.depth16, this.depth32][StorageManager$1.data.settings.colorDepth], StorageManager$1.data.settings.colorDepth);
	        this.musicVolumeKnob.style.left = Math.floor(this.musicVolumeKnobLeft + StorageManager$1.data.settings.musicVolume * this.trackLength) + 'px';
	        this.soundVolumeKnob.style.left = Math.floor(this.soundVolumeKnobLeft + StorageManager$1.data.settings.soundVolume * this.trackLength) + 'px';
	        this.mouseSensitivityKnob.style.left = Math.floor(this.mouseSensitivityKnobLeft + StorageManager$1.data.settings.mouseSensitivity * this.trackLength) + 'px';
	        this.refreshKeybindings();
	        if (!!(StorageManager$1.data.settings.invertMouse & 0b10) !== this.invertY.hasAttribute('data-locked'))
	            this.invertY.click();
	        if (StorageManager$1.data.settings.alwaysFreeLook !== this.alwaysFreeLook.hasAttribute('data-locked'))
	            this.alwaysFreeLook.click();
	        if ((StorageManager$1.data.settings.marbleReflectivity === 2) !== this.reflectiveMarbleCheckbox.hasAttribute('data-locked'))
	            this.reflectiveMarbleCheckbox.click();
	        this.setResetMarbleTextureState(!((await StorageManager$1.databaseCount('keyvalue', 'marbleTexture')) === 0));
	    }
	    selectTab(which) {
	        for (let elem of [this.tabGraphics, this.tabAudio, this.tabControls]) {
	            elem.style.zIndex = "-1";
	        }
	        for (let elem of [this.graphicsDiv, this.audioDiv, this.controlsDiv]) {
	            elem.classList.add('hidden');
	        }
	        let index = ['graphics', 'audio', 'controls'].indexOf(which);
	        let elem = [this.tabGraphics, this.tabAudio, this.tabControls][index];
	        elem.style.zIndex = "0";
	        [this.graphicsDiv, this.audioDiv, this.controlsDiv][index].classList.remove('hidden');
	    }
	    setupTab(element, which) {
	        element.addEventListener('mousedown', (e) => {
	            if (e.button !== 0)
	                return;
	            AudioManager$1.play('buttonpress.wav');
	        });
	        element.addEventListener('click', (e) => e.button === 0 && this.selectTab(which));
	    }
	    selectResolutionButton(button, index) {
	        this.unlockResolutionButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager$1.data.settings.resolution = index;
	        StorageManager$1.store();
	    }
	    unlockResolutionButtons() {
	        // Deselect all resolution buttons
	        this.resolution640.src = './assets/ui/options/graf640_n.png';
	        this.resolution640.removeAttribute('data-locked');
	        this.resolution800.src = './assets/ui/options/graf800_n.png';
	        this.resolution800.removeAttribute('data-locked');
	        this.resolution1024.src = './assets/ui/options/graf1024_n.png';
	        this.resolution1024.removeAttribute('data-locked');
	    }
	    selectVideoDriverButton(button, index) {
	        this.unlockVideoDriverButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager$1.data.settings.videoDriver = index;
	        StorageManager$1.store();
	    }
	    unlockVideoDriverButtons() {
	        // Deselect all video driver buttons
	        this.openGl.src = './assets/ui/options/grafopgl_n.png';
	        this.openGl.removeAttribute('data-locked');
	        this.direct3D.src = './assets/ui/options/grafdir3d_n.png';
	        this.direct3D.removeAttribute('data-locked');
	    }
	    selectScreenStyleButton(button, index) {
	        this.unlockScreenStyleButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager$1.data.settings.screenStyle = index;
	        StorageManager$1.store();
	    }
	    unlockScreenStyleButtons() {
	        // Deselect all screen style buttons
	        this.windowedButton.src = './assets/ui/options/grafwindo_n.png';
	        this.windowedButton.removeAttribute('data-locked');
	        this.fullButton.src = './assets/ui/options/grafful_n.png';
	        this.fullButton.removeAttribute('data-locked');
	    }
	    selectColorDepthButton(button, index) {
	        this.unlockColorDepthButtons();
	        button.src = button.src.slice(0, button.src.lastIndexOf('_')) + '_d.png';
	        button.setAttribute('data-locked', '');
	        StorageManager$1.data.settings.colorDepth = index;
	        StorageManager$1.store();
	    }
	    unlockColorDepthButtons() {
	        // Deselect all color depth buttons
	        this.depth16.src = './assets/ui/options/graf16bt_n.png';
	        this.depth16.removeAttribute('data-locked');
	        this.depth32.src = './assets/ui/options/graf32bt_n.png';
	        this.depth32.removeAttribute('data-locked');
	    }
	    async updateSliders() {
	        requestAnimationFrame(() => this.updateSliders());
	        if (this.div.classList.contains('hidden'))
	            return;
	        // Updates all sliders based on mouse position.
	        if (this.draggingMusicVolume) {
	            let leftStart = this.div.getBoundingClientRect().left * SCALING_RATIO$1 + this.musicVolumeKnobLeft;
	            let completion = Util$1.clamp(((currentMousePosition.x - 12) - leftStart) / this.trackLength, 0, 1);
	            this.musicVolumeKnob.style.left = Math.floor(this.musicVolumeKnobLeft + completion * this.trackLength) + 'px';
	            StorageManager$1.data.settings.musicVolume = completion;
	            AudioManager$1.updateVolumes();
	        }
	        if (this.draggingSoundVolume) {
	            let leftStart = this.div.getBoundingClientRect().left * SCALING_RATIO$1 + this.soundVolumeKnobLeft;
	            let completion = Util$1.clamp(((currentMousePosition.x - 12) - leftStart) / this.trackLength, 0, 1);
	            this.soundVolumeKnob.style.left = Math.floor(this.soundVolumeKnobLeft + completion * this.trackLength) + 'px';
	            StorageManager$1.data.settings.soundVolume = completion;
	            AudioManager$1.updateVolumes();
	            if (!this.soundTestingSound) {
	                this.soundTestingSound = AudioManager$1.createAudioSource('testing.wav');
	                this.soundTestingSound.setLoop(true);
	                this.soundTestingSound.play();
	            }
	        }
	        if (this.draggingMouseSensitivity) {
	            let leftStart = this.div.getBoundingClientRect().left * SCALING_RATIO$1 + this.mouseSensitivityKnobLeft;
	            let completion = Util$1.clamp(((currentMousePosition.x - 12) - leftStart) / this.trackLength, 0, 1);
	            this.mouseSensitivityKnob.style.left = Math.floor(this.mouseSensitivityKnobLeft + completion * this.trackLength) + 'px';
	            StorageManager$1.data.settings.mouseSensitivity = completion;
	        }
	    }
	    selectControlsTab(which) {
	        for (let elem of [this.marbleControlsDiv, this.cameraControlsDiv, this.mouseControlsDiv]) {
	            elem.classList.add('hidden');
	        }
	        let index = ['marble', 'camera', 'mouse'].indexOf(which);
	        let elem = [this.marbleControlsDiv, this.cameraControlsDiv, this.mouseControlsDiv][index];
	        elem.classList.remove('hidden');
	        this.controlsBackground.src = './assets/ui/options/' + ['cntrl_marb_bse.png', 'cntrl_cam_bse.png', 'cntrl_mous_base.png'][index];
	        if (which === 'mouse') {
	            // The mouse background is sized differently and requires its own transform
	            this.controlsBackground.style.left = '2px';
	            this.controlsBackground.style.top = '-1px';
	        }
	        else {
	            this.controlsBackground.style.left = '';
	            this.controlsBackground.style.top = '';
	        }
	    }
	    refreshKeybindings() {
	        this.buttonMarbleLeftContent.textContent = this.formatKeybinding('left');
	        this.buttonMarbleRightContent.textContent = this.formatKeybinding('right');
	        this.buttonMarbleUpContent.textContent = this.formatKeybinding('up');
	        this.buttonMarbleDownContent.textContent = this.formatKeybinding('down');
	        this.buttonMarbleUseContent.textContent = this.formatKeybinding('use');
	        this.buttonMarbleJumpContent.textContent = this.formatKeybinding('jump');
	        this.buttonCameraLeftContent.textContent = this.formatKeybinding('cameraLeft');
	        this.buttonCameraRightContent.textContent = this.formatKeybinding('cameraRight');
	        this.buttonCameraUpContent.textContent = this.formatKeybinding('cameraUp');
	        this.buttonCameraDownContent.textContent = this.formatKeybinding('cameraDown');
	        this.freeLookKeyContent.textContent = this.formatKeybinding('freeLook');
	        this.buttonRestartLevelContent.textContent = this.formatKeybinding('restart');
	    }
	    setResetMarbleTextureState(enabled) {
	        if (enabled) {
	            this.resetMarbleTexture.style.pointerEvents = '';
	            this.resetMarbleTexture.style.filter = '';
	            document.querySelector('#graphics-marble-texture-reset-text').style.opacity = '';
	        }
	        else {
	            // Make it all grayed out and things
	            this.resetMarbleTexture.style.pointerEvents = 'none';
	            this.resetMarbleTexture.style.filter = 'saturate(0)';
	            this.resetMarbleTexture.src = './assets/ui/options/cntr_cam_dwn_n.png';
	            document.querySelector('#graphics-marble-texture-reset-text').style.opacity = '0.7';
	        }
	    }
	}
	//# sourceMappingURL=options_mbg.js.map

	class HelpScreen {
	    constructor(menu) {
	        this.initProperties();
	        menu.setupButton(this.homeButton, this.homeButtonSrc, () => {
	            // Close help and go back to the main menu
	            this.hide();
	            menu.home.show();
	        }, undefined, undefined, G$1.modification === 'gold');
	    }
	    async init() { }
	    show() {
	        this.div.classList.remove('hidden');
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	}
	//# sourceMappingURL=help.js.map

	/** A list describing all possible scenes that can be displayed in the help menu. */
	const sceneDescriptions = {
	    "startPad": [{
	            dtsPath: 'shapes/pads/startarea.dts',
	            distance: 6
	        }],
	    "endPad": [{
	            dtsPath: 'shapes/pads/endarea.dts',
	            distance: 6
	        }],
	    "gems": [{
	            dtsPath: 'shapes/items/gem.dts',
	            distance: 1.6,
	            translation: new Vector3$1(0.15, 0.1, 0.05),
	            matNamesOverride: { "base.gem": "purple.gem" }
	        },
	        {
	            dtsPath: 'shapes/items/gem.dts',
	            distance: 1.6,
	            translation: new Vector3$1(-0.2, 0, -0.2)
	        },
	        {
	            dtsPath: 'shapes/items/gem.dts',
	            distance: 1.6,
	            translation: new Vector3$1(0.15, 0, -0.55),
	            matNamesOverride: { "base.gem": "green.gem" }
	        }],
	    "superSpeed": [{
	            dtsPath: 'shapes/items/superspeed.dts',
	            distance: 2.5
	        }],
	    "superJump": [{
	            dtsPath: 'shapes/items/superjump.dts',
	            distance: 2.5,
	            translation: new Vector3$1(0, 0, -0.5)
	        }],
	    "shockAbsorber": [{
	            dtsPath: 'shapes/items/shockabsorber.dts',
	            distance: 2.5
	        }],
	    "superBounce": [{
	            dtsPath: 'shapes/items/superbounce.dts',
	            distance: 2.5
	        }],
	    "gyrocopter": [{
	            dtsPath: 'shapes/images/helicopter.dts',
	            distance: 2.5,
	            translation: new Vector3$1(0, 0, -0.4)
	        }],
	    "timeTravel": [{
	            dtsPath: 'shapes/items/timetravel.dts',
	            distance: 2.5
	        }],
	    "gravityModifier": [{
	            dtsPath: 'shapes/items/antigravity.dts',
	            distance: 2.5
	        }],
	    "ductFan": [{
	            dtsPath: 'shapes/hazards/ductfan.dts',
	            distance: 3.2
	        }],
	    "tornado": [{
	            dtsPath: 'shapes/hazards/tornado.dts',
	            distance: 10,
	            translation: new Vector3$1(0, 0, -6)
	        }],
	    "trapDoor": [{
	            dtsPath: 'shapes/hazards/trapdoor.dts',
	            distance: 5,
	            translation: new Vector3$1(0, 0, 0.8)
	        }],
	    "bumper": [{
	            dtsPath: 'shapes/bumpers/pball_round.dts',
	            distance: 1.3,
	            translation: new Vector3$1(0, 0, -0.15)
	        }],
	    "mine": [{
	            dtsPath: 'shapes/hazards/landmine.dts',
	            distance: 1.3,
	            translation: new Vector3$1(0, 0, -0.1)
	        }],
	    "oilslick": [{
	            dtsPath: 'shapes/hazards/oilslick.dts',
	            distance: 7
	        }]
	};
	class MbgHelpScreen extends HelpScreen {
	    constructor(menu) {
	        super(menu);
	        // Retrieve a list all of pages from the HTML
	        this.pages = [...document.querySelectorAll('.help-page')];
	        this.helpCanvas = document.createElement('canvas');
	        /** A renderer used to render small icons of shapes in the help screen. */
	        this.helpRenderer = new Renderer({ canvas: this.helpCanvas, alpha: true, desynchronized: false });
	        this.helpCamera = new PerspectiveCamera$1(40, 1);
	        this.scenes = new Map();
	        this.shapes = new Map();
	        menu.setupButton(this.prevButton, 'play/prev', () => this.cyclePage(-1));
	        menu.setupButton(this.nextButton, 'play/next', () => this.cyclePage(1));
	        this.showHelpPage(0);
	        requestAnimationFrame(() => this.update());
	        this.helpRenderer.setSize(80, 80);
	        let rot = new Quaternion$1().setFromRotationMatrix(new Matrix4().makeRotationX(1.1));
	        this.helpCamera.orientation.premultiply(rot);
	        window.addEventListener('keydown', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'Escape') {
	                this.homeButton.src = './assets/ui/play/back_d.png';
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'Escape') {
	                this.homeButton.click();
	            }
	        });
	    }
	    initProperties() {
	        this.div = document.querySelector('#help');
	        this.homeButton = document.querySelector('#help-back');
	        this.homeButtonSrc = 'play/back';
	        this.prevButton = document.querySelector('#help-prev');
	        this.nextButton = document.querySelector('#help-next');
	    }
	    show() {
	        super.show();
	        this.initHelpScenes();
	        this.showHelpPage(0);
	    }
	    cyclePage(direction) {
	        let index = this.pages.indexOf(this.currentPage);
	        index = Util$1.adjustedMod(index + direction, this.pages.length);
	        this.showHelpPage(index);
	    }
	    showHelpPage(index) {
	        for (let page of this.pages) {
	            page.classList.add('hidden');
	        }
	        this.pages[index].classList.remove('hidden');
	        this.currentPage = this.pages[index];
	        // Scan the paragraph
	        let paragraph = this.currentPage.querySelector('.help-paragraph');
	        if (paragraph) {
	            for (let element of paragraph.children) {
	                let buttonAttribute = element.getAttribute('data-button'); // This element represents a keybinding, we need to replace its content based on what key the user has bound
	                // Automatically replace the content with the correct value for the button
	                if (buttonAttribute) {
	                    let str = Util$1.getKeyForButtonCode(StorageManager$1.data.settings.gameButtonMapping[buttonAttribute]);
	                    element.textContent = str;
	                }
	            }
	        }
	    }
	    async update() {
	        requestAnimationFrame(this.update.bind(this));
	        if (this.div.classList.contains('hidden'))
	            return;
	        let now = performance.now();
	        let canvasRows = this.currentPage.querySelectorAll('.help-canvas-row');
	        // Update all shapes in the current page
	        for (let row of canvasRows) {
	            let canvas = row.children[0];
	            let sceneName = canvas.getAttribute('data-scene'); // The name of the scene to show is stored in this attribute
	            let scene = this.scenes.get(sceneName);
	            if (!(scene === null || scene === void 0 ? void 0 : scene.compiled))
	                continue;
	            // Select the correct scene
	            let shapeArr = this.shapes.get(sceneName);
	            for (let shape of shapeArr) {
	                let euler = new Euler$1(0, 0, now / 3000 * Math.PI);
	                shape.group.orientation.setFromEuler(euler);
	                shape.group.recomputeTransform();
	            }
	            // Render the scene
	            this.helpCamera.updateMatrixWorld();
	            scene.prepareForRender(this.helpCamera);
	            this.helpRenderer.render(scene, this.helpCamera);
	            // Copy it to the other canvas
	            let ctx = canvas.getContext('2d');
	            ctx.clearRect(0, 0, 80, 80);
	            ctx.drawImage(this.helpCanvas, 0, 0);
	        }
	    }
	    async initHelpScenes() {
	        if (this.scenes.size > 0)
	            return;
	        let timeState = { timeSinceLoad: 0, currentAttemptTime: 0, gameplayClock: 0, physicsTickCompletion: 0, tickIndex: 0 };
	        // Create all scenes and shapes
	        for (let key in sceneDescriptions) {
	            let scene = new Scene$1(this.helpRenderer);
	            let description = sceneDescriptions[key];
	            let arr = [];
	            for (let shapeDescription of description) {
	                let shape = new Shape$1();
	                shape.dtsPath = shapeDescription.dtsPath;
	                if (shapeDescription.matNamesOverride)
	                    shape.matNamesOverride = shapeDescription.matNamesOverride;
	                arr.push(shape);
	            }
	            this.scenes.set(key, scene);
	            this.shapes.set(key, arr);
	        }
	        // Init the shapes
	        let promises = [];
	        for (let [, shapeArr] of this.shapes) {
	            for (let shape of shapeArr)
	                promises.push(shape.init());
	        }
	        await Promise.all(promises);
	        let lookVector = new Vector3$1(0, 0, -1);
	        lookVector.applyQuaternion(this.helpCamera.orientation);
	        // Construct the scenes and set transforms
	        for (let [key, scene] of this.scenes) {
	            let shapeArr = this.shapes.get(key);
	            for (let i = 0; i < shapeArr.length; i++) {
	                let shape = shapeArr[i];
	                let description = sceneDescriptions[key][i];
	                let position = lookVector.clone().multiplyScalar(description.distance);
	                if (description.translation)
	                    position.add(description.translation);
	                shape.setTransform(position, new Quaternion$1(), new Vector3$1(1, 1, 1));
	                shape.render(timeState);
	                scene.add(shape.group);
	            }
	            // A simple ambient light will do
	            let light = new AmbientLight$1(new Vector3$1().setScalar(1));
	            scene.addAmbientLight(light);
	            scene.compile();
	        }
	    }
	}
	//# sourceMappingURL=help_mbg.js.map

	class MbgHud extends Hud {
	    constructor() {
	        super(...arguments);
	        this.gemCountMinDigits = 2;
	        this.showClockBackground = false;
	        this.supportNumberColors = false;
	        this.supportFpsMeter = false;
	    }
	}
	//# sourceMappingURL=hud_mbg.js.map

	class MbgPauseScreen extends PauseScreen {
	    initProperties() {
	        this.div = document.querySelector('#pause-screen');
	        this.yesButton = document.querySelector('#pause-yes');
	        this.noButton = document.querySelector('#pause-no');
	        this.restartButton = document.querySelector('#pause-restart');
	        this.replayButton = document.querySelector('#pause-replay');
	        this.yesSrc = 'common/yes';
	        this.noSrc = 'common/no';
	        this.restartSrc = 'common/restart';
	    }
	    constructor(menu) {
	        super(menu);
	        this.replayButton.addEventListener('click', async (e) => {
	            if (e.button !== 0)
	                return;
	            this.onReplayButtonClick(e.altKey);
	        });
	        Util$1.onLongTouch(this.replayButton, () => this.onReplayButtonClick(true));
	    }
	}
	//# sourceMappingURL=pause_screen_mbg.js.map

	class FinishScreen {
	    constructor(menu) {
	        this.scheduled = false;
	        this.initProperties();
	        menu.setupButton(this.replayButton, 'endgame/replay', () => {
	            // Restart the level
	            G$1.game.signalRestartIntent();
	        });
	        menu.setupButton(this.continueButton, 'endgame/continue', () => G$1.game.stopAndExit());
	        menu.setupButton(this.nameEntryButton, this.nameEntryButtonSrc, async () => {
	            let trimmed = this.nameEntryInput.value.trim().slice(0, 16);
	            if (trimmed.length < 2) {
	                G$1.menu.showAlertPopup('Warning', "Please enter a proper name for usage in the online leaderboard.");
	                return;
	            }
	            if (Util$1.isNaughty(trimmed)) {
	                G$1.menu.showAlertPopup('Warning', "The name you chose contains words deemed inappropriate. Please do the right thing and choose a non-offensive name.");
	                return;
	            }
	            StorageManager$1.data.lastUsedName = trimmed;
	            StorageManager$1.store();
	            // Store the time and close the dialog.
	            let game = G$1.game;
	            let inserted = StorageManager$1.insertNewTime(game.mission.path, trimmed, 1000 * game.finishState.time);
	            this.nameEntryScreenDiv.classList.add('hidden');
	            this.div.style.pointerEvents = '';
	            this.drawBestTimes();
	            if (inserted) {
	                // Store the replay
	                /* todo
	                if (game.replay.mode === 'record' && !game.replay.isInvalid) {
	                    game.replay.canStore = false;
	                    let serialized = await game.replay.serialize();
	                    await StorageManager.databasePut('replays', serialized, inserted.score[2]);
	                }*/
	                // Submit the score to the leaderboard but only if it's the local top time and qualified
	                if (inserted.index === 0 && 1000 * game.finishState.time <= game.mission.qualifyTime)
	                    Leaderboard.submitBestTime(game.mission.path, inserted.score);
	            }
	        }, undefined, undefined, G$1.modification === 'gold');
	        window.addEventListener('keydown', (e) => {
	            if (!G$1.game)
	                return;
	            if (G$1.menu !== menu)
	                return;
	            if (G$1.game.type === 'multiplayer')
	                return; // Enter should open chat instead
	            if (e.key === 'Enter') {
	                if (!this.nameEntryScreenDiv.classList.contains('hidden')) {
	                    this.nameEntryButton.src = menu.uiAssetPath + this.nameEntryButtonSrc + '_d.png';
	                }
	                else if (!this.div.classList.contains('hidden')) {
	                    this.continueButton.src = menu.uiAssetPath + 'endgame/continue_d.png';
	                }
	            }
	        });
	        window.addEventListener('keyup', (e) => {
	            if (!G$1.game)
	                return;
	            if (G$1.menu !== menu)
	                return;
	            if (G$1.game.type === 'multiplayer')
	                return; // Enter should open chat instead
	            if (e.key === 'Enter') {
	                if (!this.nameEntryScreenDiv.classList.contains('hidden')) {
	                    this.nameEntryButton.click();
	                }
	                else if (!this.div.classList.contains('hidden')) {
	                    this.continueButton.click();
	                }
	            }
	        });
	    }
	    get showing() {
	        return !this.div.classList.contains('hidden');
	    }
	    async init() {
	        for (let i = 0; i < this.bestTimeCount; i++) {
	            let element = this.createBestTimeElement();
	            this.bestTimeContainer.appendChild(element);
	        }
	    }
	    schedule() {
	        if (this.scheduled)
	            return;
	        this.scheduled = true;
	        setTimeout(() => {
	            var _a;
	            // Show the finish screen
	            (_a = document.exitPointerLock) === null || _a === void 0 ? void 0 : _a.call(document);
	            G$1.menu.finishScreen.show();
	            hideTouchControls$1();
	            resetPressedFlag$1('use');
	            resetPressedFlag$1('jump');
	            resetPressedFlag$1('restart');
	        }, 2000);
	    }
	    show() {
	        let game = G$1.game;
	        this.div.classList.remove('hidden');
	        let time = game.finishState.time;
	        let elapsedTime = game.finishState.elapsedTime;
	        let bonusTime = Util$1.roundToMultiple(Math.max(0, elapsedTime - time), 1e-8); // Fix 4999 bullshit
	        let failedToQualify = false;
	        // Change the message based on having achieve gold time, qualified time or not having qualified.
	        if (1000 * time > game.mission.qualifyTime) {
	            this.showMessage('failed');
	            failedToQualify = true;
	        }
	        else if (1000 * time <= game.mission.ultimateTime) {
	            this.showMessage('ultimate');
	        }
	        else if (1000 * time <= game.mission.goldTime) {
	            this.showMessage('gold');
	        }
	        else {
	            this.showMessage('qualified');
	        }
	        this.updateTimeElements(elapsedTime, bonusTime, failedToQualify);
	        this.drawBestTimes();
	        let bestTimes = StorageManager$1.getBestTimesForMission(game.mission.path, this.bestTimeCount, this.scorePlaceholderName);
	        let place = bestTimes.filter(x => x[1] <= 1000 * time).length; // The place is determined by seeing how many scores there currently are faster than the achieved time.
	        if (game.type === 'singleplayer' && place < this.bestTimeCount && (!failedToQualify || this.storeNotQualified)) {
	            // Prompt the user to enter their name
	            this.nameEntryScreenDiv.classList.remove('hidden');
	            this.nameEntryText.textContent = this.generateNameEntryText(place);
	            this.nameEntryInput.value = StorageManager$1.data.lastUsedName;
	            this.div.style.pointerEvents = 'none';
	            //nameEntryInput.select(); // Don't select, since we want to avoid renames for leaderboard consistency
	        }
	        else {
	            this.nameEntryScreenDiv.classList.add('hidden');
	            this.div.style.pointerEvents = '';
	        }
	        if (!failedToQualify && game.mission.type !== 'custom') {
	            let levelSelect = G$1.menu.levelSelect;
	            if (levelSelect.currentMission === game.mission)
	                levelSelect.cycleMission(1); // Cycle to that next level, but only if it isn't already selected
	        }
	        // todo Hide the replay button if the replay's invalid
	        //this.viewReplayButton.style.display = game.replay.isInvalid? 'none' : '';
	    }
	    hide() {
	        this.div.classList.add('hidden');
	        this.scheduled = false;
	    }
	    /** Updates the best times. */
	    drawBestTimes() {
	        let bestTimes = StorageManager$1.getBestTimesForMission(G$1.game.mission.path, this.bestTimeCount, this.scorePlaceholderName);
	        for (let i = 0; i < this.bestTimeCount; i++) {
	            this.updateBestTimeElement(this.bestTimeContainer.children[i], bestTimes[i], i + 1);
	        }
	    }
	    async onViewReplayButtonClick(download) {
	        let game = G$1.game;
	        // todo
	        if (download) {
	            let serialized = await game.replay.serialize();
	            Replay$1.download(serialized, game.mission, false);
	            if (Util$1.isTouchDevice && Util$1.isInFullscreen())
	                G$1.menu.showAlertPopup('Downloaded', 'The .wrec has been downloaded.');
	        }
	        else {
	            let confirmed = await G$1.menu.showConfirmPopup('Confirm', `Do you want to start the replay for the last playthrough? This can be done only once if this isn't one of your top ${this.bestTimeCount} local scores.`);
	            if (!confirmed)
	                return;
	            game.replay.mode = 'playback';
	            this.replayButton.click();
	        }
	    }
	    handleGamepadInput() {
	        // If the finish screen is up, handle those buttons ...
	        if (!this.nameEntryScreenDiv.classList.contains('hidden')) {
	            if (isPressedByGamepad('jump') && getPressedFlag$1('jump')) {
	                resetPressedFlag$1('jump');
	                this.nameEntryButton.click();
	                AudioManager$1.play('buttonpress.wav');
	            }
	        }
	        else if (!this.div.classList.contains('hidden')) {
	            // Check for buttons
	            if (isPressedByGamepad('use') && getPressedFlag$1('use')) {
	                resetPressedFlag$1('use');
	                this.viewReplayButton.click();
	                AudioManager$1.play('buttonpress.wav');
	            }
	            if (isPressedByGamepad('jump') && getPressedFlag$1('jump')) {
	                resetPressedFlag$1('jump');
	                this.continueButton.click();
	                AudioManager$1.play('buttonpress.wav');
	                return;
	            }
	            if (isPressedByGamepad('restart') && getPressedFlag$1('restart')) {
	                resetPressedFlag$1('restart');
	                this.replayButton.click();
	                AudioManager$1.play('buttonpress.wav');
	            }
	        }
	    }
	}
	//# sourceMappingURL=finish_screen.js.map

	class MbgFinishScreen extends FinishScreen {
	    constructor(menu) {
	        super(menu);
	        this.viewReplayButton = document.querySelector('#finish-view-replay');
	        this.bestTimeCount = 3;
	        this.scorePlaceholderName = "Nardo Polo";
	        this.storeNotQualified = false;
	        this.viewReplayButton.addEventListener('click', async (e) => {
	            if (e.button !== 0)
	                return;
	            this.onViewReplayButtonClick(e.altKey);
	        });
	        Util$1.onLongTouch(this.viewReplayButton, () => this.onViewReplayButtonClick(true));
	        this.viewReplayButton.addEventListener('mouseenter', () => AudioManager$1.play('buttonover.wav'));
	        this.viewReplayButton.addEventListener('mousedown', () => AudioManager$1.play('buttonpress.wav'));
	    }
	    initProperties() {
	        this.div = document.querySelector('#finish-screen');
	        this.time = document.querySelector('#finish-screen-time-time');
	        this.message = document.querySelector('#finish-message');
	        this.qualifyTimeElement = document.querySelector('#finish-qualify-time');
	        this.goldTimeElement = document.querySelector('#finish-gold-time');
	        this.elapsedTimeElement = document.querySelector('#finish-elapsed-time');
	        this.bonusTimeElement = document.querySelector('#finish-bonus-time');
	        this.replayButton = document.querySelector('#finish-replay');
	        this.continueButton = document.querySelector('#finish-continue');
	        this.bestTimeContainer = document.querySelector('#finish-best-times');
	        this.nameEntryScreenDiv = document.querySelector('#name-entry-screen');
	        this.nameEntryText = document.querySelector('#name-entry-screen > p:nth-child(3)');
	        this.nameEntryInput = document.querySelector('#name-entry-input');
	        this.nameEntryButton = this.nameEntryScreenDiv.querySelector('#name-entry-confirm');
	        this.nameEntryButtonSrc = 'common/ok';
	    }
	    showMessage(type) {
	        this.message.style.color = '';
	        if (type === 'gold') {
	            this.message.innerHTML = 'You beat the <span style="color: #fff700;">GOLD</span> time!';
	        }
	        else if (type === 'qualified') {
	            this.message.innerHTML = "You've qualified!";
	        }
	        else {
	            this.message.innerHTML = "You failed to qualify!";
	            this.message.style.color = 'red';
	        }
	    }
	    updateTimeElements(elapsedTime, bonusTime, failedToQualify) {
	        let game = G$1.game;
	        this.time.textContent = Util$1.secondsToTimeString(game.finishState.time);
	        this.qualifyTimeElement.textContent = isFinite(game.mission.qualifyTime) ? Util$1.secondsToTimeString(game.mission.qualifyTime / 1000) : Util$1.secondsToTimeString(5999.999);
	        this.qualifyTimeElement.style.color = failedToQualify ? 'red' : '';
	        this.qualifyTimeElement.style.textShadow = failedToQualify ? '1px 1px 0px black' : '';
	        Util$1.monospaceNumbers(this.qualifyTimeElement);
	        let goldTime = game.mission.goldTime;
	        this.goldTimeElement.textContent = Util$1.secondsToTimeString(goldTime / 1000);
	        this.goldTimeElement.parentElement.style.display = (goldTime !== -Infinity) ? '' : 'none';
	        Util$1.monospaceNumbers(this.goldTimeElement);
	        this.elapsedTimeElement.textContent = Util$1.secondsToTimeString(elapsedTime / 1000);
	        this.bonusTimeElement.textContent = Util$1.secondsToTimeString(bonusTime / 1000);
	        Util$1.monospaceNumbers(this.elapsedTimeElement);
	        Util$1.monospaceNumbers(this.bonusTimeElement);
	    }
	    createBestTimeElement() {
	        let div = document.createElement('div');
	        div.innerHTML = '<p></p><p></p>';
	        div.classList.add('finish-row');
	        return div;
	    }
	    updateBestTimeElement(element, score, rank) {
	        let goldTime = G$1.game.mission.goldTime;
	        element.children[0].textContent = rank + '. ' + score[0];
	        element.children[1].textContent = Util$1.secondsToTimeString(score[1] / 1000);
	        Util$1.monospaceNumbers(element.children[1]);
	        element.children[1].style.color = (score[1] <= goldTime) ? '#fff700' : '';
	        element.children[1].style.textShadow = (score[1] <= goldTime) ? '1px 1px 0px black' : '';
	    }
	    generateNameEntryText(place) {
	        return `You got the ${['best', '2nd best', '3rd best'][place]} time!`;
	    }
	}
	//# sourceMappingURL=finish_screen_mbg.js.map

	class MbgMenu extends Menu {
	    constructor() {
	        super(...arguments);
	        this.audioAssetPath = './assets/data/sound/';
	        this.menuMusicSrc = 'shell.ogg';
	        this.popupBackgroundSrc = './assets/ui/common/dialog.png';
	        this.popupOkaySrc = 'common/ok';
	        this.popupNoSrc = 'common/no';
	        this.popupYesSrc = 'common/yes';
	    }
	    get uiAssetPath() {
	        return './assets/ui/';
	    }
	    createHome() {
	        return new MbgHomeScreen(this);
	    }
	    createLevelSelect() {
	        return new MbgLevelSelect(this);
	    }
	    createLoadingScreen() {
	        return new MbgLoadingScreen(this);
	    }
	    createOptionsScreen() {
	        return new MbgOptionsScreen(this);
	    }
	    createHelpScreen() {
	        return new MbgHelpScreen(this);
	    }
	    createHud() {
	        return new MbgHud(this);
	    }
	    createPauseScreen() {
	        return new MbgPauseScreen(this);
	    }
	    createFinishScreen() {
	        return new MbgFinishScreen(this);
	    }
	    getMenuDiv() {
	        return document.querySelector('#menu');
	    }
	    getBackgroundImage() {
	        return document.querySelector('#background-image');
	    }
	    async init() {
	        if (Util$1.isWeeb) {
	            this.backgroundImage.src = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	        }
	        await super.init();
	    }
	}
	//# sourceMappingURL=menu_mbg.js.map

	const MBP_GOLD_COLOR = 'rgb(255, 204, 0)';
	const MBP_PLATINUM_COLOR = 'rgb(204, 204, 204)';
	const MBP_ULTIMATE_COLOR = 'rgb(255, 221, 34)';
	class MbpFinishScreen extends FinishScreen {
	    constructor(menu) {
	        super(menu);
	        this.viewReplayButton = document.querySelector('#mbp-finish-view-replay');
	        this.timeRows = document.querySelector('#mbp-finish-time-rows');
	        this.nextLevelImage = document.querySelector('#mbp-finish-next-level-image');
	        this.nextLevelButton = document.querySelector('#mbp-finish-next-level');
	        this.bestTimeCount = 5;
	        this.scorePlaceholderName = "Matan W.";
	        this.storeNotQualified = true;
	        menu.setupButton(this.viewReplayButton, 'play/replay', (e) => this.onViewReplayButtonClick(e.altKey));
	        Util$1.onLongTouch(this.viewReplayButton, () => this.onViewReplayButtonClick(true));
	        this.qualifyTimeElement = this.createTimeRow('Par Time').children[0];
	        this.goldTimeElement = this.createTimeRow('Gold Time').children[0];
	        this.platinumTimeElement = this.createTimeRow('Platinum Time').children[0];
	        this.ultimateTimeElement = this.createTimeRow('Ultimate Time').children[0];
	        this.elapsedTimeElement = this.createTimeRow('Time Passed').children[0];
	        this.bonusTimeElement = this.createTimeRow('Clock Bonuses').children[0];
	        this.goldTimeElement.parentElement.style.color = 'rgb(255, 204, 0)';
	        this.platinumTimeElement.parentElement.style.color = 'rgb(204, 204, 204)';
	        this.ultimateTimeElement.parentElement.style.color = 'rgb(255, 221, 34)';
	        this.elapsedTimeElement.parentElement.style.marginTop = '20px';
	        menu.setupButton(this.nextLevelButton, 'endgame/level_window', () => {
	            let nextLevel = this.getNextLevel();
	            let levelSelect = G$1.menu.levelSelect;
	            // Exit to level select and immediately load the next level
	            this.continueButton.click();
	            levelSelect.setMissionArray(nextLevel.array);
	            levelSelect.currentMissionIndex = nextLevel.index;
	            levelSelect.playCurrentMission();
	        }, undefined, undefined, false);
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-finish-screen');
	        this.time = document.querySelector('#mbp-finish-screen-time-time');
	        this.message = document.querySelector('#mbp-finish-message');
	        this.replayButton = document.querySelector('#mbp-finish-replay');
	        this.continueButton = document.querySelector('#mbp-finish-continue');
	        this.bestTimeContainer = document.querySelector('#mbp-finish-screen-top-times');
	        this.nameEntryScreenDiv = document.querySelector('#mbp-name-entry-screen');
	        this.nameEntryText = document.querySelector('#mbp-name-entry-screen > p:nth-child(3)');
	        this.nameEntryInput = document.querySelector('#mbp-name-entry-input');
	        this.nameEntryButton = this.nameEntryScreenDiv.querySelector('#mbp-name-entry-confirm');
	        this.nameEntryButtonSrc = 'endgame/ok';
	    }
	    createTimeRow(label) {
	        let row = document.createElement('p');
	        row.innerHTML = label + ':<span></span>';
	        this.timeRows.appendChild(row);
	        return row;
	    }
	    show() {
	        super.show();
	        let game = G$1.game;
	        let nextLevel = this.getNextLevel();
	        let mission = nextLevel.array[nextLevel.index];
	        if (game.type === 'multiplayer') {
	            this.nextLevelImage.style.display = 'none';
	            this.nextLevelButton.style.display = 'none';
	        }
	        else {
	            this.nextLevelImage.style.display = '';
	            this.nextLevelButton.style.display = '';
	            this.nextLevelImage.src = mission.getImagePath();
	        }
	    }
	    showMessage(type) {
	        this.message.style.color = '';
	        if (type === 'ultimate') {
	            this.message.innerHTML = `You beat the <span style="color: ${MBP_ULTIMATE_COLOR};">Ultimate</span> Time!`;
	        }
	        else if (type === 'gold') {
	            if (G$1.game.mission.modification === 'gold')
	                this.message.innerHTML = `You beat the <span style="color: ${MBP_GOLD_COLOR};">Gold</span> Time!`;
	            else
	                this.message.innerHTML = `You beat the <span style="color: ${MBP_PLATINUM_COLOR};">Platinum</span> Time!`;
	        }
	        else if (type === 'qualified') {
	            this.message.innerHTML = "You beat the Par Time!";
	        }
	        else {
	            this.message.innerHTML = "You didn't pass the Par Time!";
	            this.message.style.color = 'rgb(245, 85, 85)';
	        }
	    }
	    updateTimeElements(elapsedTime, bonusTime) {
	        let game = G$1.game;
	        this.time.textContent = Util$1.secondsToTimeString(game.finishState.time);
	        this.qualifyTimeElement.textContent = isFinite(game.mission.qualifyTime) ? Util$1.secondsToTimeString(game.mission.qualifyTime / 1000) : Util$1.secondsToTimeString(5999.999);
	        Util$1.monospaceNumbers(this.qualifyTimeElement);
	        let goldTime = game.mission.goldTime;
	        this.goldTimeElement.parentElement.style.display = 'none';
	        this.platinumTimeElement.parentElement.style.display = 'none';
	        if (goldTime !== -Infinity) {
	            if (game.mission.modification === 'gold') {
	                this.goldTimeElement.textContent = Util$1.secondsToTimeString(goldTime / 1000);
	                this.goldTimeElement.parentElement.style.display = '';
	                Util$1.monospaceNumbers(this.goldTimeElement);
	            }
	            else {
	                this.platinumTimeElement.textContent = Util$1.secondsToTimeString(goldTime / 1000);
	                this.platinumTimeElement.parentElement.style.display = '';
	                Util$1.monospaceNumbers(this.platinumTimeElement);
	            }
	        }
	        let ultimateTime = game.mission.ultimateTime;
	        this.ultimateTimeElement.parentElement.style.display = 'none';
	        if (ultimateTime !== -Infinity) {
	            this.ultimateTimeElement.textContent = Util$1.secondsToTimeString(ultimateTime / 1000);
	            this.ultimateTimeElement.parentElement.style.display = '';
	            Util$1.monospaceNumbers(this.ultimateTimeElement);
	        }
	        this.elapsedTimeElement.textContent = Util$1.secondsToTimeString(elapsedTime / 1000);
	        this.bonusTimeElement.textContent = Util$1.secondsToTimeString(bonusTime / 1000);
	        Util$1.monospaceNumbers(this.elapsedTimeElement);
	        Util$1.monospaceNumbers(this.bonusTimeElement);
	    }
	    createBestTimeElement() {
	        let div = document.createElement('div');
	        return div;
	    }
	    updateBestTimeElement(element, score, rank) {
	        let goldTime = G$1.game.mission.goldTime;
	        let ultimateTime = G$1.game.mission.ultimateTime;
	        let tmp = document.createElement('div');
	        tmp.textContent = Util$1.secondsToTimeString(score[1] / 1000);
	        Util$1.monospaceNumbers(tmp);
	        element.innerHTML = `<div><span>${rank}. </span>${Util$1.htmlEscape(score[0])}</div><div>${tmp.innerHTML}</div>`;
	        element.style.color = '';
	        if (score[1] <= goldTime)
	            element.style.color = (G$1.game.mission.modification === 'gold') ? MBP_GOLD_COLOR : MBP_PLATINUM_COLOR;
	        if (score[1] <= ultimateTime)
	            element.style.color = MBP_ULTIMATE_COLOR;
	    }
	    generateNameEntryText(place) {
	        return `You have the ${['top', 'second top', 'third top', 'fourth top', 'fifth top'][place]} time!`;
	    }
	    /** Figures out what the next level after this one should be. */
	    getNextLevel() {
	        let levelSelect = G$1.menu.levelSelect;
	        let currIndex = levelSelect.currentMissionArray.indexOf(G$1.game.mission); // Get it like this because the index might have already changed
	        if (currIndex < levelSelect.currentMissionArray.length - 1) {
	            // Just the next level in the current array
	            return {
	                index: currIndex + 1,
	                array: levelSelect.currentMissionArray
	            };
	        }
	        else {
	            if (levelSelect.currentMission.type === 'custom') {
	                return {
	                    // We stay at the last custom level
	                    index: currIndex,
	                    array: levelSelect.currentMissionArray
	                };
	            }
	            else {
	                // Move on to the next mission array
	                let order = MissionLibrary.allMissionArrays;
	                let next = order[order.indexOf(levelSelect.currentMissionArray) + 1];
	                return {
	                    index: 0,
	                    array: next
	                };
	            }
	        }
	    }
	}
	//# sourceMappingURL=finish_screen_mbp.js.map

	class MbpLevelSelect extends LevelSelect {
	    constructor() {
	        super(...arguments);
	        this.loadReplayButton = document.querySelector('#mbp-load-replay-button');
	        this.shuffleButton = document.querySelector('#mbp-shuffle-button');
	        this.viewToggleButton = document.querySelector('#mbp-level-select-view-toggle');
	        this.metadataContainer = document.querySelector('#mbp-level-metadata');
	        this.scoresContainer = document.querySelector('#mbp-level-scores');
	        this.easterEggIcon = document.querySelector('#mbp-level-select-egg');
	        this.background = document.querySelector('#mbp-level-select-background');
	        this.imageFrame = document.querySelector('#mbp-level-select-frame');
	        this.chooseLevelButton = document.querySelector('#mbp-level-select-choose');
	        this.cancelButton = document.querySelector('#mbp-level-select-cancel');
	        this.difficultySelectorCollapsed = document.querySelector('#mbp-difficulty-selector-collapsed');
	        this.difficultySelectorModificationIcon = document.querySelector('#mbp-difficulty-selector-modification-icon');
	        this.difficultySelectorWindow = document.querySelector('#mbp-difficulty-selector-window');
	        this.difficultySelectorContent = document.querySelector('#mbp-difficulty-selector-window > ._content');
	        this.localScoresCount = 5;
	        this.scorePlaceholderName = "Matan W.";
	        this.scoreElementHeight = 16;
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-level-select');
	        this.homeButton = document.querySelector('#mbp-level-select-home-button');
	        this.homeButtonSrc = 'play/menu';
	        this.prevButton = document.querySelector('#mbp-level-select-prev');
	        this.playButton = document.querySelector('#mbp-level-select-play');
	        this.nextButton = document.querySelector('#mbp-level-select-next');
	        this.levelImage = document.querySelector('#mbp-level-image');
	        this.levelTitle = document.querySelector('#mbp-level-title');
	        this.levelArtist = document.querySelector('#mbp-level-artist');
	        this.levelDescription = document.querySelector('#mbp-level-description');
	        this.levelQualifyTime = document.querySelector('#mbp-level-qualify-time');
	        this.localBestTimesContainer = document.querySelector('#mbp-level-select-local-best-times');
	        this.leaderboardLoading = document.querySelector('#mbp-online-leaderboard-loading');
	        this.leaderboardScores = document.querySelector('#mbp-leaderboard-scores');
	        this.scrollWindow = document.querySelector('#mbp-level-select-text-window');
	        this.searchInput = document.querySelector('#mbp-search-input');
	    }
	    async init() {
	        await super.init();
	        this.menu.setupVaryingButton(this.difficultySelectorCollapsed, [
	            'play/difficulty_beginner', 'play/difficulty_intermediate', 'play/difficulty_advanced', 'play/difficulty_expert', 'play/difficulty_custom'
	        ], () => {
	            if (this.difficultySelectorWindow.classList.contains('hidden')) {
	                this.difficultySelectorWindow.classList.remove('hidden');
	            }
	            else {
	                this.difficultySelectorWindow.classList.add('hidden');
	            }
	        }, undefined, undefined, false);
	        this.createDifficultySection('Gold', './assets/ui_mbp/play/marble_gold.png', [
	            { name: 'Beginner', arr: MissionLibrary.goldBeginner },
	            { name: 'Intermediate', arr: MissionLibrary.goldIntermediate },
	            { name: 'Advanced', arr: MissionLibrary.goldAdvanced },
	            { name: 'Custom', arr: MissionLibrary.goldCustom }
	        ]);
	        this.createDifficultySection('Platinum', './assets/ui_mbp/play/marble_platinum.png', [
	            { name: 'Beginner', arr: MissionLibrary.platinumBeginner },
	            { name: 'Intermediate', arr: MissionLibrary.platinumIntermediate },
	            { name: 'Advanced', arr: MissionLibrary.platinumAdvanced },
	            { name: 'Expert', arr: MissionLibrary.platinumExpert },
	            { name: 'Custom', arr: MissionLibrary.platinumCustom }
	        ]);
	        this.createDifficultySection('Ultra', './assets/ui_mbp/play/marble_ultra.png', [
	            { name: 'Beginner', arr: MissionLibrary.ultraBeginner },
	            { name: 'Intermediate', arr: MissionLibrary.ultraIntermediate },
	            { name: 'Advanced', arr: MissionLibrary.ultraAdvanced },
	            { name: 'Custom', arr: MissionLibrary.ultraCustom }
	        ]);
	        this.difficultySelectorWindow.querySelector('._click-preventer').addEventListener('mousedown', () => {
	            AudioManager$1.play('buttonpress.wav');
	        });
	        this.difficultySelectorWindow.querySelector('._click-preventer').addEventListener('click', () => {
	            this.difficultySelectorWindow.classList.add('hidden');
	        });
	        // Button toggles between metadata and scores screen
	        this.menu.setupVaryingButton(this.viewToggleButton, ['mp/play/scoresactive', 'mp/play/settingsactive'], () => {
	            if (this.scoresContainer.classList.contains('hidden')) {
	                this.metadataContainer.classList.add('hidden');
	                this.scoresContainer.classList.remove('hidden');
	                this.levelQualifyTime.classList.add('hidden');
	                this.scrollWindow.style.height = '';
	                this.menu.setButtonVariant(this.viewToggleButton, 1);
	                this.viewToggleButton.title = "Show level information";
	            }
	            else {
	                this.metadataContainer.classList.remove('hidden');
	                this.scoresContainer.classList.add('hidden');
	                this.levelQualifyTime.classList.remove('hidden');
	                this.scrollWindow.style.height = '150px';
	                this.menu.setButtonVariant(this.viewToggleButton, 0);
	                this.viewToggleButton.title = "Show scores";
	            }
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.loadReplayButton, 'play/replay', () => {
	            this.showLoadReplayPrompt();
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.shuffleButton, 'search/random', () => {
	            this.shuffle();
	        }, undefined, undefined, false);
	        // Preload images and leaderboards
	        this.setMissionArray(MissionLibrary.goldCustom, false); // Make sure to disable the image timeouts so that no funky stuff happens
	        this.setMissionArray(MissionLibrary.goldAdvanced, false);
	        this.setMissionArray(MissionLibrary.goldIntermediate, false);
	        this.setMissionArray(MissionLibrary.goldBeginner, false);
	        this.setMissionArray(MissionLibrary.platinumCustom, false);
	        this.setMissionArray(MissionLibrary.platinumExpert, false);
	        this.setMissionArray(MissionLibrary.platinumAdvanced, false);
	        this.setMissionArray(MissionLibrary.platinumIntermediate, false);
	        this.setMissionArray(MissionLibrary.platinumBeginner, false);
	        this.setMissionArray(MissionLibrary.ultraCustom, false);
	        this.setMissionArray(MissionLibrary.ultraAdvanced, false);
	        this.setMissionArray(MissionLibrary.ultraIntermediate, false);
	        this.setMissionArray(MissionLibrary.ultraBeginner, false);
	        // Show a random beginner category at the start
	        this.setMissionArray(Util$1.randomFromArray([MissionLibrary.goldBeginner /*, MissionLibrary.platinumBeginner, MissionLibrary.ultraBeginner*/]), false); // fixme
	        // todo: This but for Lobby screen
	        await ResourceManager$1.loadImages(['play/eggnotfound.png', 'play/eggfound.png', 'play/marble_gold.png', 'play/marble_platinum.png', 'play/marble_ultra.png', 'mp/menu/brown/joined.png', 'mp/menu/brown/divider-orange-joined.png', 'options/textentry.png'].map(x => './assets/ui_mbp/' + x));
	        this.menu.setupButton(this.chooseLevelButton, 'mp/play/choose', () => {
	            this.hide();
	            G$1.lobby.settings.missionPath = this.currentMission.path;
	            G$1.lobby.onSettingsChanged();
	            this.menu.lobbyScreen.show();
	        }, undefined, undefined, false);
	        this.menu.setupButton(this.cancelButton, 'mp/search/cancel', () => {
	            this.hide();
	            this.menu.lobbyScreen.show();
	        });
	    }
	    /** Creates a vertical section for the difficulty picker. */
	    createDifficultySection(title, img, difficulties) {
	        let div = document.createElement('div');
	        let header = document.createElement('p');
	        let icon = document.createElement('img');
	        div.classList.add('_section');
	        div.append(header, icon);
	        header.textContent = title;
	        icon.src = img;
	        for (let difficulty of difficulties) {
	            let container = document.createElement('div');
	            let nameElement = document.createElement('p');
	            let buttonElement = document.createElement('img');
	            container.append(nameElement, buttonElement);
	            div.append(container);
	            nameElement.textContent = difficulty.name;
	            this.menu.setupButton(buttonElement, 'play/difficulty_highlight-120', () => {
	                this.setMissionArray(difficulty.arr);
	                this.difficultySelectorWindow.classList.add('hidden');
	            });
	            if (!difficulty.arr) {
	                container.style.opacity = '0.333';
	                container.style.pointerEvents = 'none';
	            }
	        }
	        this.difficultySelectorContent.append(div);
	    }
	    setMissionArray(arr, doImageTimeout) {
	        super.setMissionArray(arr, doImageTimeout);
	        if (arr.length > 0) {
	            // Make sure to update the difficulty picker accordingly
	            this.menu.setButtonVariant(this.difficultySelectorCollapsed, ['beginner', 'intermediate', 'advanced', 'expert', 'custom'].indexOf(MissionLibrary.getDifficulty(arr)));
	            this.difficultySelectorModificationIcon.src = "./assets/ui_mbp/play/" + ((MissionLibrary.getModification(arr) === 'gold') ? "marble_gold.png" : (MissionLibrary.getModification(arr) === 'ultra') ? "marble_ultra.png" : "marble_platinum.png");
	        }
	        this.updateBackground();
	    }
	    displayMetadata() {
	        let mission = this.currentMission;
	        this.levelTitle.textContent = `#${this.currentMissionIndex + 1}: ${mission.title}`;
	        this.levelArtist.textContent = 'Author: ' + mission.artist.trim();
	        this.levelDescription.textContent = mission.description;
	        let qualifyTime = (mission.qualifyTime !== 0) ? mission.qualifyTime : Infinity;
	        this.levelQualifyTime.innerHTML = `<span style="opacity: 0.8;">${mission.modification === 'gold' ? 'Qualify' : 'Par'} Time: </span>` + (isFinite(qualifyTime) ? Util$1.secondsToTimeString(qualifyTime / 1000) : 'N/A');
	        if (mission.hasEasterEgg) {
	            this.easterEggIcon.classList.remove('hidden');
	            this.easterEggIcon.src = StorageManager$1.data.collectedEggs.includes(mission.path) ? './assets/ui_mbp/play/eggfound.png' : './assets/ui_mbp/play/eggnotfound.png';
	        }
	        else {
	            this.easterEggIcon.classList.add('hidden');
	        }
	    }
	    displayEmptyMetadata() {
	        this.levelTitle.innerHTML = '<br>';
	        this.levelArtist.innerHTML = '<br>';
	        this.levelDescription.innerHTML = '<br>';
	        this.levelQualifyTime.innerHTML = '';
	        this.easterEggIcon.classList.add('hidden');
	    }
	    createScoreElement(includeReplayButton) {
	        let element = document.createElement('div');
	        element.classList.add('mbp-level-select-best-time');
	        let name = document.createElement('div');
	        element.appendChild(name);
	        let time = document.createElement('div');
	        element.appendChild(time);
	        if (includeReplayButton) {
	            element.appendChild(this.createReplayButton());
	        }
	        return element;
	    }
	    updateScoreElement(element, score, rank) {
	        element.children[0].innerHTML = `<span>${rank}.</span> ${Util$1.htmlEscape(score[0])}`;
	        element.children[1].textContent = Util$1.secondsToTimeString(score[1] / 1000);
	        Util$1.monospaceNumbers(element.children[1]);
	        if (element.children[2])
	            this.updateReplayButton(element.children[2], score);
	        element.style.color = '';
	        if (!this.currentMission)
	            return;
	        if (score[1] <= this.currentMission.goldTime)
	            element.style.color = (this.currentMission.modification === 'gold') ? MBP_GOLD_COLOR : MBP_PLATINUM_COLOR;
	        if (score[1] <= this.currentMission.ultimateTime)
	            element.style.color = MBP_ULTIMATE_COLOR;
	    }
	    show(lobbyLevelSelect = false) {
	        super.show();
	        this.updateBackground();
	        if (lobbyLevelSelect) {
	            this.playButton.style.display = 'none';
	            this.chooseLevelButton.style.display = '';
	            this.cancelButton.style.display = '';
	            this.viewToggleButton.style.display = 'none';
	            this.loadReplayButton.style.display = 'none';
	            this.background.style.filter = this.imageFrame.style.filter = 'hue-rotate(180deg) saturate(0.7)';
	            if (!this.scoresContainer.classList.contains('hidden'))
	                this.viewToggleButton.click();
	            if (this.currentMission.path !== G$1.lobby.settings.missionPath) {
	                this.setMissionArray(MissionLibrary.allMissionArrays.find(x => x.some(y => y.path === G$1.lobby.settings.missionPath)));
	                this.currentMissionIndex = this.currentMissionArray.findIndex(x => x.path === G$1.lobby.settings.missionPath);
	                this.displayMission();
	            }
	        }
	        else {
	            this.playButton.style.display = '';
	            this.chooseLevelButton.style.display = 'none';
	            this.cancelButton.style.display = 'none';
	            this.viewToggleButton.style.display = '';
	            this.loadReplayButton.style.display = '';
	            this.background.style.filter = this.imageFrame.style.filter = '';
	        }
	    }
	    /** Sets the background image based on the modification. */
	    updateBackground() {
	        let arr = this.currentMissionArray;
	        G$1.menu.backgroundImage.src =
	            (MissionLibrary.getModification(arr) === 'gold') ? G$1.menu.mbgBg :
	                (MissionLibrary.getModification(arr) === 'ultra') ? G$1.menu.mbuBg :
	                    G$1.menu.mbpBg;
	    }
	}
	//# sourceMappingURL=level_select_mbp.js.map

	class MbpHomeScreen extends HomeScreen {
	    constructor(menu) {
	        super(menu);
	        this.onlineButton = document.querySelector('#mbp-home-online');
	        menu.setupButton(this.onlineButton, 'menu/online', () => {
	            this.hide();
	            menu.lobbySelectScreen.show();
	        });
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-home-screen');
	        this.playButton = document.querySelector('#mbp-home-play');
	        this.optionsButton = document.querySelector('#mbp-home-options');
	        this.helpButton = document.querySelector('#mbp-home-help');
	        this.exitButton = document.querySelector('#mbp-home-quit');
	        this.showChangelogButton = document.querySelector('#mbp-show-changelog');
	        this.changelogContainer = document.querySelector('#mbp-changelog');
	        this.changelogBackButton = document.querySelector('#mbp-changelog-back');
	        this.changelogContent = document.querySelector('#mbp-changelog-content');
	        this.version = document.querySelector('#mbp-version');
	        this.playSrc = 'menu/play';
	        this.optionsSrc = 'menu/options';
	        this.helpSrc = 'menu/help';
	        this.exitSrc = 'menu/quit';
	        this.showChangelogSrc = 'menu/changelog';
	        this.changelogBackSrc = 'motd/ok';
	    }
	    show() {
	        super.show();
	        G$1.menu.backgroundImage.src = G$1.menu.homeBg;
	    }
	}
	//# sourceMappingURL=home_mbp.js.map

	class MbpLoadingScreen extends LoadingScreen {
	    constructor() {
	        super(...arguments);
	        this.maxProgressBarWidth = 219;
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-loading');
	        this.levelNameElement = document.querySelector('#mbp-loading-level-name');
	        this.cancelButton = document.querySelector('#mbp-loading-cancel');
	        this.progressBar = document.querySelector('#mbp-loading-progress');
	    }
	}
	//# sourceMappingURL=loading_mbp.js.map

	/** The page files to load and show, ordered. */
	const PAGES = ['webport', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22'];
	const FORMAT_COMMAND_REGEX = /<.+?>/g; // Literally the cheapest thing ever
	const ANCHOR_REGEX = /&lt;a:(.+?)&gt;(.+?)&lt;\/a&gt;/g; // Looks a bit shitty 'cuz of escaped HTML stuff
	class MbpHelpScreen extends HelpScreen {
	    constructor() {
	        super(...arguments);
	        this.pagePicker = document.querySelector('#mbp-help-picker');
	        this.pageElements = [];
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-help');
	        this.homeButton = document.querySelector('#mbp-help-home');
	        this.homeButtonSrc = 'manual/home';
	    }
	    /** Fetches all the pages for this help page. */
	    async init() {
	        let promises = [];
	        for (let page of PAGES) {
	            let path = `./assets/ui_mbp/manual/pages/${page}.txt`;
	            promises.push(ResourceManager$1.loadResource(path));
	        }
	        let blobs = await Promise.all(promises);
	        let texts = await Promise.all(blobs.map(x => ResourceManager$1.readBlobAsText(x)));
	        // For each text, create the necessary elements
	        for (let text of texts) {
	            let heading = text.slice(0, text.indexOf('\n')); // The title of each page is its first line
	            let selector = document.createElement('div');
	            selector.textContent = heading;
	            selector.addEventListener('mousedown', () => this.selectPage(texts.indexOf(text)));
	            this.pagePicker.appendChild(selector);
	            let pageElement = document.createElement('div');
	            pageElement.classList.add('_page', 'hidden');
	            pageElement.innerHTML = this.generatePageHtml(text);
	            this.pageElements.push(pageElement);
	            this.div.appendChild(pageElement);
	        }
	        this.selectPage(0);
	    }
	    selectPage(index) {
	        for (let child of this.pagePicker.children)
	            child.classList.remove('selected');
	        this.pagePicker.children[index].classList.add('selected');
	        for (let page of this.pageElements)
	            page.classList.add('hidden');
	        this.pageElements[index].classList.remove('hidden');
	        this.pageElements[index].scrollTop = 0;
	    }
	    /** Turns a subset of TorqueML into HTML. */
	    generatePageHtml(text) {
	        let currentStyle = ''; // The current style used for inserted text
	        let styleStack = []; // Stores previous styles so they can be reverted to
	        let html = '';
	        let heading = text.slice(0, text.indexOf('\n'));
	        let headingElement = document.createElement('h1');
	        headingElement.textContent = heading;
	        html += headingElement.outerHTML;
	        text = text.slice(text.indexOf('\n') + 1);
	        while (true) {
	            FORMAT_COMMAND_REGEX.lastIndex = 0;
	            let nextCommand;
	            while (nextCommand = FORMAT_COMMAND_REGEX.exec(text)) {
	                // Check if the command is a supported one
	                if (nextCommand[0].startsWith('<just') || nextCommand[0].startsWith('<font') || nextCommand[0] === '<spush>' || nextCommand[0] === '<spop>')
	                    break;
	            }
	            let div = document.createElement('div');
	            if (currentStyle)
	                div.setAttribute('style', currentStyle);
	            if (!nextCommand) {
	                // There is no more command found, so dump the remaining text
	                div.textContent = text;
	                if (div.innerHTML)
	                    html += div.outerHTML;
	                break;
	            }
	            div.textContent = text.slice(0, nextCommand.index);
	            if (div.innerHTML)
	                html += div.outerHTML;
	            // Update the text style based on the command
	            if (nextCommand[0].startsWith('<just')) {
	                // Add text align to the style
	                currentStyle += 'text-align: ' + nextCommand[0].slice(6, -1) + ';';
	            }
	            else if (nextCommand[0].startsWith('<font')) {
	                // Add a font family change to the style
	                let font = nextCommand[0].slice(6, nextCommand[0].lastIndexOf(':'));
	                let size = nextCommand[0].slice(nextCommand[0].lastIndexOf(':') + 1, -1);
	                currentStyle += `font-family: ${font};font-size: ${size}px;`;
	            }
	            else if (nextCommand[0] === '<spush>') {
	                // Push the current style to the stack
	                styleStack.push(currentStyle);
	            }
	            else if (nextCommand[0] === '<spop>') {
	                // Pop the last style from the stack into the current style
	                currentStyle = styleStack.pop();
	            }
	            text = text.slice(nextCommand.index + nextCommand[0].length);
	        }
	        // Make links clickable
	        html = html.replace(ANCHOR_REGEX, '<a href="http://$1" target="_blank">$2</a>');
	        return html;
	    }
	}
	//# sourceMappingURL=help_mbp.js.map

	class Lobby {
	    constructor(id, name, settings) {
	        this.sockets = [];
	        this.ownerSessionId = null;
	        this.lastConnectionStatus = null;
	        this.id = id;
	        this.name = name;
	        this.settings = settings;
	    }
	    join() {
	        this.applySettings();
	        G$1.menu.lobbyScreen.onJoin();
	        this.pollerInterval = setInterval(() => {
	            let gameServer = gameServers$1.find(x => x.id === this.settings.gameServer);
	            if (!gameServer)
	                return;
	            if (!gameServer.connection)
	                return;
	            let status = gameServer.connection.socket.getStatus();
	            if (status !== this.lastConnectionStatus) {
	                this.lastConnectionStatus = status;
	                Socket.send('connectionStatus', status);
	            }
	        }, 1000 / 30);
	    }
	    leave(kicked = false) {
	        clearInterval(this.pollerInterval);
	        if (!kicked)
	            Socket.send('leaveLobby', null);
	        let connectedGameServer = gameServers$1.find(x => x.connection);
	        connectedGameServer === null || connectedGameServer === void 0 ? void 0 : connectedGameServer.disconnect();
	        G$1.lobby = null;
	        G$1.menu.lobbyScreen.hide();
	        G$1.menu.lobbySelectScreen.show();
	        if (kicked)
	            G$1.menu.showAlertPopup('Kicked', 'The lobby owner has kicked you out of the lobby.');
	    }
	    onSettingsChanged() {
	        Socket.send('setLobbySettings', this.settings);
	        this.applySettings();
	    }
	    applySettings() {
	        if (this.settings.gameServer) {
	            let gameServer = gameServers$1.find(x => x.id === this.settings.gameServer);
	            if (!gameServer)
	                return;
	            if (!gameServer.connection) {
	                let connectedGameServer = gameServers$1.find(x => x.connection);
	                connectedGameServer === null || connectedGameServer === void 0 ? void 0 : connectedGameServer.disconnect();
	                gameServer.connect('rtc');
	            }
	        }
	        G$1.menu.lobbyScreen.updateUi();
	    }
	    localSessionIsOwner() {
	        return this.ownerSessionId === Connectivity.sessionId;
	    }
	}
	Socket.on('lobbySettingsChange', settings => {
	    let lobby = G$1.lobby;
	    if (!lobby)
	        return;
	    lobby.settings = settings;
	    lobby.applySettings();
	});
	Socket.on('lobbySocketList', list => {
	    let lobby = G$1.lobby;
	    if (!lobby)
	        return;
	    lobby.sockets = list;
	    G$1.menu.lobbyScreen.updatePlayerList(list);
	    G$1.menu.lobbyScreen.updatePlayButton();
	});
	Socket.on('lobbyTextMessage', data => {
	    let lobby = G$1.lobby;
	    if (!lobby)
	        return;
	    G$1.menu.lobbyScreen.addChatMessage(data.username, data.body);
	});
	Socket.on('lobbyOwner', ownerSessionId => {
	    let lobby = G$1.lobby;
	    if (!lobby)
	        return;
	    lobby.ownerSessionId = ownerSessionId;
	    G$1.menu.lobbyScreen.updateUi();
	    G$1.menu.lobbyScreen.updatePlayerList(lobby.sockets);
	});
	Socket.on('kicked', () => {
	    let lobby = G$1.lobby;
	    if (!lobby)
	        return;
	    lobby.leave(true);
	});
	Socket.on('startGame', data => {
	    let lobby = G$1.lobby;
	    if (!lobby)
	        return;
	    lobby.settings = data.lobbySettings; // Make sure we're all on the same page
	    let mission = MissionLibrary.allMissions.find(x => x.path === lobby.settings.missionPath);
	    if (!mission)
	        return;
	    G$1.menu.lobbyScreen.hide();
	    G$1.menu.loadingScreen.loadMissionMultiplayer(mission, lobby, data.gameId, data.seed);
	});
	Socket.on('endGame', () => {
	    let lobby = G$1.lobby;
	    let game = G$1.game;
	    if (!lobby || !game)
	        return;
	    game.stopAndExit(true);
	    G$1.menu.levelSelect.hide();
	    G$1.menu.lobbyScreen.show();
	});
	//# sourceMappingURL=lobby.js.map

	class LobbySelectScreen {
	    constructor(menu) {
	        this.menu = menu;
	        this.initProperties();
	        menu.setupButton(this.closeButton, 'mp/team/close', () => {
	            this.hide();
	            menu.home.show();
	        });
	        menu.setupButton(this.createLobbyButton, 'mp/team/create', () => {
	            Socket.send('createLobbyRequest', null);
	        });
	        Socket.on('lobbyList', list => {
	            this.updateLobbyList(list);
	        });
	        Socket.on('joinLobbyResponse', data => {
	            if (G$1.lobby)
	                throw new Error("Already in a lobby!");
	            this.hide();
	            let newLobby = new Lobby(data.id, data.name, data.settings);
	            G$1.lobby = newLobby;
	            newLobby.join();
	            this.menu.lobbyScreen.show();
	        });
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-lobby-select');
	        this.closeButton = document.querySelector('#mbp-lobby-select-close');
	        this.createLobbyButton = document.querySelector('#mbp-lobby-select-create');
	        this.listContainer = document.querySelector('#mbp-lobby-select-list');
	    }
	    show() {
	        this.div.classList.remove('hidden');
	        G$1.menu.backgroundImage.src = G$1.menu.multiplayerBg;
	        Socket.send('subscribeToLobbyList', null);
	    }
	    hide() {
	        this.div.classList.add('hidden');
	        Socket.send('unsubscribeFromLobbyList', null);
	    }
	    updateLobbyList(list) {
	        this.listContainer.innerHTML = '';
	        for (let lobby of list) {
	            let div = document.createElement('div');
	            let img = document.createElement('img');
	            let mission = MissionLibrary.allMissions.find(x => x.path === lobby.settings.missionPath);
	            img.src = mission.getImagePath();
	            img.title = mission.title;
	            let topText = document.createElement('p');
	            topText.textContent = lobby.name;
	            let bottomText = document.createElement('p');
	            bottomText.innerHTML = `<span style="color: #e5a8ff">Co-op</span>  |  ${lobby.socketCount} Player${lobby.socketCount === 1 ? '' : 's'}`;
	            let statusText = document.createElement('p');
	            statusText.textContent = lobby.status === 'idle' ? 'Waiting' : 'In-Game';
	            if (lobby.status === 'playing')
	                statusText.style.color = '#ffa966';
	            div.append(img, topText, bottomText, statusText);
	            div.addEventListener('click', () => {
	                if (lobby.status === 'playing') {
	                    alert("Cannot join ongoing games right now.");
	                    return;
	                }
	                Socket.send('joinLobbyRequest', lobby.id);
	            });
	            this.listContainer.appendChild(div);
	        }
	    }
	}
	//# sourceMappingURL=lobby_select_screen.js.map

	class LobbyScreen {
	    constructor(menu) {
	        this.currentPlayerActionReceiver = null;
	        this.initProperties();
	        this.menu = menu;
	        menu.setupButton(this.leaveButton, 'mp/play/leave', async () => {
	            let confirmed = await menu.showConfirmPopup("Leave lobby", "Are you sure you want to leave this lobby?");
	            if (!confirmed)
	                return;
	            G$1.lobby.leave();
	        });
	        menu.setupButton(this.playButton, 'play/play', () => {
	            Socket.send('startGameRequest', null);
	        }, true);
	        menu.setupButton(this.serverSelectorCollapsed, 'mp/play/difficulty', () => {
	            if (this.serverSelectorWindow.classList.contains('hidden')) {
	                this.serverSelectorWindow.classList.remove('hidden');
	            }
	            else {
	                this.serverSelectorWindow.classList.add('hidden');
	            }
	        });
	        this.serverSelectorWindow.querySelector('._click-preventer').addEventListener('click', () => {
	            this.serverSelectorWindow.classList.add('hidden');
	        });
	        this.levelImageContainer.addEventListener('mouseenter', () => {
	            AudioManager$1.play('buttonover.wav');
	        });
	        this.levelImageContainer.addEventListener('click', () => {
	            AudioManager$1.play('buttonpress.wav');
	            this.hide();
	            menu.levelSelect.show(true);
	        });
	        this.chatInput.parentElement.addEventListener('submit', e => {
	            e.preventDefault();
	            let body = this.chatInput.value.trim();
	            if (!body)
	                return;
	            this.addChatMessage(StorageManager$1.data.username, body);
	            this.chatInput.value = '';
	            Socket.send('sendLobbyTextMessage', body);
	        });
	        this.chatInput.addEventListener('focus', () => this.chatInput.setAttribute('placeholder', ''));
	        this.chatInput.addEventListener('blur', () => this.chatInput.setAttribute('placeholder', "Type a message"));
	        window.addEventListener('keydown', e => {
	            if (this.div.classList.contains('hidden'))
	                return;
	            if (e.code === 'Enter' && document.activeElement !== this.chatInput) {
	                this.chatInput.focus();
	            }
	        });
	        this.playerActionsContainer.querySelector('._click-preventer').addEventListener('click', () => {
	            this.playerActionsContainer.classList.add('hidden');
	        });
	        menu.setupButton(this.playerActionsContainer.querySelector('#mbp-lobby-player-action-kick'), 'mp/play/kick', async () => {
	            var _a;
	            let confirmed = await menu.showConfirmPopup('Kick Player', `Are you sure you want to kick player ${(_a = G$1.lobby.sockets.find(x => x.id === this.currentPlayerActionReceiver)) === null || _a === void 0 ? void 0 : _a.name} out of this lobby?`);
	            if (!confirmed)
	                return;
	            this.playerActionsContainer.classList.add('hidden');
	            Socket.send('kickSocketOutOfLobby', this.currentPlayerActionReceiver);
	        });
	        menu.setupButton(this.playerActionsContainer.querySelector('#mbp-lobby-player-action-promote'), 'mp/play/empty', async () => {
	            var _a;
	            let confirmed = await menu.showConfirmPopup('Promote Player', `Are you sure you want to promote player ${(_a = G$1.lobby.sockets.find(x => x.id === this.currentPlayerActionReceiver)) === null || _a === void 0 ? void 0 : _a.name} to lobby owner?`);
	            if (!confirmed)
	                return;
	            this.playerActionsContainer.classList.add('hidden');
	            Socket.send('promotePlayer', this.currentPlayerActionReceiver);
	        });
	        this.updateGameServerList();
	    }
	    initProperties() {
	        this.div = document.querySelector('#mbp-lobby');
	        this.leaveButton = document.querySelector('#mbp-lobby-leave');
	        this.serverSelectorCollapsed = document.querySelector('#mbp-lobby-server-selector-collapsed');
	        this.currentServer = document.querySelector('#mbp-lobby-current-server');
	        this.serverSelectorWindow = document.querySelector('#mbp-lobby-server-selector-window');
	        this.noServersMessage = document.querySelector('#mbp-lobby-no-servers');
	        this.levelImageContainer = document.querySelector('#mbp-lobby-image-container');
	        this.levelImage = document.querySelector('#mbp-lobby-image');
	        this.levelTitle = document.querySelector('#mbp-lobby-level-title');
	        this.playerListContainer = document.querySelector('#mbp-lobby-player-list');
	        this.playerActionsContainer = document.querySelector('#mbp-lobby-player-actions');
	        this.playButton = document.querySelector('#mbp-lobby-play');
	        this.chatMessageContainer = document.querySelector('#mbp-lobby-chat-container');
	        this.chatInput = document.querySelector('#mbp-lobby-chat-input');
	    }
	    show() {
	        if (!G$1.lobby)
	            throw new Error("Ah ah ah! ☝");
	        this.div.classList.remove('hidden');
	        this.updateUi();
	        G$1.menu.backgroundImage.src = G$1.menu.multiplayerBg;
	        this.chatMessageContainer.scrollTop = 1e10;
	    }
	    hide() {
	        this.div.classList.add('hidden');
	    }
	    onJoin() {
	        this.chatMessageContainer.innerHTML = '';
	        let startDiv = document.createElement('div');
	        startDiv.textContent = "Welcome to chat!";
	        startDiv.style.opacity = '0.5';
	        this.chatMessageContainer.appendChild(startDiv);
	    }
	    updateUi() {
	        let selectedMission = MissionLibrary.allMissions.find(x => x.path === G$1.lobby.settings.missionPath);
	        if (selectedMission) {
	            this.levelImage.src = selectedMission.getImagePath();
	            this.levelTitle.textContent = selectedMission.title;
	        }
	        if (!G$1.lobby.settings.gameServer) {
	            this.currentServer.textContent = "Select server";
	        }
	        else {
	            let gameServer = gameServers$1.find(x => x.id === G$1.lobby.settings.gameServer);
	            if (!gameServer) {
	                this.currentServer.textContent = "???";
	            }
	            else {
	                this.currentServer.textContent = gameServer.id;
	            }
	        }
	        this.updatePlayButton();
	        if (G$1.lobby.localSessionIsOwner()) {
	            this.serverSelectorCollapsed.src = this.serverSelectorCollapsed.src.replace(/_\w\.png$/, '_n.png');
	            this.serverSelectorCollapsed.style.pointerEvents = '';
	            this.playerListContainer.classList.add('_is-lobby-owner');
	            this.levelImageContainer.style.pointerEvents = '';
	        }
	        else {
	            this.serverSelectorCollapsed.src = this.serverSelectorCollapsed.src.replace(/_\w\.png$/, '_i.png');
	            this.serverSelectorCollapsed.style.pointerEvents = 'none';
	            this.playerListContainer.classList.remove('_is-lobby-owner');
	            this.levelImageContainer.style.pointerEvents = 'none';
	        }
	    }
	    // todo: method name
	    updatePlayerList(list) {
	        var _a, _b;
	        this.playerListContainer.innerHTML = '';
	        for (let player of list) {
	            let div = document.createElement('div');
	            div.innerHTML = `<span>${Util$1.htmlEscape(player.name)}</span>`;
	            if (G$1.lobby.ownerSessionId === player.id)
	                div.innerHTML += '<img src="./assets/img/crown_b.png" class="_lobby-owner-icon" title="Lobby owner">';
	            let statusColor = (_a = {
	                'connecting': '',
	                'connected': '#72e13c'
	            }[player.connectionStatus]) !== null && _a !== void 0 ? _a : '';
	            div.innerHTML += `<span style="color: ${statusColor};">${(_b = {
                'connecting': "Connecting",
                'connected': "Connected"
            }[Util$1.htmlEscape(player.connectionStatus)]) !== null && _b !== void 0 ? _b : "In Lobby"}</span>`;
	            this.playerListContainer.appendChild(div);
	            if (G$1.lobby.localSessionIsOwner() && player.id !== G$1.lobby.ownerSessionId)
	                div.addEventListener('click', () => {
	                    this.playerActionsContainer.classList.remove('hidden');
	                    let wholeBoundingRect = this.div.getBoundingClientRect();
	                    let boundingRect = div.getBoundingClientRect();
	                    this.playerActionsContainer.style.bottom = (boundingRect.top - wholeBoundingRect.top) + 'px';
	                    this.playerActionsContainer.style.left = (boundingRect.left - wholeBoundingRect.left + Math.floor(boundingRect.width / 2)) + 'px';
	                    this.currentPlayerActionReceiver = player.id;
	                });
	        }
	        if (!list.some(x => x.id === this.currentPlayerActionReceiver)) {
	            this.playerActionsContainer.classList.add('hidden'); // Hide the action popup if the player isn't in the lobby anymore
	            this.currentPlayerActionReceiver = null;
	        }
	    }
	    updatePlayButton() {
	        let enabled = !!G$1.lobby.settings.gameServer && G$1.lobby.sockets.every(x => x.connectionStatus === 'connected') && G$1.lobby.localSessionIsOwner();
	        if (enabled && this.playButton.style.pointerEvents === 'none') {
	            this.playButton.style.pointerEvents = '';
	            this.playButton.src = this.playButton.src.replace(/_\w\.png$/, '_n.png');
	        }
	        else if (!enabled) {
	            this.playButton.style.pointerEvents = 'none';
	            this.playButton.src = this.playButton.src.replace(/_\w\.png$/, '_i.png');
	        }
	    }
	    addChatMessage(username, body) {
	        let div = document.createElement('div');
	        div.innerHTML = `<b>${Util$1.htmlEscape(username)}</b>: ${Util$1.htmlEscape(body)}`;
	        let scrolledToBottom = this.chatMessageContainer.scrollHeight - this.chatMessageContainer.scrollTop === this.chatMessageContainer.clientHeight;
	        this.chatMessageContainer.appendChild(div);
	        if (scrolledToBottom)
	            this.chatMessageContainer.scrollTop = 1e6;
	    }
	    updateGameServerList() {
	        this.serverSelectorWindow.querySelector('._content').innerHTML = '';
	        if (gameServers$1.length === 0) {
	            this.noServersMessage.style.display = '';
	            return;
	        }
	        this.noServersMessage.style.display = 'none';
	        for (let gameServer of gameServers$1) {
	            let div = document.createElement('div');
	            let img = document.createElement('img');
	            this.menu.setupButton(img, 'mp/play/difficultysel', () => {
	                G$1.lobby.settings.gameServer = gameServer.id;
	                G$1.lobby.onSettingsChanged();
	                this.serverSelectorWindow.classList.add('hidden');
	            });
	            let p = document.createElement('p');
	            p.textContent = gameServer.id;
	            div.append(img, p);
	            this.serverSelectorWindow.querySelector('._content').append(div);
	        }
	    }
	}
	//# sourceMappingURL=lobby_screen.js.map

	const BACKGROUNDS = {
	    'gold': 12,
	    'platinum': 28,
	    'ultra': 9,
	    'multi': 13
	};
	class MbpMenu extends Menu {
	    constructor() {
	        super();
	        this.audioAssetPath = './assets/data_mbp/sound/';
	        this.menuMusicSrc = 'music/pianoforte.ogg';
	        this.popupBackgroundSrc = './assets/ui_mbp/play/text_window.png';
	        this.popupOkaySrc = 'achiev/close';
	        this.popupNoSrc = 'exit/no';
	        this.popupYesSrc = 'exit/yes';
	        this.lobbySelectScreen = new LobbySelectScreen(this);
	        this.lobbyScreen = new LobbyScreen(this);
	    }
	    get uiAssetPath() {
	        return './assets/ui_mbp/';
	    }
	    createHome() {
	        return new MbpHomeScreen(this);
	    }
	    createLevelSelect() {
	        return new MbpLevelSelect(this);
	    }
	    createLoadingScreen() {
	        return new MbpLoadingScreen(this);
	    }
	    createOptionsScreen() {
	        return new MbpOptionsScreen(this);
	    }
	    createHelpScreen() {
	        return new MbpHelpScreen(this);
	    }
	    createHud() {
	        return new MbpHud$1(this);
	    }
	    createPauseScreen() {
	        return new MbpPauseScreen$1(this);
	    }
	    createFinishScreen() {
	        return new MbpFinishScreen(this);
	    }
	    getMenuDiv() {
	        return document.querySelector('#mbp-menu');
	    }
	    getBackgroundImage() {
	        return document.querySelector('#mbp-background-image');
	    }
	    async init() {
	        // Preselect random backgrounds and load them
	        let homeCategory = Util$1.randomFromArray(Object.keys(BACKGROUNDS));
	        let homeIndex = Math.floor(Math.random() * BACKGROUNDS[homeCategory]) + 1;
	        let mbgIndex = Math.floor(Math.random() * BACKGROUNDS['gold']) + 1;
	        let mbpIndex = Math.floor(Math.random() * BACKGROUNDS['platinum']) + 1;
	        let mbuIndex = Math.floor(Math.random() * BACKGROUNDS['ultra']) + 1;
	        let multiplayerIndex = Math.floor(Math.random() * BACKGROUNDS['multi']) + 1;
	        this.homeBg = './assets/ui_mbp/backgrounds/' + homeCategory + '/' + homeIndex + '.jpg';
	        this.mbgBg = './assets/ui_mbp/backgrounds/' + 'gold/' + mbgIndex + '.jpg';
	        this.mbpBg = './assets/ui_mbp/backgrounds/' + 'platinum/' + mbpIndex + '.jpg';
	        this.mbuBg = './assets/ui_mbp/backgrounds/' + 'ultra/' + mbuIndex + '.jpg';
	        this.multiplayerBg = './assets/ui_mbp/backgrounds/' + 'multi/' + multiplayerIndex + '.jpg';
	        if (Util$1.isWeeb) {
	            this.homeBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.mbgBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.mbpBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.mbuBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	            this.multiplayerBg = `./assets/img/weeb${Math.floor(4 * Math.random() + 1)}.jpg`;
	        }
	        await ResourceManager$1.loadImages([this.homeBg, this.mbgBg, this.mbpBg, this.mbuBg, this.multiplayerBg]);
	        await super.init();
	    }
	}
	//# sourceMappingURL=menu_mbp.js.map

	// I'm pissed. Had to put this in a separate file because Rollup is just too stupid to order stuff correctly.
	let mbgMenu;
	let mbpMenu;
	const switchingMessage = document.querySelector('#switching-message');
	/** Sets the menu to the given modification. */
	const setMenu = async (type) => {
	    var _a;
	    (_a = G$1.menu) === null || _a === void 0 ? void 0 : _a.hide();
	    if (G$1.menu)
	        switchingMessage.classList.remove('hidden');
	    document.querySelector('#favicon').setAttribute('href', (type === 'gold') ? "./assets/img/marble-blast-gold-logo.png" : "./assets/img/mbp.png");
	    if (type === 'gold') {
	        if (mbgMenu) {
	            // It already exists, show it immediately
	            G$1.modification = 'gold';
	            G$1.menu = mbgMenu;
	            mbgMenu.show();
	        }
	        else {
	            // We still need to create it
	            mbgMenu = new MbgMenu();
	            G$1.modification = 'gold';
	            G$1.menu = mbgMenu;
	            await mbgMenu.init();
	            if (mbpMenu)
	                mbgMenu.show();
	        }
	    }
	    else {
	        if (mbpMenu) {
	            // It already exists, show it immediately
	            G$1.modification = 'platinum';
	            G$1.menu = mbpMenu;
	            mbpMenu.show();
	        }
	        else {
	            // We still need to create it
	            mbpMenu = new MbpMenu();
	            G$1.modification = 'platinum';
	            G$1.menu = mbpMenu;
	            await mbpMenu.init();
	            if (mbgMenu)
	                mbpMenu.show();
	        }
	    }
	    switchingMessage.classList.add('hidden');
	    StorageManager$1.data.modification = type;
	    StorageManager$1.store();
	};
	//# sourceMappingURL=menu_setter.js.map

	const loadingMessage = document.querySelector('#loading-message');
	const loadingDetail = document.querySelector('#loading-detail');
	const startGameDialog = document.querySelector('#start-game-dialog');
	const init = async () => {
	    await Util$1.init();
	    await StorageManager$1.init();
	    await ResourceManager$1.init();
	    initMainRenderer();
	    initHudCtx();
	    await Connectivity.init();
	    loadingDetail.textContent = 'Loading levels...';
	    await MissionLibrary.init();
	    AudioManager$1.init();
	    loadingDetail.textContent = 'Loading UI...';
	    await setMenu(StorageManager$1.data.modification);
	    loadingDetail.textContent = 'Loading leaderboard...';
	    await Leaderboard.init();
	    if (Util$1.isWeeb)
	        document.title = 'Marble Blast Weeb'; // <- humor
	    // If we're on a touch device, remind the user that the site can be installed as a PWA
	    if (Util$1.isTouchDevice && !location.search.includes('app')) {
	        let div = document.createElement('div');
	        div.id = 'install-popup';
	        let img = document.createElement('img');
	        img.src = './assets/img/download.png';
	        img.style.display = 'none';
	        div.append(img);
	        img.addEventListener('click', () => {
	            installPromptEvent.prompt();
	        });
	        let intervalId = setInterval(() => {
	            if (installPromptEvent)
	                img.style.display = '';
	        }, 100);
	        G$1.menu.showAlertPopup('Install as app', `This website can be installed on your device's home screen to run in proper fullscreen and feel like a native app. To install it, press the icon below, or if there is none, follow <a href="https://natomasunified.org/kb/add-website-to-mobile-device-home-screen/" target="_blank">these</a> steps.`, div).then(() => {
	            clearInterval(intervalId);
	        });
	    }
	    let started = false;
	    const start = async () => {
	        while (!StorageManager$1.data.username) {
	            StorageManager$1.data.username = prompt("Please choose a username:").trim();
	            StorageManager$1.store();
	        }
	        Socket.send('setUsername', StorageManager$1.data.username);
	        started = true;
	        startGameDialog.style.display = 'none';
	        AudioManager$1.context.resume();
	        G$1.menu.show();
	    };
	    loadingMessage.style.display = 'none';
	    loadingDetail.style.display = 'none';
	    if (AudioManager$1.context.state === "running" && !Util$1.isSafari()) {
	        // Start the game automatically if we already have audio autoplay permission.
	        start();
	        return;
	    }
	    // Otherwise, we need user interaction to start audio.
	    if (Util$1.isInFullscreen() || Util$1.isTouchDevice) {
	        // No need to tell them to enter fullscreen if they're already in it
	        startGameDialog.children[0].textContent = 'Click anywhere to start';
	        startGameDialog.children[1].textContent = '';
	    }
	    else {
	        startGameDialog.children[0].textContent = `Press ${Util$1.isMac() ? '^⌘F' : 'F11'} to start in fullscreen mode`;
	    }
	    startGameDialog.style.display = 'block';
	    window.addEventListener('mousedown', () => {
	        if (started)
	            return;
	        start();
	    });
	    window.addEventListener('pointerdown', () => {
	        if (started)
	            return;
	        start();
	    });
	    window.addEventListener('keydown', (e) => {
	        if (started)
	            return;
	        if (e.code === 'F11' && !Util$1.isInFullscreen())
	            start();
	    });
	};
	window.onload = init;
	let errorTimeout = null;
	// Keep track all errors
	let errorQueue = [];
	window.addEventListener('error', (e) => {
	    errorQueue.push({
	        message: e.error.stack,
	        lineno: e.lineno,
	        colno: e.colno,
	        filename: e.filename
	    });
	    if (errorTimeout === null)
	        sendErrors();
	});
	window.addEventListener('unhandledrejection', (e) => {
	    errorQueue.push({
	        message: e.reason instanceof Error ? e.reason.stack : e.reason.toString(),
	        lineno: 0,
	        colno: 0,
	        filename: 'Unhandled in Promise'
	    });
	    if (errorTimeout === null)
	        sendErrors();
	});
	/** Sends an error report to the server. */
	const sendErrors = () => {
	    errorTimeout = null;
	    if (errorQueue.length === 0)
	        return;
	    let errors = [];
	    errorQueue.length = Math.min(errorQueue.length, 16); // Cap it at 16 errors, we don't wanna be sending too much
	    for (let event of errorQueue) {
	        errors.push({
	            message: event.message,
	            line: event.lineno,
	            column: event.colno,
	            filename: event.filename
	        });
	    }
	    errorQueue.length = 0;
	    if (errors.length > 0) {
	        fetch('./api/error', {
	            method: 'POST',
	            headers: {
	                'Content-Type': 'application/json',
	            },
	            body: JSON.stringify({
	                userAgent: navigator.userAgent,
	                errors: errors
	            })
	        });
	    }
	    // 5-second timeout until it's done again
	    errorTimeout = setTimeout(sendErrors, 5000);
	};
	const activityId = Util$1.uuid();
	setInterval(() => {
	    fetch('/api/activity?id=' + activityId);
	}, 30000);
	// Very basic Service Worker code here:
	if (navigator.serviceWorker) {
	    navigator.serviceWorker.register('/sw.js', {
	        scope: '/'
	    }).then(reg => {
	        reg.update();
	    }).catch(error => {
	        console.log('Service worker registration failed, error:', error);
	    });
	}
	let installPromptEvent = null;
	window.addEventListener('beforeinstallprompt', (e) => {
	    e.preventDefault();
	    installPromptEvent = e; // Save the prompt for later
	});
	//# sourceMappingURL=index.js.map

}());
